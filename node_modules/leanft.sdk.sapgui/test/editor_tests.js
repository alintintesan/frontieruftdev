// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 06/24/2016.
 */

var assert = require("assert");
var sinon = require("sinon");

describe("Editor Description", function () {

    var Editor = require("../lib/editor.js").Editor;
    var editorDescriptionUnderTest;

    beforeEach(function () {
        editorDescriptionUnderTest = Editor();
    });

    describe("Constructor", function () {
        it("should assign 'SAPGUI' and 'Editor' LeanFT type", function () {
            editorDescriptionUnderTest = new Editor();
            assert.deepEqual(editorDescriptionUnderTest.leanFTType, {
                technology: "SAPGUI",
                leanftType: "Editor"
            });
        });
    });

    describe("text method", function () {
        it("should add 'Value' to _properties when value is given", function () {
            editorDescriptionUnderTest.text("EditFieldText");
            assert.strictEqual(editorDescriptionUnderTest._properties["Value"], "EditFieldText");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = editorDescriptionUnderTest.text("EditFieldText");
            assert.strictEqual(result, editorDescriptionUnderTest);
        });

        it("should remove 'Value' from _properties when value is null", function () {
            editorDescriptionUnderTest._properties["Value"] = "EditFieldText";
            editorDescriptionUnderTest.text(null);
            assert(!("Value" in editorDescriptionUnderTest._properties));
        });

        it("should return the value of 'Value' from _properties when value is not given", function () {
            editorDescriptionUnderTest._properties["Value"] = "EditFieldText";
            var value = editorDescriptionUnderTest.text();
            assert.strictEqual(value, "EditFieldText");
        });
    });

    describe("isEnabled method", function () {
        it("should add 'Enabled' to _properties when value is given", function () {
            editorDescriptionUnderTest.isEnabled(true);
            assert.strictEqual(editorDescriptionUnderTest._properties["Enabled"], true);
        });

        it("should add 'Enabled' to _properties when value is given in string", function () {
            editorDescriptionUnderTest.isEnabled("true");
            assert.strictEqual(editorDescriptionUnderTest._properties["Enabled"], true);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editorDescriptionUnderTest.isEnabled(true);
            assert.strictEqual(result, editorDescriptionUnderTest);
        });

        it("should remove 'Enabled' from _properties when value is null", function () {
            editorDescriptionUnderTest._properties["Enabled"] = true;
            editorDescriptionUnderTest.isEnabled(null);
            assert(!("Enabled" in editorDescriptionUnderTest._properties));
        });

        it("should return the value of 'Enabled' from _properties when value is not given", function () {
            editorDescriptionUnderTest._properties["Enabled"] = true;
            var result = editorDescriptionUnderTest.isEnabled();
            assert.equal(result, true);
        });
    });
});

describe("Editor Test Object", function () {
    var EditorTO = require("../lib/editor.js").EditorTO;
    var editorTOUnderTest;

    beforeEach(function () {
        editorTOUnderTest = new EditorTO();
        sinon.stub(editorTOUnderTest, "_getROProperty");
        sinon.stub(editorTOUnderTest, "_executeWithEvents");
    });

    describe("text method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTOUnderTest._getROProperty.returns(executionPromise);
            var res = editorTOUnderTest.text();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'Value' with correct parameters", function () {
            editorTOUnderTest.text();
            sinon.assert.calledOnce(editorTOUnderTest._getROProperty);
            sinon.assert.calledWith(editorTOUnderTest._getROProperty, "Value", sinon.match({}));
        });
    });

    describe("isEnabled method", function () {
        it("should return the execution promise", function () {
            var promiseMock = {};
            editorTOUnderTest._getROProperty.returns(promiseMock);
            var res = editorTOUnderTest.isEnabled();
            assert.strictEqual(res, promiseMock);
        });

        it("should execute _getROProperty 'Enabled'", function () {
            editorTOUnderTest.isEnabled();
            sinon.assert.calledOnce(editorTOUnderTest._getROProperty);
            sinon.assert.calledWith(editorTOUnderTest._getROProperty, "Enabled", sinon.match({}));
        });
    });

    describe("doubleClick method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTOUnderTest.doubleClick();
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'DoubleClick'", function () {
            editorTOUnderTest.doubleClick();
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({}), "DoubleClick");
        });
    });

    describe("setText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTOUnderTest.setText("EditorFieldText");
            assert.equal(res, executionPromise);
        });

        it("should throw error if the text is undefined", function () {
            assert.throws(function () {
                editorTOUnderTest.setText();
            });
        });

        it("should throw error if the text is null", function () {
            assert.throws(function () {
                editorTOUnderTest.setText(null);
            });
        });

        it("should execute _executeWithEvents 'Set' if the text is defined", function () {
            editorTOUnderTest.setText("EditorFieldText");
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: "EditorFieldText" }), "Set", "EditorFieldText");
        });
    });

    describe("setCursorPosition method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTOUnderTest.setCursorPosition(100);
            assert.equal(res, executionPromise);
        });

        it("should throw error if position is undefined", function () {
            assert.throws(function () {
                editorTOUnderTest.setCursorPosition();
            });
        });

        it("should throw error if position is null", function () {
            assert.throws(function () {
                editorTOUnderTest.setCursorPosition(null);
            });
        });

        it("should execute _executeWithEvents 'SetSelectionIndexes' if position is defined as number", function () {
            editorTOUnderTest.setCursorPosition(100);
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: 100 }), "SetSelectionIndexes", 100, 100);
        });

        it("should execute _executeWithEvents 'SetSelectionIndexes' if position is defined as string", function () {
            editorTOUnderTest.setCursorPosition("100");
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: "100"}), "SetSelectionIndexes", 100, 100);
        });
    });

    describe("select method", function () {
        it("should throw error if startPos is undefined", function () {
            assert.throws(function () {
                editorTOUnderTest.select();
            });
        });

        it("should throw error if startPos is null", function () {
            assert.throws(function () {
                editorTOUnderTest.select(null);
            });
        });

        it("should throw error if endPos is undefined", function () {
            assert.throws(function () {
                editorTOUnderTest.select(0);
            });
        });

        it("should throw error if endPos is null", function () {
            assert.throws(function () {
                editorTOUnderTest.select(0, null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTOUnderTest.select(0, 200);
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetSelectionIndexes' if parameters are all number", function () {
            editorTOUnderTest.select(1,200);
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: 1, 1: 200 }), "SetSelectionIndexes", 1, 201);
        });

        it("should execute _executeWithEvents 'SetSelectionIndexes' if parameters are all string", function () {
            editorTOUnderTest.select("1", "200");
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: "1", 1: "200" }), "SetSelectionIndexes", 1, 201);
        });

        it("should execute _executeWithEvents 'SetSelectionIndexes' if parameters are strings and numbers", function () {
            editorTOUnderTest.select("1", 200);
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: "1", 1: 200 }), "SetSelectionIndexes", 1, 201);
        });
    });

    describe("setUnprotectedTextPart method", function () {
        it("should throw error if sectionNumber is undefined", function () {
            assert.throws(function () {
                editorTOUnderTest.setUnprotectedTextPart();
            });
        });

        it("should throw error if sectionNumber is null", function () {
            assert.throws(function () {
                editorTOUnderTest.setUnprotectedTextPart(null);
            });
        });

        it("should throw error if text is undefined", function () {
            assert.throws(function () {
                editorTOUnderTest.setUnprotectedTextPart(0);
            });
        });

        it("should throw error if text is null", function () {
            assert.throws(function () {
                editorTOUnderTest.setUnprotectedTextPart(0, null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTOUnderTest.setUnprotectedTextPart(100, "EditorTextPart");
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetUnprotectedTextPart' if sectionNumber is defined as number", function () {
            editorTOUnderTest.setUnprotectedTextPart(100,"EditorTextPart");
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: 100, 1: "EditorTextPart" }), "SetUnprotectedTextPart", 100, "EditorTextPart");
        });

        it("should execute _executeWithEvents 'SetUnprotectedTextPart' if sectionNumber is defined as string", function () {
            editorTOUnderTest.setUnprotectedTextPart("100", "EditorTextPart");
            sinon.assert.calledOnce(editorTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTOUnderTest._executeWithEvents, sinon.match({ 0: "100", 1: "EditorTextPart" }), "SetUnprotectedTextPart", 100, "EditorTextPart");
        });
    });
});
