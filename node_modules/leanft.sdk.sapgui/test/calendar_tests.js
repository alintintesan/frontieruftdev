// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 06/20/2016.
 */

var assert = require("assert");
var sinon = require("sinon");

describe("CalendarDescriptionBehavior", function () {

    var Calendar = require("../lib/calendar.js").Calendar;
    var calendarUnderTest;

    beforeEach(function () {
        calendarUnderTest = new Calendar();
    });

    describe("attachedText method", function () {
        it("should add 'AttachedText' to _properties when value is given", function () {
            calendarUnderTest.attachedText("Text");
            assert.strictEqual(calendarUnderTest._properties["AttachedText"], "Text");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = calendarUnderTest.attachedText("Text");
            assert.strictEqual(result, calendarUnderTest);
        });

        it("should remove 'AttachedText' from _properties when value is null", function () {
            calendarUnderTest._properties["AttachedText"] = "Text";
            calendarUnderTest.attachedText(null);
            assert(!("AttachedText" in calendarUnderTest._properties));
        });

        it("should return the value of 'AttachedText' from _properties when value is not given", function () {
            calendarUnderTest._properties["AttachedText"] = "Text";
            var value = calendarUnderTest.attachedText();
            assert.strictEqual(value, "Text");
        });
    });

    describe("isEnabled method", function () {
        it("should add 'Enabled' to _properties when value is given", function () {
            calendarUnderTest.isEnabled(true);
            assert.strictEqual(calendarUnderTest._properties["Enabled"], true);
        });

        it("should add 'Enabled' to _properties when value is given in string", function () {
            calendarUnderTest.isEnabled("true");
            assert.strictEqual(calendarUnderTest._properties["Enabled"], true);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = calendarUnderTest.isEnabled(true);
            assert.strictEqual(result, calendarUnderTest);
        });

        it("should remove 'Enabled' from _properties when value is null", function () {
            calendarUnderTest._properties["Enabled"] = true;
            calendarUnderTest.isEnabled(null);
            assert(!("Enabled" in calendarUnderTest._properties));
        });

        it("should return the value of 'Enabled' from _properties when value is not given", function () {
            calendarUnderTest._properties["Enabled"] = true;
            var result = calendarUnderTest.isEnabled();
            assert.equal(result, true);
        });
    });
});

describe("CalendarTO Test Object", function () {

    var CalendarTO = require("../lib/calendar.js").CalendarTO;
    var calendarTOUnderTest;

    beforeEach(function () {
        calendarTOUnderTest = new CalendarTO();
        sinon.stub(calendarTOUnderTest, "_executeWithEvents");
        sinon.stub(calendarTOUnderTest, "_getROProperty");
        sinon.stub(calendarTOUnderTest, "_getROProperties");
    });

    afterEach(function () {
        calendarTOUnderTest._executeWithEvents.restore();
        calendarTOUnderTest._getROProperty.restore();
        calendarTOUnderTest._getROProperties.restore();
    });

    describe("isEnabled method", function () {
        it("should return the execution promise", function () {
            var promiseMock = {};
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.isEnabled();
            assert.strictEqual(res, promiseMock);
        });

        it("should execute _getROProperty 'Enabled'", function () {
            calendarTOUnderTest.isEnabled();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "Enabled", sinon.match({}));
        });
    });

    describe("attachedText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._getROProperty.returns(executionPromise);
            var res = calendarTOUnderTest.attachedText();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'AttachedText' with correct parameters", function () {
            calendarTOUnderTest.attachedText();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "AttachedText", sinon.match({}));
        });
    });

    describe("dateRange method", function () {
        it("should execute _getROProperties 'DateRangeStart' 'DateRangeEnd' with correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(["17/Mar/2016", "18/May/2016"]);
                }
            };
            calendarTOUnderTest._getROProperties.returns(promiseMock);
            calendarTOUnderTest.dateRange();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperties);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperties, sinon.match({}), "DateRangeStart", "DateRangeEnd");
        });

        it("should return null if DateRangeStart is null", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb([null, "18/May/2016"]);
                }
            };
            calendarTOUnderTest._getROProperties.returns(promiseMock);
            var res = calendarTOUnderTest.dateRange();
            assert.strictEqual(res, null);
        });

        it("should return null if DateRangeStart is empty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(["", "18/May/2016"]);
                }
            };
            calendarTOUnderTest._getROProperties.returns(promiseMock);
            var res = calendarTOUnderTest.dateRange();
            assert.strictEqual(res, null);
        });

        it("should return null if DateRangeEnd is null", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(["18/May/2016", null]);
                }
            };
            calendarTOUnderTest._getROProperties.returns(promiseMock);
            var res = calendarTOUnderTest.dateRange();
            assert.strictEqual(res, null);
        });

        it("should return null if DateRangeEnd is empty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(["18/May/2016", ""]);
                }
            };
            calendarTOUnderTest._getROProperties.returns(promiseMock);
            var res = calendarTOUnderTest.dateRange();
            assert.strictEqual(res, null);
        });

        it("should return a dateRange if return data is valid", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(["17/Mar/2016", "18/May/2016"]);
                }
            };
            calendarTOUnderTest._getROProperties.returns(promiseMock);
            var res = calendarTOUnderTest.dateRange();
            assert.deepEqual(res, {startDate: new Date(2016, 2, 17), endDate: new Date(2016, 4, 18)});
        });
    });

    describe("date method", function () {
        it("should execute _getROProperty 'SelectedDate' with correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("17/Mar/2016");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            calendarTOUnderTest.date();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "SelectedDate", sinon.match({}));
        });

        it("should throw error if SelectedDate is null", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(null);
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOUnderTest.date();
            });
        });

        it("should throw error if SelectedDate is empty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOUnderTest.date();
            });
        });

        it("should return a Date if return data is valid", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("17/Mar/2016");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.date();
            assert.deepEqual(res, new Date(2016, 2, 17));
        });
    });

    describe("setDate method", function () {
        it("should throw error if date is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDate();
            });
        });

        it("should throw error if date is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDate(null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = calendarTOUnderTest.setDate(new Date(2016, 2, 17));
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetDate' with correct parameter", function () {
            var date = new Date(2016, 2, 17);
            calendarTOUnderTest.setDate(date);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: date }), "SetDate", "17/Mar/2016");
        });
    });

    describe("setDateRange method", function () {
        it("should throw error if dateRangeOrStartDate is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange();
            });
        });

        it("should throw error if dateRangeOrStartDate is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange(null);
            });
        });

        it("should throw error if endDate is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange(new Date(2016, 2, 17));
            });
        });

        it("should throw error if endDate is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange(new Date(2016, 2, 17), null);
            });
        });

        it("should throw error if dateRangeOrStartDate is an object and no have startDate", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange({ endDate: new Date(2016, 2, 17) });
            });
        });

        it("should throw error if dateRangeOrStartDate is an object and no have endDate", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange({ startDate: new Date(2016, 2, 17) });
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = calendarTOUnderTest.setDateRange(new Date(2016, 2, 17), new Date(2016, 4, 18));
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetDateRange' with correct parameter if input paramters are 2 dates", function () {
            var date1 = new Date(2016, 2, 17);
            var date2 = new Date(2016, 4, 18);
            calendarTOUnderTest.setDateRange(date1, date2);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: date1, 1: date2 }), "SetDateRange", "17/Mar/2016", "18/May/2016");
        });

        it("should execute _executeWithEvents 'SetDateRange' with correct parameter if input paramater is an object", function () {
            var date1 = new Date(2016, 2, 17);
            var date2 = new Date(2016, 4, 18);
            var range = {startDate: date1, endDate: date2};
            calendarTOUnderTest.setDateRange(range);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: range }), "SetDateRange", "17/Mar/2016", "18/May/2016");
        });
    });
});