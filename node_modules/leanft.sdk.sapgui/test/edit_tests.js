// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 06/24/2016.
 */

var assert = require("assert");
var sinon = require("sinon");

describe("Edit Description", function () {

    var Edit = require("../lib/edit.js").Edit;
    var editDescriptionUnderTest;

    beforeEach(function () {
        editDescriptionUnderTest = Edit();
    });

    describe("Constructor", function () {
        it("should assign 'SAPGUI' and 'EditField' LeanFT type", function () {
            editDescriptionUnderTest = new Edit();
            assert.deepEqual(editDescriptionUnderTest.leanFTType, {
                technology: "SAPGUI",
                leanftType: "EditField"
            });
        });
    });

    describe("attachedText method", function () {
        it("should add 'AttachedText' to _properties when value is given", function () {
            editDescriptionUnderTest.attachedText("EditFieldText");
            assert.strictEqual(editDescriptionUnderTest._properties["AttachedText"], "EditFieldText");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = editDescriptionUnderTest.attachedText("EditFieldText");
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'AttachedText' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["AttachedText"] = "EditFieldText";
            editDescriptionUnderTest.attachedText(null);
            assert(!("AttachedText" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'AttachedText' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["AttachedText"] = "EditFieldText";
            var value = editDescriptionUnderTest.attachedText();
            assert.strictEqual(value, "EditFieldText");
        });
    });

    describe("isEnabled method", function () {
        it("should add 'Enabled' to _properties when value is given", function () {
            editDescriptionUnderTest.isEnabled(true);
            assert.strictEqual(editDescriptionUnderTest._properties["Enabled"], true);
        });

        it("should add 'Enabled' to _properties when value is given in string", function () {
            editDescriptionUnderTest.isEnabled("true");
            assert.strictEqual(editDescriptionUnderTest._properties["Enabled"], true);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editDescriptionUnderTest.isEnabled(true);
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'Enabled' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["Enabled"] = true;
            editDescriptionUnderTest.isEnabled(null);
            assert(!("Enabled" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'Enabled' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["Enabled"] = true;
            var result = editDescriptionUnderTest.isEnabled();
            assert.equal(result, true);
        });
    });

    describe("isHighlighted method", function () {
        it("should add 'Highlighted' to _properties when value is given", function () {
            editDescriptionUnderTest.isHighlighted(true);
            assert.strictEqual(editDescriptionUnderTest._properties["Highlighted"], true);
        });

        it("should add 'Highlighted' to _properties when value is given in string", function () {
            editDescriptionUnderTest.isHighlighted("true");
            assert.strictEqual(editDescriptionUnderTest._properties["Highlighted"], true);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editDescriptionUnderTest.isHighlighted(true);
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'Highlighted' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["Highlighted"] = true;
            editDescriptionUnderTest.isHighlighted(null);
            assert(!("Highlighted" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'Highlighted' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["Highlighted"] = true;
            var result = editDescriptionUnderTest.isHighlighted();
            assert.equal(result, true);
        });
    });


    describe("iconName method", function () {
        it("should add 'IconName' to _properties when value is given", function () {
            editDescriptionUnderTest.iconName("SAPGUIIconName");
            assert.strictEqual(editDescriptionUnderTest._properties["IconName"], "SAPGUIIconName");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = editDescriptionUnderTest.iconName("SAPGUIIconName");
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'IconName' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["IconName"] = "SAPGUIIconName";
            editDescriptionUnderTest.iconName(null);
            assert(!("IconName" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'IconName' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["IconName"] = "SAPGUIIconName";
            var value = editDescriptionUnderTest.iconName();
            assert.strictEqual(value, "SAPGUIIconName");
        });
    });

    describe("maxLength method", function () {
        it("should add 'MaxLength' to _properties when value is given", function () {
            editDescriptionUnderTest.maxLength(1000);
            assert.strictEqual(editDescriptionUnderTest._properties["MaxLength"], 1000);
        });

        it("should add 'MaxLength' to _properties when value is given in string", function () {
            editDescriptionUnderTest.maxLength("1000");
            assert.strictEqual(editDescriptionUnderTest._properties["MaxLength"], 1000);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editDescriptionUnderTest.maxLength(1000);
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'MaxLength' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["MaxLength"] = 1000;
            editDescriptionUnderTest.maxLength(null);
            assert(!("MaxLength" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'MaxLength' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["MaxLength"] = 1000;
            var result = editDescriptionUnderTest.maxLength();
            assert.equal(result, 1000);
        });
    });

    describe("isNumerical method", function () {
        it("should add 'Numerical' to _properties when value is given", function () {
            editDescriptionUnderTest.isNumerical(true);
            assert.strictEqual(editDescriptionUnderTest._properties["Numerical"], true);
        });

        it("should add 'Numerical' to _properties when value is given in string", function () {
            editDescriptionUnderTest.isNumerical("true");
            assert.strictEqual(editDescriptionUnderTest._properties["Numerical"], true);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editDescriptionUnderTest.isNumerical(true);
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'Numerical' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["Numerical"] = true;
            editDescriptionUnderTest.isNumerical(null);
            assert(!("Numerical" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'Numerical' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["Numerical"] = true;
            var result = editDescriptionUnderTest.isNumerical();
            assert.equal(result, true);
        });
    });

    describe("isRequired method", function () {
        it("should add 'Required' to _properties when value is given", function () {
            editDescriptionUnderTest.isRequired(true);
            assert.strictEqual(editDescriptionUnderTest._properties["Required"], true);
        });

        it("should add 'Required' to _properties when value is given in string", function () {
            editDescriptionUnderTest.isRequired("true");
            assert.strictEqual(editDescriptionUnderTest._properties["Required"], true);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editDescriptionUnderTest.isRequired(true);
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'Required' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["Required"] = true;
            editDescriptionUnderTest.isRequired(null);
            assert(!("Required" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'Required' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["Required"] = true;
            var result = editDescriptionUnderTest.isRequired();
            assert.equal(result, true);
        });
    });

    describe("text method", function () {
        it("should add 'Value' to _properties when value is given", function () {
            editDescriptionUnderTest.text("EditFieldText");
            assert.strictEqual(editDescriptionUnderTest._properties["Value"], "EditFieldText");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = editDescriptionUnderTest.text("EditFieldText");
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'Value' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["Value"] = "EditFieldText";
            editDescriptionUnderTest.text(null);
            assert(!("Value" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'Value' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["Value"] = "EditFieldText";
            var value = editDescriptionUnderTest.text();
            assert.strictEqual(value, "EditFieldText");
        });
    });
});

describe("Edit Test Object", function () {
    var EditTO = require("../lib/edit.js").EditTO;
    var editTestObjectUnderTest;

    beforeEach(function () {
        editTestObjectUnderTest = new EditTO();
        sinon.stub(editTestObjectUnderTest, "_getROProperty");
        sinon.stub(editTestObjectUnderTest, "_executeWithEvents");
    });

    describe("attachedText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.attachedText();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'AttachedText' with correct parameters", function () {
            editTestObjectUnderTest.attachedText();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "AttachedText", sinon.match({}));
        });
    });

    describe("isEnabled method", function () {
        it("should return the execution promise", function () {
            var promiseMock = {};
            editTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = editTestObjectUnderTest.isEnabled();
            assert.strictEqual(res, promiseMock);
        });

        it("should execute _getROProperty 'Enabled'", function () {
            editTestObjectUnderTest.isEnabled();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "Enabled", sinon.match({}));
        });
    });

    describe("isHighlighted method", function () {
        it("should return the execution promise", function () {
            var promiseMock = {};
            editTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = editTestObjectUnderTest.isHighlighted();
            assert.strictEqual(res, promiseMock);
        });

        it("should execute _getROProperty 'Highlighted'", function () {
            editTestObjectUnderTest.isHighlighted();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "Highlighted", sinon.match({}));
        });
    });

    describe("iconName method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.iconName();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'IconName' with correct parameters", function () {
            editTestObjectUnderTest.iconName();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "IconName", sinon.match({}));
        });
    });

    describe("maxLength method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.maxLength();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'MaxLength' with correct parameters", function () {
            editTestObjectUnderTest.maxLength();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "MaxLength", sinon.match({}));
        });
    });

    describe("isNumerical method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.isNumerical();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'Numerical' with correct parameters", function () {
            editTestObjectUnderTest.isNumerical();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "Numerical", sinon.match({}));
        });
    });

    describe("isRequired method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.isRequired();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'Required' with correct parameters", function () {
            editTestObjectUnderTest.isRequired();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "Required", sinon.match({}));
        });
    });

    describe("text method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.text();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'Value' with correct parameters", function () {
            editTestObjectUnderTest.text();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "Value", sinon.match({}));
        });
    });

    describe("openPossibleEntries method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.openPossibleEntries();
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'OpenPossibleEntries'", function () {
            editTestObjectUnderTest.openPossibleEntries();
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({}), "OpenPossibleEntries");
        });
    });

    describe("setText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setText("EditFieldText");
            assert.equal(res, executionPromise);
        });

        it("should throw error if the text is undefined", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setText();
            });
        });

        it("should throw error if the text is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setText(null);
            });
        });

        it("should execute _executeWithEvents 'Set' if the text is defined", function () {
            editTestObjectUnderTest.setText("EditFieldText");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "EditFieldText" }), "Set", "EditFieldText");
        });
    });

    describe("setCursorPosition method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setCursorPosition(100);
            assert.equal(res, executionPromise);
        });

        it("should throw error if position is undefined", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setCursorPosition();
            });
        });

        it("should throw error if position is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setCursorPosition(null);
            });
        });

        it("should execute _executeWithEvents 'SetCaretPos' if position is defined as number", function () {
            editTestObjectUnderTest.setCursorPosition(100);
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: 100 }), "SetCaretPos", 100);
        });

        it("should execute _executeWithEvents 'SetCaretPos' if position is defined as string", function () {
            editTestObjectUnderTest.setCursorPosition("100");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "100"}), "SetCaretPos", 100);
        });
    });

    describe("setFocus method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setFocus();
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetFocus'", function () {
            editTestObjectUnderTest.setFocus();
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({}), "SetFocus");
        });
    });

    describe("setSecure method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setSecure("SecuredText");
            assert.equal(res, executionPromise);
        });

        it("should throw error if the secured text is undefined", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setSecure();
            });
        });

        it("should throw error if the secured text is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setSecure(null);
            });
        });

        it("should execute _executeWithEvents 'SetSecure' if the secured text is defined", function () {
            editTestObjectUnderTest.setSecure("SecuredText");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "SecuredText" }), "SetSecure", "SecuredText");
        });
    });
});
