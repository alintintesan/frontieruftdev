// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

var assert = require("assert");
var sinon = require("sinon");

describe("DateTimeInput Description unit tests", function() {
    var DateTimeInputDesc = require("../lib/date_time_input.js").DateTimeInput;
    var dateTimeInputDescUnderTest;

    beforeEach(function() {
        dateTimeInputDescUnderTest = new DateTimeInputDesc();
    });

    describe("placeholder method",function() {
        it("should add 'placeholder' with the correct value",function(){
            dateTimeInputDescUnderTest.placeholder('placeholder');
            assert.strictEqual(dateTimeInputDescUnderTest._properties["placeholder"], 'placeholder');
        });
        it("should add 'placeholder' with correct value when value is given using property bag",function(){
            dateTimeInputDescUnderTest = DateTimeInputDesc({
                placeholder: 'placeholder'
            });
            assert.strictEqual(dateTimeInputDescUnderTest._properties["placeholder"], 'placeholder');
        });
        it("should return this - builder pattern when value is given",function(){
            var result = dateTimeInputDescUnderTest.placeholder('placeholder');
            assert.strictEqual(result, dateTimeInputDescUnderTest);
        });
        it("should remove 'placeholder' from _properties when value is null",function(){
            dateTimeInputDescUnderTest._properties["placeholder"] = 'placeholder';
            dateTimeInputDescUnderTest.placeholder(null);
            assert(!("placeholder" in dateTimeInputDescUnderTest._properties));
        });
        it("should return the value of 'placeholder' from _properties when value is not given",function(){
            dateTimeInputDescUnderTest._properties["placeholder"] = 'placeholder';
            var placeholderLevel = dateTimeInputDescUnderTest.placeholder();
            assert.equal(placeholderLevel, 'placeholder');
        });
    });

    describe("displayFormat method",function() {
        it("should add 'display format' with the correct value",function(){
            dateTimeInputDescUnderTest.displayFormat(5);
            assert.strictEqual(dateTimeInputDescUnderTest._properties["display format"], 5);
        });
        it("should add 'maximum placeholder' with correct value when value is given using property bag",function(){
            dateTimeInputDescUnderTest = DateTimeInputDesc({
                displayFormat: 'yyyyMMdd'
            });
            assert.strictEqual(dateTimeInputDescUnderTest._properties["display format"], 'yyyyMMdd');
        });
        it("should return this - builder pattern when value is given",function(){
            var result = dateTimeInputDescUnderTest.displayFormat('yyyyMMdd');
            assert.strictEqual(result, dateTimeInputDescUnderTest);
        });
        it("should remove 'display format' from _properties when value is null",function(){
            dateTimeInputDescUnderTest._properties["display format"] = 'yyyyMMdd';
            dateTimeInputDescUnderTest.displayFormat(null);
            assert(!("display format" in dateTimeInputDescUnderTest._properties));
        });
        it("should return the value of 'display format' from _properties when value is not given",function(){
            dateTimeInputDescUnderTest._properties["display format"] = 'yyyyMMdd';
            var format = dateTimeInputDescUnderTest.displayFormat();
            assert.equal(format, 'yyyyMMdd');
        });
    });

    describe("dateType method",function() {
        it("should add 'dateType' with the correct value",function(){
            dateTimeInputDescUnderTest.dateType("DateTime");
            assert.strictEqual(dateTimeInputDescUnderTest._properties["date type"], "DateTime");
        });
        it("should add 'dateType' with correct value when value is given using property bag",function(){
            dateTimeInputDescUnderTest = DateTimeInputDesc({
                dateType: "DateTime"
            });
            assert.strictEqual(dateTimeInputDescUnderTest._properties["date type"], "DateTime");
        });
        it("should return this - builder pattern when value is given",function(){
            var result = dateTimeInputDescUnderTest.dateType("DateTime");
            assert.strictEqual(result, dateTimeInputDescUnderTest);
        });
        it("should remove 'dateType' from _properties when value is null",function(){
            dateTimeInputDescUnderTest._properties["date type"] = "DateTime";
            dateTimeInputDescUnderTest.dateType(null);
            assert(!("date type" in dateTimeInputDescUnderTest._properties));
        });
        it("should return the value of 'date type' from _properties when value is not given",function(){
            dateTimeInputDescUnderTest._properties["date type"] = "DateTime";
            var dateType = dateTimeInputDescUnderTest.dateType();
            assert.equal(dateType, "DateTime");
        });
    });
});

describe("DateTimeInput Test Object Behavior",function(){
    var DateTimeInputTO = require("../lib/date_time_input.js").DateTimeInputTO;
    var dateTimeInputTOBehaviorUnderTest;

    beforeEach(function(){
        dateTimeInputTOBehaviorUnderTest = DateTimeInputTO({});
        sinon.stub(dateTimeInputTOBehaviorUnderTest, "_executeCommand");
        sinon.stub(dateTimeInputTOBehaviorUnderTest, "_getROProperty");
		
		dateTimeInputTOBehaviorUnderTest._session.fireEvent = sinon.stub();
        dateTimeInputTOBehaviorUnderTest._session._promiseManager = {wrapPromiseFunctionWithNotifyEvents: function () {} };
        sinon.stub(dateTimeInputTOBehaviorUnderTest._session._promiseManager, "wrapPromiseFunctionWithNotifyEvents", function (onStart, promiseFunc) {
            return promiseFunc();
        });
    });

    describe("setDateTime",function(){
        it("should call the _executeCommand method and pass it the correct arguments",function(){
            dateTimeInputTOBehaviorUnderTest.setDateTime(new Date("2016-01-01,12:30:55"));
            assert(dateTimeInputTOBehaviorUnderTest._executeCommand.calledOnce);
            assert.deepEqual(dateTimeInputTOBehaviorUnderTest._executeCommand.firstCall.args.slice(0, 2), ["SetDateTime","20160101,12:30:55"]);
        });
        it("should return the same promise that was returned from _executeCommand",function(){
            var getROPromise = {};
            dateTimeInputTOBehaviorUnderTest._executeCommand.returns(getROPromise);
            var res = dateTimeInputTOBehaviorUnderTest.setDateTime(new Date("2016-01-01,12:30:55"));
            assert.strictEqual(res,getROPromise);
        });
        it("should throw exception if parameter is not Date object",function(){
            assert.throws(function() {
                dateTimeInputTOBehaviorUnderTest.setDateTime("2016-01-01");
            });
        });
    });

    describe("value",function(){
        var promiseMock = {then: function(cb) {return cb("20160107,12:30:55");}};
        it("should call the _executeCommand method and pass it the correct arguments",function(){
            dateTimeInputTOBehaviorUnderTest._executeCommand.returns(promiseMock);
            dateTimeInputTOBehaviorUnderTest.value();
            assert(dateTimeInputTOBehaviorUnderTest._executeCommand.calledOnce);
            assert.deepEqual(dateTimeInputTOBehaviorUnderTest._executeCommand.firstCall.args.slice(0, 1), ["GetDateTime"]);
        });

        it("should return the same promise that was returned from _executeCommand",function(){
            dateTimeInputTOBehaviorUnderTest._executeCommand.returns(promiseMock);
            var res = dateTimeInputTOBehaviorUnderTest.value();
            assert.strictEqual(res.toLocaleString(),new Date('2016-01-07,12:30:55').toLocaleString());
        });
    });

    describe("placeholder",function(){
        it("should query the property 'placeholder'",function(){
            dateTimeInputTOBehaviorUnderTest.placeholder();
            assert(dateTimeInputTOBehaviorUnderTest._getROProperty.calledOnce);
            assert.deepEqual(dateTimeInputTOBehaviorUnderTest._getROProperty.firstCall.args,["placeholder", arguments]);
        });
        it("should return the same promise that was returned from _getROProperty",function(){
            var getROPromise = {};
            dateTimeInputTOBehaviorUnderTest._getROProperty.returns(getROPromise);
            var res = dateTimeInputTOBehaviorUnderTest.placeholder();
            assert.strictEqual(res,getROPromise);
        });
    });

    describe("displayFormat",function(){
        it("should query the property 'display format'",function(){
            dateTimeInputTOBehaviorUnderTest.displayFormat();
            assert(dateTimeInputTOBehaviorUnderTest._getROProperty.calledOnce);
            assert.deepEqual(dateTimeInputTOBehaviorUnderTest._getROProperty.firstCall.args,["display format", arguments]);
        });
        it("should return the same promise that was returned from _getROProperty",function(){
            var getROPromise = {};
            dateTimeInputTOBehaviorUnderTest._getROProperty.returns(getROPromise);
            var res = dateTimeInputTOBehaviorUnderTest.displayFormat();
            assert.strictEqual(res,getROPromise);
        });
    });

    describe("dateType",function(){
        it("should query the property 'date type'",function(){
            dateTimeInputTOBehaviorUnderTest.dateType();
            assert(dateTimeInputTOBehaviorUnderTest._getROProperty.calledOnce);
            assert.deepEqual(dateTimeInputTOBehaviorUnderTest._getROProperty.firstCall.args,["date type", arguments]);
        });
        it("should return the same promise that was returned from _getROProperty",function(){
            dateTimeInputTOBehaviorUnderTest._getROProperty.returns("DateTime");
            var res = dateTimeInputTOBehaviorUnderTest.dateType();
            assert.strictEqual(res,"DateTime");
        });
    });

});