// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created by 12/28/2015.
 */

var assert = require("assert");
var sinon = require("sinon");

describe("RoadMapDescriptionBehavior",function(){
    var RoadMapDesc = require("../lib/road_map.js").RoadMap;
    var roadMapDescUnderTest;

    beforeEach(function(){
        roadMapDescUnderTest = RoadMapDesc();
    });

    describe("steps method",function() {
        it("should add 'all steps' with correct value when a value is given",function(){
            roadMapDescUnderTest.steps(["male","female"]);
            assert.strictEqual(roadMapDescUnderTest._properties["all steps"], "male;female");
        });
        it("should add 'all steps' with correct value, when value is given using property bag",function(){
            roadMapDescUnderTest = RoadMapDesc({
                steps: ["male","female"]
            });
            assert.strictEqual(roadMapDescUnderTest._properties["all steps"], "male;female");
        });
        it("should return this - builder pattern when value is given",function(){
            var result = roadMapDescUnderTest.steps(["male","female"]);
            assert.strictEqual(result, roadMapDescUnderTest);
        });
        it("should remove 'all steps' from _properties when value is null",function(){
            roadMapDescUnderTest._properties["all steps"] = "male;female";
            roadMapDescUnderTest.steps(null);
            assert(!("all steps" in roadMapDescUnderTest._properties));
        });
        it("should return the value of 'all steps' from _properties, when value is not given",function(){
            roadMapDescUnderTest._properties["all steps"] = "male;female";
            var steps = roadMapDescUnderTest.steps();
            assert.deepEqual(steps, ["male","female"]);
        });
        it("should not modify property 'all steps', upon get",function(){
            roadMapDescUnderTest._properties["all steps"] = "male;female";
            roadMapDescUnderTest.steps();
            assert.strictEqual(roadMapDescUnderTest._properties["all steps"], "male;female");
        });
        it("should return same value in get, when value is set",function(){
            roadMapDescUnderTest.steps(["male","female"]);
            var steps = roadMapDescUnderTest.steps();
            assert.deepEqual(steps, ["male","female"]);
        });
    });

    describe("stepsCount method",function() {
        it("should add 'steps count' with correct value when value is given",function(){
            roadMapDescUnderTest.stepsCount(2);
            assert.strictEqual(roadMapDescUnderTest._properties["steps count"], 2);
        });
        it("should add 'steps count' with correct value when value is given using property bag",function(){
            roadMapDescUnderTest = RoadMapDesc({
                stepsCount: 2
            });
            assert.strictEqual(roadMapDescUnderTest._properties["steps count"], 2);
        });
        it("should return this - builder pattern when value is given",function(){
            var result = roadMapDescUnderTest.stepsCount(2);
            assert.strictEqual(result, roadMapDescUnderTest);
        });
        it("should remove 'steps count' from _properties when value is null",function(){
            roadMapDescUnderTest._properties["steps count"] = 2;
            roadMapDescUnderTest.stepsCount(null);
            assert(!("steps count" in roadMapDescUnderTest._properties));
        });
        it("should return the value of 'steps count' from _properties when value is not given",function(){
            roadMapDescUnderTest._properties["steps count"] = 2;
            var stepsCount = roadMapDescUnderTest.stepsCount();
            assert.equal(stepsCount, 2);
        });
    });

});

describe("RoadMapTOBehavior",function(){
    var RoadMapTO = require("../lib/road_map.js").RoadMapTO;
    var roadMapTOBehaviorUnderTest;

    beforeEach(function(){
        roadMapTOBehaviorUnderTest = RoadMapTO({});
        sinon.stub(roadMapTOBehaviorUnderTest, "_getROProperty");
        sinon.stub(roadMapTOBehaviorUnderTest, "_executeCommand");
		
		roadMapTOBehaviorUnderTest._session.fireEvent = sinon.stub();
        roadMapTOBehaviorUnderTest._session._promiseManager = {wrapPromiseFunctionWithNotifyEvents: function () {} };
        sinon.stub(roadMapTOBehaviorUnderTest._session._promiseManager, "wrapPromiseFunctionWithNotifyEvents", function (onStart, promiseFunc) {
            return promiseFunc();
        });
    });

    describe("steps",function(){
        it("should convert the returned string to array",function(){
            var promise = {
                then: function(cb){return cb("male;female");}
            };
            roadMapTOBehaviorUnderTest._getROProperty.returns(promise);
            var res = roadMapTOBehaviorUnderTest.steps();
            assert.deepEqual(res,["male","female"]);
        });
        it("should query the property 'all steps'",function(){
            var promise  = {then: sinon.spy()};
            roadMapTOBehaviorUnderTest._getROProperty.returns(promise);
            roadMapTOBehaviorUnderTest.steps();
            assert(roadMapTOBehaviorUnderTest._getROProperty.calledOnce);
            assert.deepEqual(roadMapTOBehaviorUnderTest._getROProperty.firstCall.args, ["all steps", arguments]);
        });
    });

    describe("selectedItem",function(){
        it("should query the property 'selected item'",function(){
            var promiseMock = {then: sinon.stub()};
            roadMapTOBehaviorUnderTest._getROProperty.returns(promiseMock);
            roadMapTOBehaviorUnderTest.selectedItem();

            assert(roadMapTOBehaviorUnderTest._getROProperty.calledOnce);
            assert.deepEqual(roadMapTOBehaviorUnderTest._getROProperty.firstCall.args, ["selected item", arguments]);
        });

        it("should return the same promise that was returned from _getROProperty",function(){
            var promiseMock = {then: function(){}};
            sinon.stub(promiseMock, "then", function (cb) {
               return cb("someItem");
            });
            roadMapTOBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = roadMapTOBehaviorUnderTest.selectedItem();
            assert.strictEqual(res,"someItem");
        });

        it("should return null if selectedItem returns empty string", function () {
            var promiseMock = {then: function(){}};
            sinon.stub(promiseMock, "then", function (cb) {
                return cb("");
            });
            roadMapTOBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = roadMapTOBehaviorUnderTest.selectedItem();
            assert.strictEqual(res, null);
        });
    });

    describe("expand",function(){
        it("should throw error if no arguments passed", function(){
            assert.throws(function(){
                roadMapTOBehaviorUnderTest.expand();
            });
        });
        it("should call the _executeCommand method and pass it string arg as is",function(){
            roadMapTOBehaviorUnderTest.expand("some name");
            assert(roadMapTOBehaviorUnderTest._executeCommand.calledOnce);
            assert.deepEqual(roadMapTOBehaviorUnderTest._executeCommand.firstCall.args.slice(0, 2), ["Expand", "some name"]);
        });
        it("should call the _executeCommand method and pass it numeric arg as string in #N format",function(){
            roadMapTOBehaviorUnderTest.expand(3);
            assert(roadMapTOBehaviorUnderTest._executeCommand.calledOnce);
            assert.deepEqual(roadMapTOBehaviorUnderTest._executeCommand.firstCall.args.slice(0, 2), ["Expand", "#4"]);
        });
        it("should return the same promise that was returned from _executeCommand",function(){
            var getROPromise = {};
            roadMapTOBehaviorUnderTest._executeCommand.returns(getROPromise);
            var res = roadMapTOBehaviorUnderTest.expand("some name");
            assert.strictEqual(res,getROPromise);
        });
    });

    describe("collapse",function(){
        it("should throw error if no arguments passed", function(){
            assert.throws(function(){
                roadMapTOBehaviorUnderTest.collapse();
            });
        });
        it("should call the _executeCommand method and pass it string arg as is",function(){
            roadMapTOBehaviorUnderTest.collapse("some name");
            assert(roadMapTOBehaviorUnderTest._executeCommand.calledOnce);
            assert.deepEqual(roadMapTOBehaviorUnderTest._executeCommand.firstCall.args.slice(0, 2), ["Collapse", "some name"]);
        });
        it("should call the _executeCommand method and pass it numeric arg as string in #N format",function(){
            roadMapTOBehaviorUnderTest.collapse(3);
            assert(roadMapTOBehaviorUnderTest._executeCommand.calledOnce);
            assert.deepEqual(roadMapTOBehaviorUnderTest._executeCommand.firstCall.args.slice(0, 2), ["Collapse", "#4"]);
        });
        it("should return the same promise that was returned from _executeCommand",function(){
            var getROPromise = {};
            roadMapTOBehaviorUnderTest._executeCommand.returns(getROPromise);
            var res = roadMapTOBehaviorUnderTest.collapse("some name");
            assert.strictEqual(res,getROPromise);
        });
    });

});