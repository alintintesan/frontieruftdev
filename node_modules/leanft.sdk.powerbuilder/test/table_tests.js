// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 03/14/2018.
 */

var assert = require("assert");
var sinon = require("sinon");
var Q = require("q");

describe("Table Test Object", function () {
    var TableTO = require("../lib/table.js").TableTO;
    var tableTestObjectUnderTest;

    beforeEach(function () {
        tableTestObjectUnderTest = new TableTO();
        sinon.stub(tableTestObjectUnderTest, "_getROProperty");
        sinon.stub(tableTestObjectUnderTest, "_executeCommand");
        sinon.stub(tableTestObjectUnderTest, "_executeNotWrapped");
        sinon.stub(tableTestObjectUnderTest, "_executeWithEvents");
        sinon.stub(tableTestObjectUnderTest, "_executeWithEventsOnError");
    });

    describe("getTableProperty method", function () {
        it("should return the execution promise", function () {
            var promise = Q.resolve(null);
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);

            return tableTestObjectUnderTest.getTableProperty("someProperty").then(function(res){
                assert.equal(res, promise.value);
            });
        });
        it("should execute _executeWithEventsOnError 'Describe' if the parameter is property", function () {
            var promise = Q.resolve('propResult');
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);
            return tableTestObjectUnderTest.getTableProperty("someProperty").then(function(res){
                sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEventsOnError);
                sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEventsOnError, sinon.match({
                    0: "someProperty"
                }), "Describe", "someProperty");
                assert.equal(res, promise);
            });
        });
        it("should throw 'Invalid input parameter.' if the result is !", function () {
            var promise = Q.resolve('!');
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);
            return tableTestObjectUnderTest.getTableProperty("someProperty").catch(function(err){
                sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEventsOnError);
                sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEventsOnError, sinon.match({
                    0: "someProperty"
                }), "Describe", "someProperty");
                assert.equal(err.message, "Invalid input parameter.");
            });
        });
        it("should return null if the result is ?", function () {
            var promise = Q.resolve('?');
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);
            return tableTestObjectUnderTest.getTableProperty("someProperty").then(function(err){
                sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEventsOnError);
                sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEventsOnError, sinon.match({
                    0: "someProperty"
                }), "Describe", "someProperty");
                assert.equal(err, null);
            });
        });
        it("should throw 'ArgumentException: property is required.' error if the property is null", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.getTableProperty(null);
            });
        });
        it("should throw 'The property should contain no spaces.' error if the property parameter has spaces", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.getTableProperty("some property");
            });
        });
    });

    describe("evaluateExpression method", function () {
        it("should return the execution promise", function () {
            var promise = Q.resolve(null);
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);

            return tableTestObjectUnderTest.evaluateExpression("someExpression", 1).then(function(res){
                assert.equal(res, promise.value);
            });
        });
        it("should execute _executeWithEventsOnError 'Describe' if the parameter is expression", function () {
            var promise = Q.resolve('propResult');
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);
            return tableTestObjectUnderTest.evaluateExpression("someExpression", 1).then(function(res){
                sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEventsOnError);
                sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEventsOnError, sinon.match({
                    0: "someExpression",
                    1: 1
                }), "Describe", "Evaluate('someExpression', 1)");
                assert.equal(res, promise);
            });
        });
        it("should throw 'Invalid input parameter.' if the result is !", function () {
            var promise = Q.resolve('!');
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);
            return tableTestObjectUnderTest.evaluateExpression("someExpression", 1).catch(function(err){
                sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEventsOnError);
                sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEventsOnError, sinon.match({
                    0: "someExpression",
                    1: 1
                }), "Describe", "Evaluate('someExpression', 1)");
                assert.equal(err.message, "Invalid input parameter.");
            });
        });
        it("should return null if the result is ?", function () {
            var promise = Q.resolve('?');
            tableTestObjectUnderTest._executeWithEventsOnError.returns(promise);
            return tableTestObjectUnderTest.evaluateExpression("someExpression", 1).then(function(err){
                sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEventsOnError);
                sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEventsOnError, sinon.match({
                    0: "someExpression",
                    1: 1
                }), "Describe", "Evaluate('someExpression', 1)");
                assert.equal(err, null);
            });
        });
        it("should throw 'ArgumentException: expression is required.' error if the property is null", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.evaluateExpression(null, 1);
            });
        });
        it("should throw 'ArgumentException: row is required.' error if the property parameter has spaces", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.evaluateExpression("someExpression", null);
            });
        });
    });

    describe("activateCell method", function () {
        it("should execute command 'ActivateCell' if the 'row' parameter is an index", function () {
            tableTestObjectUnderTest.activateCell(0, 0);
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEvents, sinon.match({
                0: 1,
                1: 1
            }), "ActivateCell", 1, 1);
        });

        it("should execute command 'ActivateCell' if the 'row' parameter is an index string", function () {
            tableTestObjectUnderTest.activateCell("0", 0);
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEvents, sinon.match({
                0: 1,
                1: 1
            }), "ActivateCell", 1, 1);
        });

        it("should execute command 'ActivateCell' if the 'columnOrIndex' parameter is the header of a column", function () {
            tableTestObjectUnderTest.activateCell(0, "col header");
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEvents, sinon.match({
                0: 1,
                1: "col header"
            }), "ActivateCell", 1, "col header");
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            tableTestObjectUnderTest._executeWithEvents.returns(promiseMock);
            var res = tableTestObjectUnderTest.activateCell(0, 0);
            assert.strictEqual(res, promiseMock);
        });

        it("should throw error if the 'row' parameter is null", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.activateCell(null);
            });
        });

        it("should throw error if the 'row' parameter is undefined", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.activateCell();
            });
        });

        it("should throw error if the 'columnOrIndex' parameter is null", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.activateCell(0, null);
            });
        });

        it("should throw error if the 'columnOrIndex' parameter is undefined", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.activateCell(0);
            });
        });
    });

    describe("selectCell method", function () {
        it("should execute command 'SelectCell' if the 'row' parameter is an index", function () {
            tableTestObjectUnderTest.selectCell(0, 0);
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEvents, sinon.match({
                0: 1,
                1: 1
            }), "SelectCell", 1, 1);
        });

        it("should execute command 'SelectCell' if the 'row' parameter is an index string", function () {
            tableTestObjectUnderTest.selectCell("0", 0);
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEvents, sinon.match({
                0: 1,
                1: 1
            }), "SelectCell", 1, 1);
        });

        it("should execute command 'SelectCell' if the 'columnOrIndex' parameter is the header of a column", function () {
            tableTestObjectUnderTest.selectCell(0, "col header");
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEvents, sinon.match({
                0: 1,
                1: "col header"
            }), "SelectCell", 1, "col header");
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            tableTestObjectUnderTest._executeWithEvents.returns(promiseMock);
            var res = tableTestObjectUnderTest.selectCell(0, 0);
            assert.strictEqual(res, promiseMock);
        });

        it("should throw error if the 'row' parameter is null", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.selectCell(null);
            });
        });

        it("should throw error if the 'row' parameter is undefined", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.selectCell();
            });
        });

        it("should throw error if the 'columnOrIndex' parameter is null", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.selectCell(0, null);
            });
        });

        it("should throw error if the 'columnOrIndex' parameter is undefined", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.selectCell(0);
            });
        });
    });

    describe("selectRow method", function () {
        it("should execute command 'SelectRow' if the 'row' parameter is an index", function () {
            tableTestObjectUnderTest.selectRow(0);
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeWithEvents, sinon.match({
                0: 1
            }), "SelectRow", 1);
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            tableTestObjectUnderTest._executeWithEvents.returns(promiseMock);
            var res = tableTestObjectUnderTest.selectRow(0);
            assert.strictEqual(res, promiseMock);
        });

        it("should throw error if the 'row' parameter is null", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.selectRow(null);
            });
        });

        it("should throw error if the 'row' parameter is undefined", function () {
            assert.throws(function () {
                tableTestObjectUnderTest.selectRow();
            });
        });
    });

    describe("_getRowsCount method", function () {
        var rowsCount = 2;
        var promiseMock = {
            then: function (cb) {
                return cb(rowsCount.toString());
            }
        };
        it("should execute _executeCommand 'RowCount'", function () {
            tableTestObjectUnderTest._executeCommand.returns(promiseMock);
            tableTestObjectUnderTest._getRowsCount();
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeCommand);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeCommand, "RowCount");
        });

        it("should return a number value when promise returns numeric string", function () {
            tableTestObjectUnderTest._executeCommand.returns(promiseMock);
            var res = tableTestObjectUnderTest._getRowsCount();
            assert.strictEqual(res, rowsCount);
        });
    });

    describe("_getCellValue method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            tableTestObjectUnderTest._executeNotWrapped.returns(executionPromise);
            var res = tableTestObjectUnderTest._getCellValue(0, 0);
            assert.equal(res, executionPromise);
        });

        it("should execute _executeNotWrapped 'GetCellData' if the parameters are indices", function () {
            tableTestObjectUnderTest._getCellValue(0, 0);
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeNotWrapped, sinon.match({
                0: 1,
                1: 1
            }), "GetCellData", 1, 1);
        });

        it("should execute _executeNotWrapped 'GetCellData' if the 'columnIdentifier' parameter is the header of the column", function () {
            tableTestObjectUnderTest._getCellValue(0, "col header");
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeNotWrapped, sinon.match({
                0: 1,
                1: "col header"
            }), "GetCellData", 1, "col header");
        });
    });

    describe("_setCellValue method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            tableTestObjectUnderTest._executeNotWrapped.returns(executionPromise);
            var res = tableTestObjectUnderTest._setCellValue(0, 0, "some value");
            assert.equal(res, executionPromise);
        });

        it("should execute _executeNotWrapped 'SetCellData' if the parameters are indices", function () {
            tableTestObjectUnderTest._setCellValue(0, 0, "some value");
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeNotWrapped, sinon.match({
                0: 1,
                1: 1,
                2: "some value"
            }), "SetCellData", 1, 1, "some value");
        });

        it("should execute _executeNotWrapped 'SetCellData' if the 'columnIdentifier' parameter is the header of the column", function () {
            tableTestObjectUnderTest._setCellValue(0, "col header", "some value");
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeNotWrapped, sinon.match({
                0: 1,
                1: "col header",
                2: "some value"
            }), "SetCellData", 1, "col header", "some value");
        });
    });

    describe("_getRowAndColumnCount method", function () {
        beforeEach(function () {
            var executionPromise = {
                then: function (cb) {
                    return cb("4");
                }
            };
            tableTestObjectUnderTest._executeNotWrapped.returns(executionPromise);
            tableTestObjectUnderTest._executeCommand.returns(executionPromise);
        });

        it("should execute command '_executeNotWrapped'", function () {
            tableTestObjectUnderTest._getRowAndColumnCount();
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeCommand);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeNotWrapped, sinon.match({}), "RowCount");
            sinon.assert.calledWith(tableTestObjectUnderTest._executeCommand, "ColumnCount");
        });

        it("should return rowCount and columnCount", function () {
            var res = tableTestObjectUnderTest._getRowAndColumnCount();
            assert.deepEqual(res, {rowCount: 4, columnCount: 4});
        });
    });

    describe("_getColumnCount method", function () {
        var columnCount = 6;
        var promiseMock = {
            then: function (cb) {
                return cb(columnCount.toString());
            }
        };
        it("should execute _executeCommand 'ColumnCount'", function () {
            tableTestObjectUnderTest._executeCommand.returns(promiseMock);
            tableTestObjectUnderTest._getColumnCount();
            sinon.assert.calledOnce(tableTestObjectUnderTest._executeCommand);
            sinon.assert.calledWith(tableTestObjectUnderTest._executeCommand, "ColumnCount");
        });

        it("should return a number value when promise returns numeric string", function () {
            tableTestObjectUnderTest._executeCommand.returns(promiseMock);
            var res = tableTestObjectUnderTest._getColumnCount();
            assert.strictEqual(res, columnCount);
        });
    });

    describe("_createItem method", function () {
        it("should return the TableCell with correct values", function () {
            var res = tableTestObjectUnderTest._createCell(0, 0);
            assert.strictEqual(res._rowIdentifier, 0);
            assert.strictEqual(res._columnIdentifier, 0);
            assert.deepEqual(res._ownerTable, tableTestObjectUnderTest);
        });
    });
});