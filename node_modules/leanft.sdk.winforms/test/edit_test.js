// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 08/26/2016.
 */

var assert = require("assert");
var sinon = require("sinon");

describe("Edit Description", function () {
    var Edit = require("../lib/edit.js").Edit;
    var EditDescriptionUnderTest;

    beforeEach(function () {
        EditDescriptionUnderTest = Edit();
    });

    describe("Constructor", function () {
        it("should assign 'WinForms' and 'EditField' LeanFT type", function () {
            editDescriptionUnderTest = new Edit();
            assert.deepEqual(editDescriptionUnderTest.leanFTType, {
                technology: "WinForms",
                leanftType: "EditField"
            });
        });
    });
});

describe("Edit Test Object", function () {
    var EditTO = require("../lib/edit.js").EditTO;
    var editTestObjectUnderTest;

    beforeEach(function () {
        editTestObjectUnderTest = new EditTO();
        sinon.stub(editTestObjectUnderTest, "_executeWithEvents");
        sinon.stub(editTestObjectUnderTest, "_executeWithEventsOnError");
    });

    describe("setText method", function () {
        it("should throw error if text is undefined", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setText();
            });
        });

        it("should throw error if text is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setText(null);
            });
        });

        it("should execute command with text is entered", function () {
            editTestObjectUnderTest.setText("Sample text");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "Sample text" }), "Set", "Sample text");
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setText("Sample Text");
            assert.equal(res, executionPromise);
        });
    });

    describe("errorText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEventsOnError.returns(executionPromise);
            var res = editTestObjectUnderTest.errorText();
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'GetErrorProviderText'", function () {
            editTestObjectUnderTest.errorText();
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEventsOnError);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEventsOnError, sinon.match({}), "GetErrorProviderText");
        });
    });

    describe("select method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.select(1, 1);
            assert.equal(res, executionPromise);
        });

        it("should execute command 'SetSelection' with all input values if the inputs are number", function () {
            editTestObjectUnderTest.select(2, 5);
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: 2, 1: 5 }), "SetSelection", 2, 6);
        });

        it("should execute command 'SetSelection' with all input values in the inputs are string", function () {
            editTestObjectUnderTest.select("2", "5");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "2", 1: "5" }), "SetSelection", 2, 6);
        });

        it("should throw error if fromStartPos is undefined", function () {
            assert.throws(function () {
                editTestObjectUnderTest.select();
            });
        });

        it("should throw error if fromStartPos is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.select(null);
            });
        });

        it("should throw error if toEndPos is undefined", function () {
            assert.throws(function () {
                editTestObjectUnderTest.select(1);
            });
        });

        it("should throw error if toEndPos is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.select(1, null);
            });
        });
    });

    describe("setSecure method", function () {
        it("should throw error if encodedText is undefined", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setSecure();
            });
        });

        it("should throw error if encodedText is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setSecure(null);
            });
        });

        it("should execute command 'setSecure' with text is entered", function () {
            editTestObjectUnderTest.setSecure("Sample encoded text");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "Sample encoded text" }), "SetSecure", "Sample encoded text");
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setSecure("Sample encoded text");
            assert.equal(res, executionPromise);
        });
    });
});