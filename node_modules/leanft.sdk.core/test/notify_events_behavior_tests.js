// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 03/05/2016.
 */

var NotifyEventsBehavior = require("../lib/notify_events_behavior.js");
var assert = require("assert");
var sinon = require("sinon");
var Q = require("q");

describe("NotifyEventsBehavior ",function(){
    var funcUnderTest;
    var returnedPromise;

    beforeEach(function(){
        sessionMock = {
            _communication: {
                send: sinon.stub()
            },
            fireEvent: sinon.stub(),
            _promiseManager: {wrapPromiseFunctionWithNotifyEvents :function(){} }
        };

        sinon.stub(sessionMock._promiseManager, "wrapPromiseFunctionWithNotifyEvents", function(onStart, promiseFunc, onFinishOK, onFinishErr) {
            onStart();
            var res = promiseFunc();
            res.then(function(result) {
                try{onFinishOK(result)} catch(e) {}
                return result;
            }, function (error) {
                try{onFinishErr(error)} catch (e) {}
                throw error;
            });
            return res;
        });
        NotifyEventsBehavior._session = sessionMock;

        returnedPromise = Q.resolve(5);
        funcUnderTest = sinon.stub().returns(returnedPromise);
    });

    afterEach(function () {
        delete NotifyEventsBehavior._session;
    });

    it("should invoke func without events in case session not exist",function(){
        delete NotifyEventsBehavior._session;

        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null , null).then(function(res) {
            sinon.assert.calledOnce(funcUnderTest);
            assert.strictEqual(res, 5);
        });
    });

    it("should throw exception if options argument doesn't exist",function(){
        assert.throws(function(){
            NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null , null);
        });
    });

    it("should throw exception if calleArguments  doesn't exist",function(){
        assert.throws(function(){
            NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null , {});
        });
    });

    it("should fire the onBefore and the onAfter events",function(){
        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null , {name:"test1", calleeArguments: arguments})
            .then(function () {
                assert(NotifyEventsBehavior._session.fireEvent.calledTwice)
            });
    });

    it("should add to promiseManager the onBeforeCommand execution",function(){
        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
            {
                name:"test1",
                sender: null,
                onError:false,
                calleeArguments: arguments,
                type: "BrowserFactory"
            }).then(function () {
            assert.deepStrictEqual( NotifyEventsBehavior._session.fireEvent.firstCall.args[0] ,"onBeforeCommand");
            //assert.deepStrictEqual( NotifyEventsBehavior._session.fireEvent.firstCall.args ,["onBeforeCommand",
            //    {commandId : 5, method: this.test.fn.caller, methodArguments: [], methodName:"test1", sender: null, type:"BrowserFactory" }]);
        });
    });

    it("should add to promiseManager the onAfterCommand execution",function(){
        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
            {
                name:"test1",
                sender: null,
                onError:false,
                calleeArguments: arguments,
                type: "BrowserFactory"
            }).then(function () {
            assert.deepStrictEqual( NotifyEventsBehavior._session.fireEvent.secondCall.args[0] ,"onAfterCommand");
            //assert.deepStrictEqual(NotifyEventsBehavior._session.fireEvent.secondCall.args ,["onAfterCommand",
            //    {commandId : 5, method: this.test.fn.caller, methodArguments: [], methodName:"test1", sender: null, type:"BrowserFactory" }]);
        });
    });

    it("should call to executed method once",function(){
        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
            {
                name:"test1",
                sender: null,
                onError:false,
                calleeArguments: arguments,
                type: "BrowserFactory"
            }).then(function () {
            assert(funcUnderTest.calledOnce);
        });
    });

    it("should return promise on success",function(){
        var promise = NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
            {
                name:"test1",
                sender: null,
                onError:false,
                calleeArguments: arguments,
                type: "BrowserFactory"
            });

        assert.strictEqual(promise, returnedPromise);
    });

    //it("should return promise on failure",function(){
    //    var funcUnderTest = function(){
    //        return Q.resolve(null);
    //    };
    //
    //    var promise = NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
    //        {
    //            name:"test1",
    //            sender: null,
    //            onError:false,
    //            calleeArguments: arguments,
    //            type: "BrowserFactory"
    //        });
    //    process.nextTick(function(){
    //        assert.notStrictEqual(promise.promiseDispatch, undefined)
    //    });
    //});

    it("should fire the onBefore and the onAfter events with real promise",function(){

        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
            {
                name:"test1",
                sender: null,
                onError:false,
                calleeArguments: arguments,
                type: "BrowserFactory"
            })
            .then(function(res) {
                assert.strictEqual(res, 5);
                assert.deepStrictEqual( NotifyEventsBehavior._session.fireEvent.firstCall.args[0] ,"onBeforeCommand");
                assert.deepStrictEqual( NotifyEventsBehavior._session.fireEvent.secondCall.args[0] ,"onAfterCommand");
            });
    });

    //todo: re-write this test!!!
    it("should fire the onErrorCommand upon promise failure",function(){
        var error = new Error("someError");
        var funcUnderTest = function(){
            return Q.reject(error);
        };

        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
            {
                name:"test1",
                sender: null,
                onError:false,
                calleeArguments: arguments,
                type: "BrowserFactory"
            })
            .then(function () {
                throw new Error("should not be resolved");
            }, function () {
                sinon.assert.calledTwice(NotifyEventsBehavior._session.fireEvent);
                sinon.assert.calledWith(NotifyEventsBehavior._session.fireEvent, "onErrorCommand",
                    sinon.match({error: error}));
            });
        });

    it("should re-throw exception in case promise failure",function(){
        var error = new Error("someError");
        var funcUnderTest = function(){
            return Q.reject(error);
        };

        return NotifyEventsBehavior.notifyWithEvents(funcUnderTest, null ,
            {
                name:"test1",
                sender: null,
                onError:false,
                calleeArguments: arguments,
                type: "BrowserFactory"
            })
            .then(function () {
                throw new Error("should not be resolved");
            }, function (err) {
                assert.strictEqual(err, error);
            });
    });

});