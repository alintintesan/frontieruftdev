// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 06/03/2016.
 */

var assert = require("assert");
var sinon = require("sinon");
var ObjectUtils = require("./../lib/object_utils.js").ObjectUtils;

describe("SendKeys Behaviour Tests",function() {
    var Behavior = require("../lib/sendkeys_behavior.js");
    var SendKeysBehavior = Behavior.SendKeysBehavior;
    var SendKeysHelper = Behavior.SendKeysHelper;
    var KeyModifier = Behavior.KeyModifier;
    var Keys = Behavior.Keys;
    var FunctionKeys = Behavior.FunctionKeys;
    var KeysToNativeConsts = SendKeysHelper.keysToNativeConsts;
    var ModifierToNativeDownUpConsts = SendKeysHelper.modifierToNativeDownUpConsts;
    var sendKeysBehaviorUnderTest = null;

    beforeEach(function () {
        sendKeysBehaviorUnderTest = ObjectUtils.mergeTestBehavior(SendKeysBehavior);
        sendKeysBehaviorUnderTest._executeWithEvents = sinon.stub();
    });

    afterEach(function() {
        delete sendKeysBehaviorUnderTest._executeWithEvents;
    });

    describe("sendKeys", function () {
        it("should pass default parameters to _executeWithEvents if without args ", function () {
            sendKeysBehaviorUnderTest.sendKeys();
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({}), "Type", "");
        });

        it("should pass default parameters to _executeWithEvents if input is null ", function () {
            sendKeysBehaviorUnderTest.sendKeys(null);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({}), "Type", "");
        });
        
        it("should pass KeyModifier.none to _executeCommand if without modifiers", function () {
            sendKeysBehaviorUnderTest.sendKeys("The Sample Text");
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "The Sample Text" }), "Type", "The Sample Text");
        });

        it("should pass KeyModifier.none to _executeCommand if modifiers is null", function () {
            sendKeysBehaviorUnderTest.sendKeys("The Sample Text", null);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "The Sample Text" }), "Type", "The Sample Text");
        });

        it("should pass correct modifiers to _executeCommand with modifiers", function () {
            sendKeysBehaviorUnderTest.sendKeys("F", KeyModifier.ctrl | KeyModifier.shift);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "F", 1: KeyModifier.ctrl | KeyModifier.shift }), "Type", "<__MicCtrlDwn><__MicShiftDwn>F<__MicCtrlUp><__MicShiftUp>");
        });

        it("should pass correct string to _executeCommand with modifiers and Keys/FunctionKeys", function () {
            sendKeysBehaviorUnderTest.sendKeys("The " + Keys.return + "sample" + Keys.backspace + " text" + FunctionKeys.f1, KeyModifier.ctrl | KeyModifier.shift);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "The " + Keys.return + "sample" + Keys.backspace + " text" + FunctionKeys.f1, 1: KeyModifier.ctrl | KeyModifier.shift }), "Type", "<__MicCtrlDwn><__MicShiftDwn>The <__MicReturn>sample<__MicBack> text<__MicF1><__MicCtrlUp><__MicShiftUp>");
        });

        it("should keep output string the same as input if without keys", function () {
            sendKeysBehaviorUnderTest.sendKeys("some text");
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "some text" }), "Type", "some text");
        });

        it("should keep output string the same as input if input contains only prefix", function () {
            sendKeysBehaviorUnderTest.sendKeys("some <__ENTER text");
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "some <__ENTER text" }), "Type", "some <__ENTER text");
        });

        it("should keep output string the same as input if input contains only suffix", function () {
            sendKeysBehaviorUnderTest.sendKeys("some ENTER> text");
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "some ENTER> text" }), "Type", "some ENTER> text");
        });

        it("should keep output string the same as input if input contains not legal key", function () {
            sendKeysBehaviorUnderTest.sendKeys("some <__notlegalkey> text");
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: "some <__notlegalkey> text" }), "Type", "some <__notlegalkey> text");
        });

        it("should convert correctly if input with complex keys", function () {
            var input = Keys.f2 + "some text" + Keys.right + "some more text" + Keys.home + "111";
            var expected = "<__MicF2>some text<__MicRight>some more text<__MicHome>111";
            sendKeysBehaviorUnderTest.sendKeys(input);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: input }), "Type", expected);
        });

        it("should convert correctly if input with complex keys and not legal key", function () {
            var input = Keys.f2 + "some text" + Keys.right + "<__NotLegalKey>" + Keys.home + "111";
            var expected = "<__MicF2>some text<__MicRight><__NotLegalKey><__MicHome>111";
            sendKeysBehaviorUnderTest.sendKeys(input);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: input }), "Type", expected);
        });

        it("should convert correctly if input with complex keys and prefix without suffix", function () {
            var input = Keys.f2 + "some text" + Keys.right + "<__NotLegalKey" + Keys.home + "111";
            var expected = "<__MicF2>some text<__MicRight><__NotLegalKey<__MicHome>111";
            sendKeysBehaviorUnderTest.sendKeys(input);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: input }), "Type", expected);
        });

        it("should convert correctly if input with complex keys and suffix without prefix", function () {
            var input = Keys.f2 + "some text" + Keys.right + "NotLegalKey>" + Keys.home + "111";
            var expected = "<__MicF2>some text<__MicRight>NotLegalKey><__MicHome>111";
            sendKeysBehaviorUnderTest.sendKeys(input);
            sinon.assert.calledOnce(sendKeysBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: input }), "Type", expected);
        });

        it("should convert correctly for all keys", function () {
            Object.keys(KeysToNativeConsts).forEach(function (key) {
                sendKeysBehaviorUnderTest.sendKeys(key);
                sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: key }), "Type", KeysToNativeConsts[key]);
            }, this);
        });

        it("should convert correctly for all modifiers", function () {
            var text = "some text";
            Object.keys(ModifierToNativeDownUpConsts).forEach(function (key) {
                var expected = ModifierToNativeDownUpConsts[key][0] + text + ModifierToNativeDownUpConsts[key][1];
                sendKeysBehaviorUnderTest.sendKeys(text, key);
                sinon.assert.calledWith(sendKeysBehaviorUnderTest._executeWithEvents, sinon.match({ 0: text, 1: key }), "Type", expected);
            }, this);
        });


    });
});