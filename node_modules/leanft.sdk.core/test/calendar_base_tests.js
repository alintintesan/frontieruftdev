// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 06/20/2016.
 */

var assert = require("assert");
var sinon = require("sinon");
var ObjectUtils = require("./../lib/object_utils.js").ObjectUtils;

describe("CalendarConverter Tests", function () {
    var CalendarConverter = require("../lib/calendar_base.js").CalendarConverter;
    var calendarConverterUnderTest = null;

    beforeEach(function () {
        calendarConverterUnderTest = CalendarConverter;
    });

    afterEach(function() {
    });

    describe("isNativeSingleDateRangeFormatWithBrackets method", function () {
        it("should return false if the input string is not in correct format: only text)", function () {
            var input = "[ABCDEF]";
            var res = calendarConverterUnderTest.isNativeSingleDateRangeFormatWithBrackets(input);
            assert.strictEqual(res, false);
        });

        it("should return false if the input string is not in correct format: use '/' character)", function () {
            var input = "[19/12/2016 - 19/11/2016]";
            var res = calendarConverterUnderTest.isNativeSingleDateRangeFormatWithBrackets(input);
            assert.strictEqual(res, false);
        });

        it("should return false if the input string is not in correct format: missing bracket)", function () {
            var input = "11-Jan-2015 - 1-Feb-2016";
            var res = calendarConverterUnderTest.isNativeSingleDateRangeFormatWithBrackets(input);
            assert.strictEqual(res, false);
        });

        it("should return false if the input string is not in correct format: partial correct)", function () {
            var input = "[19-May-2016 - 19/11/2016]";
            var res = calendarConverterUnderTest.isNativeSingleDateRangeFormatWithBrackets(input);
            assert.strictEqual(res, false);
        });

        it("should return true if the input string is in correct format", function () {
            var input = "[11-Jan-2015 - 1-Feb-2016]";
            var res = calendarConverterUnderTest.isNativeSingleDateRangeFormatWithBrackets(input);
            assert.strictEqual(res, true);
        });
    });

    describe("parseNativeSingleDateFormat method", function () {
        it("should return correct Date object", function () {
            var input = "19-Mar-2016";
            var date = new Date(2016, 2, 19);
            var res = calendarConverterUnderTest.parseNativeSingleDateFormat(input);
            assert.deepEqual(res, date);
        });
    });

    describe("parseNativeSingleDateRangeFormatWithBrackets method", function () {
        it("should throw error if the input is not in correct format", function () {
            var input = "[19-Mar-2016]";
            assert.throws(function () {
                calendarConverterUnderTest.parseNativeSingleDateRangeFormatWithBrackets(input);
            });
        });

        it("should return correct Date Range object", function () {
            var input = "[19-Mar-2016 - 20-Apr-2017]";
            var dateRange = { startDate: new Date(2016, 2, 19), endDate: new Date(2017, 3, 20) };
            var res = calendarConverterUnderTest.parseNativeSingleDateRangeFormatWithBrackets(input);
            assert.deepEqual(res, dateRange);
        });
    });

    describe("parseNativeSingleDateRangeFormatToDateRange method", function () {
        it("should return correct Date Range object", function () {
            var input = "19-Mar-2016 - 20-Apr-2017";
            var dateRange = { startDate: new Date(2016, 2, 19), endDate: new Date(2017, 3, 20) };
            var res = calendarConverterUnderTest.parseNativeSingleDateRangeFormatToDateRange(input);
            assert.deepEqual(res, dateRange);
        });
    });

    describe("convertToNativeSingleDateRangeFormatWithBrackets method", function () {
        it("should return correct date range string if date has 2 digits", function () {
            var dateRange = { startDate: new Date(2016, 2, 19), endDate: new Date(2017, 3, 20) };
            var res = calendarConverterUnderTest.convertToNativeSingleDateRangeFormatWithBrackets(dateRange);
            assert.strictEqual(res, "[19-Mar-2016 - 20-Apr-2017]");
        });

        it("should return correct date range string if date is single digit", function () {
            var dateRange = { startDate: new Date(2016, 2, 1), endDate: new Date(2017, 3, 2) };
            var res = calendarConverterUnderTest.convertToNativeSingleDateRangeFormatWithBrackets(dateRange);
            assert.strictEqual(res, "[1-Mar-2016 - 2-Apr-2017]");
        });
    });

    describe("convertToNativeSingleDateRangeFormat method", function () {
        it("should return correct date range string", function () {
            var dateRange = { startDate: new Date(2016, 2, 19), endDate: new Date(2017, 3, 20) };
            var res = calendarConverterUnderTest.convertToNativeSingleDateRangeFormat(dateRange);
            assert.strictEqual(res, "19-Mar-2016 - 20-Apr-2017");
        });
    });

    describe("parseNativeTimeFormat method", function () {
        it("should return correct Date contain time info if the hour is < 12", function () {
            var date = new Date();
            date.setHours(1);
            date.setMinutes(12);
            date.setSeconds(34);
            var input = "01:12:34";
            var res = calendarConverterUnderTest.parseNativeTimeFormat(input);
            assert.equal(res.toTimeString(), date.toTimeString());
        });

        it("should return correct Date contain time info if the hour is >= 12", function () {
            var date = new Date();
            date.setHours(14);
            date.setMinutes(2);
            date.setSeconds(34);
            var input = "14:02:34";
            var res = calendarConverterUnderTest.parseNativeTimeFormat(input);
            assert.equal(res.toTimeString(), date.toTimeString());
        });
    });

    describe("convertToNativeTimeFormat method", function () {
        it("should return correct time string if all have 2 digits", function () {
            var date = new Date();
            date.setHours(10);
            date.setMinutes(12);
            date.setSeconds(34);
            var res = calendarConverterUnderTest.convertToNativeTimeFormat(date);
            assert.equal(res, "10:12:34");
        });

        it("should return correct time string if all have 1 digit", function () {
            var date = new Date();
            date.setHours(1);
            date.setMinutes(2);
            date.setSeconds(3);
            var res = calendarConverterUnderTest.convertToNativeTimeFormat(date);
            assert.equal(res, "01:02:03");
        });
    });

    describe("convertStringToDate method", function () {
        it("should return correct Date if the input is Date Range string", function () {
            var date = new Date(2017, 2, 17);
            var input = "[17-Mar-2017 - 17-Mar-2017]";
            var res = calendarConverterUnderTest.convertStringToDate(input);
            assert.deepEqual(res, date);
        });

        it("should return correct Date if the input is Date string", function () {
            var date = new Date(2017, 2, 17);
            var input = "17-Mar-2017";
            var res = calendarConverterUnderTest.convertStringToDate(input);
            assert.deepEqual(res, date);
        });
    });

    describe("convertToNativeSingleDateFormat method", function () {
        it("should return correct Date string if date is 2 digits", function () {
            var date = new Date(2017, 2, 17);
            var res = calendarConverterUnderTest.convertToNativeSingleDateFormat(date);
            assert.deepEqual(res, "17-Mar-2017");
        });

        it("should return correct Date string if date is 1 digit", function () {
            var date = new Date(2017, 2, 4);
            var res = calendarConverterUnderTest.convertToNativeSingleDateFormat(date);
            assert.deepEqual(res, "4-Mar-2017");
        });
    });
});

describe("CalendarTOBaseBehavior Tests", function () {
    var CalendarTOBaseBehavior = require("../lib/calendar_base.js").CalendarTOBaseBehavior;
    var calendarTOBaseBehaviorUnderTest = null;

    beforeEach(function () {
        calendarTOBaseBehaviorUnderTest = ObjectUtils.mergeTestBehavior(CalendarTOBaseBehavior);
        calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents = sinon.stub();
        calendarTOBaseBehaviorUnderTest._getROProperty = sinon.stub();
        calendarTOBaseBehaviorUnderTest._executeWithEvents = sinon.stub();
    });

    afterEach(function () {
        delete calendarTOBaseBehaviorUnderTest._getROProperty;
        delete calendarTOBaseBehaviorUnderTest._executeWithEvents;
        delete calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents;
    });

    describe("date method", function () {
        it("should execute _getROProperty 'date'", function () {
            var promiseMock = { then: function (cb) { return cb("[13-Mar-2016 - 14-Apr-2016]"); } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            calendarTOBaseBehaviorUnderTest.date();
            sinon.assert.calledOnce(calendarTOBaseBehaviorUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOBaseBehaviorUnderTest._getROProperty, "date", sinon.match({}));
        });

        it("should throw error if result is null", function () {
            var promiseMock = { then: function (cb) { return cb(null); } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.date();
            });
        });

        it("should throw error if result is Unavailable", function () {
            var promiseMock = { then: function (cb) {
                return cb("Unavailable");
            } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.date();
            });
        });

        it("should return a date if the return value is a single date", function () {
            var promiseMock = { then: function (cb) { return cb("13-Mar-2016"); } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOBaseBehaviorUnderTest.date();
            assert.deepEqual(res, new Date(2016, 2, 13));
        });

        it("should return the first date date if the return value is a date range string", function () {
            var promiseMock = { then: function (cb) { return cb("[13-Mar-2016 - 14-Apr-2016]"); } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOBaseBehaviorUnderTest.date();
            assert.deepEqual(res, new Date(2016, 2, 13));
        });
    });

    describe("setDate method", function () {
        it("should throw error if date is undefine", function () {
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.setDate();
            });
        });

        it("should throw error if date is null", function () {
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.setDate(null);
            });
        });

        it("should execute _getROPropertyWithoutEvents with 'date' without arguments if data is date", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            calendarTOBaseBehaviorUnderTest.setDate( new Date(2016, 2, 17));
            sinon.assert.calledOnce(calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents);
            sinon.assert.calledWith(calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents, "date");
        });

        it("should throw error if result of _getROPropertyWithoutEvents is Unavailable", function () {
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns("Unavailable");
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.setDate(new Date(2016, 2, 17));
            });
        });

        it("should call _executeWithEvents with SetDate and correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            calendarTOBaseBehaviorUnderTest.setDate(new Date(2016, 2, 17));
            sinon.assert.calledOnce(calendarTOBaseBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOBaseBehaviorUnderTest._executeWithEvents, sinon.match({ 0: new Date(2016, 2, 17) }), "SetDate", "17-Mar-2016");
        });

        it("should return a promise", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            var promiseMockExecute = {};
            calendarTOBaseBehaviorUnderTest._executeWithEvents.returns(promiseMockExecute);

            var res = calendarTOBaseBehaviorUnderTest.setDate(new Date(2016, 2, 17));
            assert.strictEqual(res, promiseMockExecute);
        });
    });

    describe("time method", function () {
        it("should execute _getROProperty 'time'", function () {
            var promiseMock = { then: function (cb) { return cb("13:04:45"); } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            calendarTOBaseBehaviorUnderTest.time();
            sinon.assert.calledOnce(calendarTOBaseBehaviorUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOBaseBehaviorUnderTest._getROProperty, "time", sinon.match({}));
        });

        it("should throw error if result is null", function () {
            var promiseMock = { then: function (cb) { return cb(null); } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.time();
            });
        });

        it("should throw error if result is Unavailable", function () {
            var promiseMock = { then: function (cb) { return cb("Unavailable"); } };
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.time();
            });
        });

        it("should return a Date with time information", function () {
            var promiseMock = { then: function (cb) { return cb("13:04:45"); } };
            var date = new Date();
            date.setHours(13);
            date.setMinutes(4);
            date.setSeconds(45);
            calendarTOBaseBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOBaseBehaviorUnderTest.time();
            assert.strictEqual(res.toTimeString(), date.toTimeString());
        });
    });

    describe("setTime method", function () {
        it("should throw error if time is undefine", function () {
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.setTime();
            });
        });

        it("should throw error if time is null", function () {
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.setTime(null);
            });
        });

        it("should execute _getROPropertyWithoutEvents with 'time' without arguments if data is time", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("11:12:13");
                }
            };
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            var date = new Date();
            date.setHours(13);
            date.setMinutes(4);
            date.setSeconds(45);
            calendarTOBaseBehaviorUnderTest.setTime(date);
            sinon.assert.calledOnce(calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents);
            sinon.assert.calledWith(calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents, "time");
        });

        it("should throw error if result of _getROPropertyWithoutEvents is Unavailable", function () {
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns("Unavailable");
            var date = new Date();
            date.setHours(13);
            date.setMinutes(4);
            date.setSeconds(45);
            assert.throws(function () {
                calendarTOBaseBehaviorUnderTest.setTime(date);
            });
        });

        it("should call _executeWithEvents with SetDate and correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("11:12:13");
                }
            };
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            var date = new Date();
            date.setHours(13);
            date.setMinutes(4);
            date.setSeconds(45);
            calendarTOBaseBehaviorUnderTest.setTime(date);
            sinon.assert.calledOnce(calendarTOBaseBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOBaseBehaviorUnderTest._executeWithEvents, sinon.match({ 0: date }), "SetTime", "13:04:45");
        });

        it("should return a promise", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            var promiseMockExecute = {};
            calendarTOBaseBehaviorUnderTest._executeWithEvents.returns(promiseMockExecute);

            var date = new Date();
            date.setHours(13);
            date.setMinutes(4);
            date.setSeconds(45);
            var res = calendarTOBaseBehaviorUnderTest.setTime(date);
            assert.strictEqual(res, promiseMockExecute);
        });
    });
});

describe("CalendarTOBaseExtendedBehavior Tests", function () {
    var CalendarTOBaseExtendedBehavior = require("../lib/calendar_base.js").CalendarTOBaseExtendedBehavior;
    var calendarTOBaseExtendedBehaviorUnderTest = null;

    beforeEach(function () {
        calendarTOBaseExtendedBehaviorUnderTest = ObjectUtils.mergeTestBehavior(CalendarTOBaseExtendedBehavior);
        calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents = sinon.stub();
        calendarTOBaseExtendedBehaviorUnderTest._getROProperty = sinon.stub();
        calendarTOBaseExtendedBehaviorUnderTest._executeWithEvents = sinon.stub();
    });

    afterEach(function () {
        delete calendarTOBaseExtendedBehaviorUnderTest._getROProperty;
        delete calendarTOBaseExtendedBehaviorUnderTest._executeWithEvents;
        delete calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents;
    });

    describe("dateRange method", function () {
        it("should execute _getROProperty 'date'", function () {
            var promiseMock = { then: function (cb) { return cb("[13-Mar-2016 - 14-Apr-2016]"); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            calendarTOBaseExtendedBehaviorUnderTest.dateRange();
            sinon.assert.calledOnce(calendarTOBaseExtendedBehaviorUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOBaseExtendedBehaviorUnderTest._getROProperty, "date", sinon.match({}));
        });

        it("should throw error if result is null", function () {
            var promiseMock = { then: function (cb) { return cb(null); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.dateRange();
            });
        });

        it("should throw error if result is Unavailable", function () {
            var promiseMock = { then: function (cb) {
                return cb("Unavailable");
            } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.dateRange();
            });
        });

        it("should return a date Range if the return value is a single date", function () {
            var promiseMock = { then: function (cb) { return cb("13-Mar-2016"); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOBaseExtendedBehaviorUnderTest.dateRange();
            assert.deepEqual(res, { startDate: new Date(2016, 2, 13), endDate: new Date(2016, 2, 13) });
        });

        it("should return a date Range if the return value is a date range string", function () {
            var promiseMock = { then: function (cb) { return cb("[13-Mar-2016 - 14-Apr-2016]"); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOBaseExtendedBehaviorUnderTest.dateRange();
            assert.deepEqual(res, { startDate: new Date(2016, 2, 13), endDate: new Date(2016, 3, 14) });
        });
    });

    describe("setDateRange method", function () {
        it("should throw error if dateRangeOrStartDate is undefine", function () {
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.setDateRange();
            });
        });

        it("should throw error if dateRangeOrStartDate is null", function () {
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.setDateRange(null);
            });
        });

        it("should throw error if endDate is undefine", function () {
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.setDateRange(new Date(2016, 2, 17));
            });
        });

        it("should throw error if endDate is null", function () {
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.setDateRange(new Date(2016, 2, 17), null);
            });
        });

        it("should execute _getROPropertyWithoutEvents with 'date' without arguments if data is dateRange", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            calendarTOBaseExtendedBehaviorUnderTest.setDateRange({ startDate: new Date(2016, 2, 17), endDate: new Date(2017, 3, 18) });
            sinon.assert.calledOnce(calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents);
            sinon.assert.calledWith(calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents, "date");
        });

        it("should execute _getROPropertyWithoutEvents with 'date' without arguments if data is startDate and endDate", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            calendarTOBaseExtendedBehaviorUnderTest.setDateRange(new Date(2016, 2, 17), new Date(2017, 3, 18));
            sinon.assert.calledOnce(calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents);
            sinon.assert.calledWith(calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents, "date");
        });

        it("should throw error if result of _getROPropertyWithoutEvents is Unavailable", function () {
            calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents.returns("Unavailable");
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.setDateRange(new Date(2016, 2, 17), new Date(2017, 3, 18));
            });
        });

        it("should call _executeWithEvents with SetDateRange and correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            calendarTOBaseExtendedBehaviorUnderTest.setDateRange(new Date(2016, 2, 17), new Date(2017, 3, 18));
            sinon.assert.calledOnce(calendarTOBaseExtendedBehaviorUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOBaseExtendedBehaviorUnderTest._executeWithEvents, sinon.match({ 0: new Date(2016, 2, 17), 1: new Date(2017, 3, 18) }), "SetDateRange", "[17-Mar-2016 - 18-Apr-2017]");
        });

        it("should return a promise", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTOBaseExtendedBehaviorUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            var promiseMockExecute = {};
            calendarTOBaseExtendedBehaviorUnderTest._executeWithEvents.returns(promiseMockExecute);

            var res = calendarTOBaseExtendedBehaviorUnderTest.setDateRange(new Date(2016, 2, 17), new Date(2017, 3, 18));
            assert.strictEqual(res, promiseMockExecute);
        });
    });

    describe("isRangeSelected method", function () {
        it("should execute _getROProperty 'date'", function () {
            var promiseMock = { then: function (cb) { return cb("[13-Mar-2016 - 14-Apr-2016]"); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            calendarTOBaseExtendedBehaviorUnderTest.isRangeSelected();
            sinon.assert.calledOnce(calendarTOBaseExtendedBehaviorUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOBaseExtendedBehaviorUnderTest._getROProperty, "date", sinon.match({}));
        });

        it("should throw error if result is null", function () {
            var promiseMock = { then: function (cb) { return cb(null); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.isRangeSelected();
            });
        });

        it("should throw error if result is Unavailable", function () {
            var promiseMock = { then: function (cb) { return cb("Unavailable"); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOBaseExtendedBehaviorUnderTest.isRangeSelected();
            });
        });

        it("should return false if the return value is a single date", function () {
            var promiseMock = { then: function (cb) { return cb("13-Mar-2016"); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOBaseExtendedBehaviorUnderTest.isRangeSelected();
            assert.strictEqual(res, false);
        });

        it("should return true if the return value is a date range string", function () {
            var promiseMock = { then: function (cb) { return cb("[13-Mar-2016 - 14-Apr-2016]"); } };
            calendarTOBaseExtendedBehaviorUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOBaseExtendedBehaviorUnderTest.isRangeSelected();
            assert.strictEqual(res, true);
        });
    });
});