// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 06/12/2015.
 */
var Q = require("q");
var PromiseWrapper = require("../lib/promise_wrapper.js").PromiseWrapper;
var LftPromiseManager = require("../lib/promise_wrapper.js").LftPromiseManager;
var waitUntil = require("../lib/promise_wrapper.js").waitUntil;
var delay = require("../lib/promise_wrapper.js").delay;
var sinon = require("sinon");
var assert = require("assert");


function fastForward(clock, interval, times) {
    var deferred = Q.defer();
    var tickCalls = 0;
    var tick = function () {
        clock.tick(interval);
        if (++tickCalls < times)
            process.nextTick(tick);
        else
            process.nextTick(function () {
                deferred.resolve();
            });
    };
    process.nextTick(tick);

    return deferred.promise;
}

function PromiseMock() {
    this.myKey = "myValue";
    this.myFunc = function(){};
    this.inspect = sinon.stub().returns(this._state);
}

PromiseMock.prototype = {
    then: sinon.stub(),
    _state: {state:"pending"},
    prototypeKey: "prototypeValue",
    prototypeFunc: function(){}
};


describe("PromiseWrapper unit tests", function() {
    var promiseToWrap;
    var promiseToWrap2;
    var promiseManager;

    beforeEach(function(){
        promiseManager = new LftPromiseManager();
        promiseToWrap = new PromiseMock();
        promiseToWrap2 = new PromiseMock();
        promiseManager.init();
    });

    describe("then method", function() {
        var promiseMock;
        var promiseWrapperUnderTest;

        beforeEach(function(){
            promiseMock = new PromiseMock();
            promiseMock.then = sinon.stub().returns(promiseToWrap);
            promiseWrapperUnderTest = new PromiseWrapper(promiseManager, promiseMock);
        });

        it("should pass then call to the promise mock", function() {
            promiseWrapperUnderTest.then("a", "b");

            assert(promiseMock.then.calledOnce);
        });

        it("should return a PromiseWrapper of the returned promise", function() {
            var result = promiseWrapperUnderTest.then("a", "b");
            assert(result instanceof PromiseWrapper);
            assert.strictEqual(promiseWrapperUnderTest._wrapped, promiseMock);
            assert.strictEqual(result._wrapped, promiseToWrap);
        });
    });

    describe("testing with real promise", function() {
        var realPromise;
        var promiseWrapperUnderTest;

        beforeEach(function(){
            realPromise = Q.resolve(null);
            promiseWrapperUnderTest = promiseManager.init(realPromise);
        });

        describe("then method", function() {
            it("should call the fulfilled callback passed to then", function() {
                var callbackCalled = false;

                return promiseWrapperUnderTest.then(function() {
                    callbackCalled = true;
                }).then(function() {
                    assert(callbackCalled);
                });
            });

            it("should call rejected callback if fulfilled throws error", function(done) {
                promiseWrapperUnderTest.then(function() {
                    throw new Error("someError");
                }).then(function() {
                    done("Fulfilled called instead of rejected.")
                }, function() {
                    done();
                });
            });

            it("should call fulfilled after rejected callback if fulfilled throws error", function(done) {
                promiseWrapperUnderTest.then(function() {
                    throw new Error("someError");
                }).then(null, function() { })
                    .then(function() {
                        done();
                    }, function() {
                        done("rejected called instead of fulfilled.")
                    });
            });

            it("should pass result of fulfilled to next fulfilled as arg", function() {
                return promiseWrapperUnderTest.then(function() {
                    return 42;
                }).then(function(arg) {
                    assert.strictEqual(arg, 42);
                });
            });

            it("should pass result of rejected to next fulfilled as arg", function() {
                return promiseWrapperUnderTest.then(function() {
                    throw new Error("someError");
                }).then(null, function() {
                    return 100;
                }).then(function(arg) {
                    assert.strictEqual(arg, 100);
                });
            });
        });

        describe("catch method", function() {
            it("should catch thrown errors in catch statement", function(done) {
                var thrownError;
                promiseWrapperUnderTest.then(function() {
                    thrownError = new Error("someError");
                    throw thrownError;
                }).catch(function(e) {
                    try{
                        assert.strictEqual(e,thrownError);
                        done();
                    }catch(e){
                        done(e);
                    }
                });
            });

            it("should catch thrown errors in catch statement after multiple then calls without reject", function(done) {
                var error = new Error("someError");
                promiseWrapperUnderTest.then(function() {
                    throw error;
                }).then(function() {}, null).catch(function(e) {
                    assert.strictEqual(e, error);
                    done();
                });
            });

            it("should not catch thrown errors if reject function provided in next then", function() {
                var error = new Error("someError");
                return promiseWrapperUnderTest.then(function() {
                    throw error;
                }).then(null, function(e){
                    assert.strictEqual(e, error);
                }).catch(function() {
                    throw new Error("catch should not have been called");
                });
            });

            it("should catch exceptions thrown from rejected", function(done) {
                var error = new Error("some other Error");
                promiseWrapperUnderTest.then(function() {
                    throw new Error("someError");
                }).then(null, function(){
                    throw error;
                }).catch(function(e) {
                    assert.strictEqual(e, error);
                    done();
                });
            });

            it("should propagate the exception to the first reject callback that is provided and not call catch", function() {
                var error = new Error("someError");
                return promiseWrapperUnderTest.then(function() {
                    throw error;
                }).then(function(){
                    throw new Error("fullfill should not be called");
                }).then(null, function(e){
                    assert.strictEqual(e, error);
                }).catch(function() {
                    throw new Error("catch should not have been called");
                });
            });

            it("should allow chaining new promise after a catch statement", function(done) {
                var error = new Error("someError");
                promiseWrapperUnderTest.then(function() {
                    throw error;
                }).catch(function(e) {
                    assert.strictEqual(e, error);
                }).then(done, function() {
                    done(new Error("rejected called"));
                });
            });

            it("should not pass errors of one branch to other branches (non synced branches)", function (done) {
                promiseWrapperUnderTest.then(function() {
                    throw error;
                });

                promiseWrapperUnderTest.then(done, done);
            });

            it("should not modify previously resolved value if no exception in the chain", function (done) {
               promiseWrapperUnderTest.then(function () {
                   return "aaa";
               }).catch(function () {
                   done(new Error("catch code executed"));
               }).then(function (input) {
                   assert.equal(input, "aaa");
                   done();
               });
            });

            it("should modify previously resolved value if exception in the chain", function (done) {
                promiseWrapperUnderTest.then(function () {
                    return "aaa";
                }).then(function () {
                    throw new Error("something");
                }).catch(function () {
                    return "its ok";
                }).then(function (input) {
                    assert.equal(input, "its ok");
                    done();
                });
            });
        });

        describe("whenDone method", function() {
            it("should end the test when called without any promises in the test", function(done) {
                promiseManager.whenDone(done);
            });

            it("should call done callback without any parameters, even if the main synced branch ends with some result", function (done) {
                var someFuncStub = sinon.stub().returns(2);
                var doneStub = function () {
                    if(arguments.length != 0)
                        done(new Error("arguments.length != 0"));
                    else
                        done();
                };
                promiseManager.syncedBranchThen(someFuncStub);
                promiseManager.whenDone(doneStub);
            });

            it("should call the done callback passed to the done", function(done) {
                var fulfillCount = 0;
                function countIncrease() {
                    fulfillCount++;
                }
                function doneWrap() {
                    assert.strictEqual(fulfillCount, 2);
                    done();
                }
                promiseWrapperUnderTest.then(countIncrease).then(countIncrease);

                promiseManager.whenDone(doneWrap);
            });

            it("should call done.fail (Jasmine style) and pass it the error when error is thrown.", function(done) {
                var doneMock = {
                    fail: function(e) {
                        assert.strictEqual(e.message, "someError");
                        done();
                    }
                };

                promiseWrapperUnderTest.then(function() {
                    throw new Error("someError");
                });

                promiseManager.whenDone(doneMock);
            });

            it("should call done (Mocha style) and pass it the error when error is thrown if no done.fail.", function(done) {
                var doneMock =  function(e) {
                    assert.strictEqual(e.message, "someError");
                    done();
                };

                promiseWrapperUnderTest.then(function() {
                    throw new Error("someError");
                });

                promiseManager.whenDone(doneMock);
            });

            describe("should allow chaining new promise after a done statement", function() {
                var testDoneCalled = false;
                it("part 1", function(done1) {
                    promiseWrapperUnderTest.then(function() {});

                    promiseManager.whenDone(function() {
                        testDoneCalled = true;
                        done1();
                    });
                });

                it("part 2", function() {
                    return promiseManager.syncedBranchThen(
                        function() {
                            assert(testDoneCalled);
                        }, function() {
                            done2(new Error("rejected called"));
                        }
                    );
                });

            });

            describe("should allow chaining new promise after a done statement of a failed promise", function() {
                var error = new Error("someError");
                var testDoneCalled = false;
                var promise;

                it("part 1", function(done1) {
                    promise = promiseWrapperUnderTest.then(function() {
                        throw error;
                    });

                    promiseManager.whenDone(function(e) {
                        assert.strictEqual(e, error);
                        testDoneCalled = true;
                        done1();
                    });
                });
                it("part 2", function(done2) {
                    promiseManager.syncedBranchThen(function() {
                            assert(testDoneCalled);
                            done2();
                        }, function() {
                            done2(new Error("rejected called"));
                        }
                    );
                });
            });

            it("should call done without error in then->catch scenario when then throws", function(done) {
                promiseWrapperUnderTest.then(function() {
                    throw new Error("someError");
                }).catch(function() {});

                promiseManager.whenDone(done)
            });

            it("should call done with error in then->catch scenario when then throws and catch is null", function(done) {
                var error = new Error("someError");
                var doneMock = function(e) {
                    assert.strictEqual(e, error);
                    done();
                };

                promiseWrapperUnderTest.then(function() {
                    throw error;
                }).catch(null);

                promiseManager.whenDone(doneMock)
            });

            it("should fail the test with an uncaught exception thrown on one branch and skip promises on other branches", function(done) {
                var error = new Error("someError");
                var doneMock = function(e) {
                    assert.strictEqual(e, error);
                    done();
                };

                promiseWrapperUnderTest.then(function() {
                    throw error;
                });

                promiseWrapperUnderTest.then(function() {
                    assert.fail();//should not be here
                });

                promiseManager.whenDone(doneMock);
            });
        });


        describe("SyncedBranch tests", function () {
            it("should chain synced branch promises", function (done) {
                var fulfilled = sinon.stub();
                promiseManager.syncedBranchThen(fulfilled);

                promiseManager.syncedBranchThen(function () {
                    sinon.assert.calledOnce(fulfilled);
                    done();

                }, function()
                {
                    done(new Error("synced promise rejected"));
                });
            });

            it("should reject chain if synced promise is rejected", function (done) {
                promiseManager.syncedBranchThen(function () {
                    throw new Error("some error");
                });

                var fulfilled = sinon.stub();
                promiseManager.syncedBranchThen(fulfilled);

                promiseManager.syncedBranchThen(function () {
                    done(new Error("synced promise fulfilled"));
                }, function()
                {
                    sinon.assert.notCalled(fulfilled);
                    done();
                });

            });

            it("should fulfill a synced promise if none of its leafs fail", function (done) {
                var thenFunc = sinon.stub();
                promiseWrapperUnderTest.then(thenFunc);

                promiseManager.syncedBranchThen(function () {
                    sinon.assert.calledOnce(thenFunc);
                    done();
                }, function()
                {
                    done(new Error("synced promise rejected"));
                });
            });

            it("should fulfill a synced promise if none of its leafs fail due to a catch", function (done) {
                var catchFunc = sinon.stub();
                promiseWrapperUnderTest.then(function () {
                    throw new Error("some error");
                }).catch(catchFunc);

                promiseManager.syncedBranchThen(function () {
                    sinon.assert.calledOnce(catchFunc);
                    done();
                }, function()
                {
                    done(new Error("synced promise rejected"));
                });
            });

            it("should wait for all leafs of synced promise before next synced promise", function (done) {
                var thenFunc = sinon.stub();
                var thenFunc2 = sinon.stub();
                var thenFunc3 = sinon.stub();
                promiseWrapperUnderTest.then(thenFunc).then(thenFunc2);
                promiseWrapperUnderTest.then(thenFunc3);

                promiseManager.syncedBranchThen(function () {
                    sinon.assert.calledOnce(thenFunc);
                    sinon.assert.calledOnce(thenFunc2);
                    sinon.assert.calledOnce(thenFunc3);
                    done();
                }, function()
                {
                    done(new Error("synced promise rejected"));
                });

            });

            it("should reject a synced promise if one of its leafs fail", function (done) {
                var error = new Error("some error");
                promiseWrapperUnderTest.then(function () {
                    throw error;
                });

                promiseManager.syncedBranchThen(function () {
                    done(new Error("synced promise fulfilled"));
                }, function () {
                    done();
                });
            });

            it("should catch errors of previous synced promises in the chain", function (done) {
                var error = new Error("some error");
                promiseManager.syncedBranchThen(sinon.stub().throws(error));

                var fulfilledFunc = sinon.stub();
                promiseManager.syncedBranchThen(fulfilledFunc).catch(function (err) {
                    assert.strictEqual(err, error);
                    sinon.assert.notCalled(fulfilledFunc);
                    done();
                });
            });

            it("should fulfill synced promise after a synced promise with a catch", function (done) {
                var error = new Error("some error");
                promiseManager.syncedBranchThen(sinon.stub().throws(error));

                var fulfilledFunc = sinon.stub();
                var catchFunc = sinon.stub();
                promiseManager.syncedBranchThen(sinon.stub).catch(catchFunc);

                promiseManager.syncedBranchThen(fulfilledFunc).then(function () {
                    sinon.assert.calledOnce(catchFunc);
                    sinon.assert.calledOnce(fulfilledFunc);
                    done();
                }, done);
            });

            it("should fail a then statement with synced branch inside if one of them failed", function (done) {
                var error = new Error("some error");
                var fulfilledFunc = sinon.stub().throws(error);
                var fulfilledFunc2 = sinon.stub();
                promiseWrapperUnderTest.then(function () {
                    promiseManager.syncedBranchThen(fulfilledFunc);

                    promiseManager.syncedBranchThen(fulfilledFunc2);
                }).then(function () {
                    done(new Error("should not be fulfilled"));
                }, function (err) {
                    assert.strictEqual(err, error);
                    done();
                });
            });

            it("should not fail a then statement with synced branch inside if one of them failed but a catch exists", function (done) {
                var error = new Error("some error");
                var fulfilledFunc = sinon.stub().throws(error);
                var fulfilledFunc2 = sinon.stub();
                var catchFunc = sinon.stub();
                promiseWrapperUnderTest.then(function () {
                    promiseManager.syncedBranchThen(fulfilledFunc);

                    promiseManager.syncedBranchThen(fulfilledFunc2).catch(catchFunc);
                }).then(done, done);
            });

            it("should catch errors from a synced branch created inside the then", function (done) {
                var error = new Error("some error");
                var fulfilledFunc = sinon.stub().throws(error);
                var fulfilledFunc2 = sinon.stub();
                promiseWrapperUnderTest.then(function () {
                    promiseManager.syncedBranchThen(fulfilledFunc);

                    promiseManager.syncedBranchThen(fulfilledFunc2);
                }).catch(function (err) {
                    assert.strictEqual(err, error);
                    done();
                });
            });

            it("should not fail main synced branch if errors from a synced branch created inside the then are caught", function (done) {
                var error = new Error("some error");
                var fulfilledFunc = sinon.stub().throws(error);
                var fulfilledFunc2 = sinon.stub();
                var fulfilledFunc3 = sinon.stub();
                var catchFunc = sinon.stub();
                promiseWrapperUnderTest.then(function () {
                    promiseManager.syncedBranchThen(fulfilledFunc);

                    promiseManager.syncedBranchThen(fulfilledFunc2);
                }).catch(catchFunc);

                promiseManager.syncedBranchThen(fulfilledFunc3).then(function () {
                    sinon.assert.calledOnce(fulfilledFunc3);
                    done();
                }, done);
            });
        });

        describe("wrapPromiseFunctionWithNotifyEvents", function () {
            var onStart, onFinishOK, onFinishErr, promiseFunc;

            beforeEach(function () {
                onStart = sinon.stub();
                onFinishOK = sinon.stub();
                onFinishErr = sinon.stub();
            });

            describe("promiseFunc is fulfilled", function () {
                var fulfill;
                beforeEach(function () {
                    fulfill = sinon.stub().returns(5);
                    promiseFunc = function () {
                        return promiseManager.syncedBranchThen(fulfill);
                    };
                });
                it("should call the notify functions in correct order if promiseFunc fulfilled", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            sinon.assert.callOrder(onStart, fulfill, onFinishOK);
                        });
                });

                it("should not call onFinishErr if promiseFunc fulfilled", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            sinon.assert.notCalled(onFinishErr);
                        });
                });

                it("should pass onFinishOK result of promiseFunc if fulfilled", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            sinon.assert.calledWith(onFinishOK, 5);
                        });
                });

                it("should fulfill with result of promiseFunc if fulfilled", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function (res) {
                            assert.strictEqual(res, 5);
                        });
                });

                it("should fulfill with result of promiseFunc if fulfilled even if onFinishOK throws", function () {
                    onFinishOK.throws(new Error("some error"));

                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function (res) {
                            assert.strictEqual(res, 5);
                        });
                });
            });

            describe("promiseFunc is rejected", function () {
                var rejected;
                var error;
                beforeEach(function () {
                    error = new Error("some error");
                    rejected = sinon.stub().throws(error);
                    promiseFunc = function () {
                        return promiseManager.syncedBranchThen(rejected);
                    };
                });
                it("should call the notify functions in correct order if promiseFunc rejected", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            throw new Error("should not be fulfilled");
                        }, function () {
                            sinon.assert.callOrder(onStart, rejected, onFinishErr);
                        });
                });

                it("should not call onFinishOK if promiseFunc rejected", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            throw new Error("should not be fulfilled");
                        }, function () {
                            sinon.assert.notCalled(onFinishOK);
                        });
                });

                it("should pass onFinishErr the thrown error from promiseFunc if rejected", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            throw new Error("should not be fulfilled");
                        }, function () {
                            sinon.assert.calledWith(onFinishErr, error);
                        });
                });

                it("should reject with error of promiseFunc if rejected", function () {
                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            throw new Error("should not be fulfilled");
                        }, function (err) {
                            assert.strictEqual(err, error);
                        });
                });

                it("should reject with error of promiseFunc if rejected even if onFinishErr throws", function () {
                    onFinishErr.throws(new Error("some other error"));

                    return promiseManager.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFunc, onFinishOK, onFinishErr)
                        .then(function () {
                            throw new Error("should not be fulfilled");
                        }, function (err) {
                            assert.strictEqual(err, error);
                        });
                });
            });
        });

        describe("waitUntil", function () {
            it("should call checkFunc once and returned resolved promise if checkFunc returns true", function () {
                var checkFunc = sinon.stub().returns(true);
                return waitUntil(promiseManager, checkFunc).then(function () {
                    sinon.assert.calledOnce(checkFunc);
                });
            });

            [true, Q.resolve(true)].forEach(function (checkFuncResult) {
                var resultMsg = checkFuncResult.then ? "Q.resolve(true)" : "true";
                it("should return true if checkFunc returns " + resultMsg, function () {
                    var checkFunc = sinon.stub().returns(checkFuncResult);
                    return waitUntil(promiseManager, checkFunc).then(function (res) {
                        assert.strictEqual(res, true);
                    });
                });
            });

            [false, Q.resolve(false)].forEach(function (checkFuncResult) {
                var resultMsg = checkFuncResult.then ? "Q.resolve(false)" : "false";
                it("should resolve to false if timeout occurs (checkFunc returns: " + resultMsg + ")", function () {
                    var checkFunc = sinon.stub().returns(checkFuncResult);
                    return waitUntil(promiseManager, checkFunc, 100).then(function (res) {
                        assert.strictEqual(res, false);
                    });
                });
            });


            it("should call checkFunc only once if timeout is less than 500", function () {
                var checkFunc = sinon.stub().returns(false);
                return waitUntil(promiseManager, checkFunc, 100).then(function () {
                    sinon.assert.calledOnce(checkFunc);
                });
            });

            describe("timer tests", function () {
                beforeEach(function () {
                    this.clock = sinon.useFakeTimers();
                });

                afterEach(function () {
                    this.clock.restore();
                });

                it("should call checkFunc until it is resolved to true", function () {
                    var checkFunc = sinon.stub();
                    checkFunc.onFirstCall().returns(false);
                    checkFunc.onSecondCall().returns(false);
                    checkFunc.onThirdCall().returns(true);

                    waitUntil(promiseManager, checkFunc);

                    return fastForward(this.clock, 500, 3).then(function () {
                        sinon.assert.calledThrice(checkFunc);
                    });
                });

                it("should reject if checkFunc throws error", function () {
                    var checkFunc = sinon.stub();
                    checkFunc.onFirstCall().returns(false);
                    checkFunc.onSecondCall().returns(false);
                    checkFunc.onThirdCall().throws(new Error("some error"));

                    var waitPromise = waitUntil(promiseManager, checkFunc);

                    return fastForward(this.clock, 500, 3).then(function () {
                        sinon.assert.calledThrice(checkFunc);
                        assert(waitPromise._wrapped.isRejected());
                    });
                });

                it("should resolve to false after timeout", function () {
                    var checkFunc = sinon.stub().returns(Q.resolve(false));
                    var waitPromise = waitUntil(promiseManager, checkFunc, 2900);

                    var clock = this.clock;
                    return fastForward(clock, 500, 6).then(function () {
                        assert.strictEqual(waitPromise._wrapped.isFulfilled(), true);
                        sinon.assert.callCount(checkFunc, 6);
                    });
                });
            });
        });

        describe("delay tests", function() {
            beforeEach(function () {
                this.clock = sinon.useFakeTimers();
            });

            afterEach(function () {
                this.clock.restore();
            });

            it("should execute code after the delay", function() {
                var stub = sinon.stub();

                delay(promiseManager, 10).then(stub);

                var clock = this.clock;
                return fastForward(clock, 9, 1).then(function() {
                    sinon.assert.notCalled(stub);
                    return fastForward(clock, 1, 1).then(function() {
                       sinon.assert.calledOnce(stub);
                    });
                });
            });
        });
    });
});
