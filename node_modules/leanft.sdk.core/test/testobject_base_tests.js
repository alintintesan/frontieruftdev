// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 24/11/2015.
 * Unittests for the test object base and the description base.
 */

var assert = require("assert");
var sinon = require("sinon");
var TestObjectBase = require("../lib/testobject_base.js").TestObjectBase;
var TestObjectParser = require("../lib/testobject_base.js").TestObjectParser;

describe("TestObjectBase unit tests",function(){
    var testObjectUnderTest;
    beforeEach(function() {
        testObjectUnderTest = new TestObjectBase();
    });

    describe("highlight", function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");
            testObjectUnderTest.notifyWithEvents =  function(func) {
                return func.call(this);
            };
        });
        it("should call the _executeCommand method and pass the method name",function(){
            testObjectUnderTest.highlight();
            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.firstCall.args[0], "highlight");
        });
        it("should return the same promise that was returned from _executeCommand method",function(){
            var promise = {};
            testObjectUnderTest._executeCommand.returns(promise);
            var res = testObjectUnderTest.highlight();
            assert.strictEqual(res,promise);
        });
    });

    describe("exists", function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");
            testObjectUnderTest._session = {
                _config:{
                }
            };
        });
        it("should call the _executeCommand method and pass the method name",function(){
            testObjectUnderTest.exists();
            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.firstCall.args[0], "Exist");
        });
        it("should return the same promise that was returned from _executeCommand method",function(){
            var promise = {};
            testObjectUnderTest._executeCommand.returns(promise);
            var res = testObjectUnderTest.exists();
            assert.strictEqual(res,promise);
        });
        it("should throw error if null passed", function(){
            assert.throws(function(){
                testObjectUnderTest.exists(null);
            });
        });
        it("should pass the method name and timeout value if passed", function(){
            testObjectUnderTest.exists(5000);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args, ["Exist", 5000]);
        });

        it("should add additional data handler if _saveLastAdditionalInfo is true", function(){
            testObjectUnderTest._session._config._saveLastAdditionalInfo = true
            testObjectUnderTest.exists();
            sinon.assert.calledWith(testObjectUnderTest._executeCommand, "Exist", sinon.match.func);
        });

        it("should add additional data handler if _saveLastAdditionalInfo is true (with timeout)", function(){
            testObjectUnderTest._session._config._saveLastAdditionalInfo = true
            testObjectUnderTest.exists(5000);
            sinon.assert.calledWith(testObjectUnderTest._executeCommand, "Exist", 5000, sinon.match.func);
        });

        it("should store additional data on test object when additinoal data handler is called", function(){
            testObjectUnderTest._session._config._saveLastAdditionalInfo = true
            testObjectUnderTest._lastAdditionalData = "old data";
            testObjectUnderTest.exists();
            sinon.assert.calledWith(testObjectUnderTest._executeCommand, "Exist", sinon.match.func);
            var additinoalDataHandler = testObjectUnderTest._executeCommand.firstCall.args[1];
            additinoalDataHandler("some data");
            assert.equal(testObjectUnderTest._lastAdditionalData, "some data");
        });
    });

    describe("highlightMatches", function() {
        var testObjectMock;
        var descMock;

        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");

            testObjectUnderTest._session = {
                factory:{
                    create: sinon.stub()
                }
            };

            testObjectUnderTest.notifyWithEvents = function(func) {
                return func.call(this);
            };

            testObjectMock = {};

            testObjectUnderTest._session.factory.create.returns(testObjectMock);

            descMock = {
                _toJSON: function() {
                    return {
                        Properties: {tagName: "a"}
                    };
                }
            };
        });

        it("should call _executeCommand with null description if null description passed", function() {
            testObjectUnderTest.highlightMatches(null);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("HighlightAllMatchingChildren", null));
        });

        it("should call _executeCommand with null description if null description passed and flag set", function() {
            testObjectUnderTest.highlightMatches(null, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("HighlightAllMatchingChildren", null));
        });

        it("should add Type: Description and micclass to the description JSON", function() {
            testObjectUnderTest.highlightMatches(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Type, "Description");
        });

        it("should not add native class if flag set to true", function() {
            var expectedFilter = {
                Properties: {
                    tagName: "a"
                },
                Type: "Description"
            };

            testObjectUnderTest.highlightMatches(descMock, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1], expectedFilter);
        });

        it("should use native class of the test object", function() {
            testObjectMock._nativeClass = "SomeType";

            testObjectUnderTest.highlightMatches(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.micclass, "SomeType");
        });

        it("should use _nativeTypeFieldName of the test object if defined", function() {
            testObjectMock._nativeClass = "SomeType";
            testObjectMock._nativeTypeFieldName = "SomeNativeTypeFieldName";

            testObjectUnderTest.highlightMatches(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.SomeNativeTypeFieldName
                , "SomeType");
        });

        it("should return the result of _executeCommand as is", function() {
            testObjectUnderTest._executeCommand.returns("aaa");

            var res = testObjectUnderTest.highlightMatches(descMock);
            assert.strictEqual(res, "aaa");
        });
    });

    describe("$$ - findChildren", function() {
        var testObjectMock;
        var descMock;

        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");

            testObjectUnderTest._session = {
                factory:{
                    create: sinon.stub()
                }
            };

            testObjectMock = {};

            testObjectUnderTest._session.factory.create.returns(testObjectMock);

            descMock = {
                _toJSON: function() {
                    return {
                        Properties: {a: "aa"}
                    };
                }
            };
        });

        it("should call _executeCommand with null description if null description passed", function() {
            testObjectUnderTest.$$(null);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("ChildObjects", null));
        });

        it("should call _executeCommand with null description if null description passed and flag set", function() {
            testObjectUnderTest.$$(null, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("ChildObjects", null));
        });

        it("should add Type: Description and micclass to the description JSON", function() {
            testObjectUnderTest.$$(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Type, "Description");
        });

        it("should not add native class if flag set to true", function() {
            var expectedFilter = {
                Properties: {
                    a: "aa"
                },
                Type: "Description"
            };

            testObjectUnderTest.$$(descMock, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1], expectedFilter);
        });

        it("should use native class of the test object", function() {
            testObjectMock._nativeClass = "SomeType";

            testObjectUnderTest.$$(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.micclass, "SomeType");
        });

        it("should use _nativeTypeFieldName of the test object if defined", function() {
            testObjectMock._nativeClass = "SomeType";
            testObjectMock._nativeTypeFieldName = "SomeNativeTypeFieldName";

            testObjectUnderTest.$$(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.SomeNativeTypeFieldName
                , "SomeType");
        });

        it("should return the result of _executeCommand as is", function() {
            testObjectUnderTest._executeCommand.returns("aaa");

            var res = testObjectUnderTest.$$(descMock);
            assert.strictEqual(res, "aaa");
        });
    });

    describe("_getResultValue", function() {
        beforeEach(function() {
            testObjectUnderTest._init(null, null, null);
        });

        it("should return null if null passed", function() {
            assert.strictEqual(testObjectUnderTest._getResultValue(null), null);
        });

        it("should return simple value as is", function() {
            assert.strictEqual(testObjectUnderTest._getResultValue("aaa"), "aaa");
        });

        it("should return array of simple values as is", function() {
            assert.deepEqual(testObjectUnderTest._getResultValue([1, "aaa"]), [1, "aaa"]);
        });

        describe("Type: TestObject", function() {
            var testObjectMock;

            beforeEach(function() {
                testObjectUnderTest._session = {
                    factory: {
                        createByNativeClass: sinon.stub()
                    }
                };
                testObjectMock = {
                    _useCachedProperties: sinon.mock()
                };
                testObjectUnderTest._session.factory.createByNativeClass.returns(testObjectMock);
            });

            it("should throw error if test object does not have server cookie", function() {
                assert.throws(function(){
                    testObjectUnderTest._getResultValue({
                        Type: "TestObject"
                    });
                });
            });



            it("should return the created test object", function() {
                var res = testObjectUnderTest._getResultValue({
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass"
                });

                assert.strictEqual(res, testObjectMock);
            });
        });

        describe("Type: DynamicProxy", function() {
            var nativeObjProto = require("../lib/native_object.js").prototype;

            beforeEach(function() {
                sinon.stub(nativeObjProto, "_fillKeysFromMembers").returnsThis();
                testObjectUnderTest._session = {someKey: "value"};
            });

            afterEach(function() {
                nativeObjProto._fillKeysFromMembers.restore();
            });

            it("should throw error if native object does not have server cookie", function() {
                assert.throws(function(){
                    testObjectUnderTest._getResultValue({
                        Type: "DynamicProxy"
                    });
                });
            });

            it("should create a NativeObject with correct cookie and session", function() {
                var res =  testObjectUnderTest._getResultValue({
                    Type: "DynamicProxy",
                    ServerCookie: 15
                });

                assert.strictEqual(res._proxyId, 15);
                assert.strictEqual(res._session, testObjectUnderTest._session);
            });

            it("should call the _fillKeysFromMembers of the native object", function() {
                testObjectUnderTest._getResultValue({
                    Type: "DynamicProxy",
                    ServerCookie: 15
                });

                assert(nativeObjProto._fillKeysFromMembers.calledOnce);
            });
        });
    });

    describe("error handling", function() {
        var resultPromise;
        var sessionMock;

        beforeEach(function(){
            sessionMock = {
                _communication: {
                    send: sinon.stub()
                }
            };

            resultPromise = {
                then: sinon.stub()
            };
            sessionMock._communication.send.returns(resultPromise);

            testObjectUnderTest._init(null,sessionMock,null);
        });

        it("should throw the given exception in case the error code is one of general errors",function(){
            var error = new Error("SomeError");
            error.statusCode = -100;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/SomeError/);
        });

        it("should throw the given exception in case there is no statusCode",function(){
            var error = new Error("SomeError");
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/SomeError/);
        });

        it("should translate code of a replay error to correct message",function(){
            var error = new Error("");
            error.statusCode = -111;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/ReplayObjectNotFoundException/);
        });

        it("should concat error message passed with the translation of the replay error",function(){
            var error = new Error("some error");
            error.statusCode = -111;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/ReplayObjectNotFoundException: some error/);
        });

        it("should convert native types to lean ft types in the error message", function() {
            testObjectUnderTest._init("NativeClass", sessionMock, {
                leanFTType: {
                    technology: "Tech",
                    leanftType: "LeanFtType"
                },
                _toJSON: sinon.stub()
            });

            testObjectUnderTest._parent = new TestObjectBase();

            testObjectUnderTest._parent._init("ParentNativeClass", sessionMock, {
                leanFTType: {
                    technology: "Tech2",
                    leanftType: "ParentLeanFtType"
                },
                _toJSON: sinon.stub()
            });

            var error = new Error("[ NativeClass ], [ ParentNativeClass ] (of class blablabla) aaa");
            error.statusCode = -111;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/ReplayObjectNotFoundException: Tech.LeanFtType, Tech2.ParentLeanFtType aaa/);
        });
    });

    describe("snapshot",function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");
        });

        it("should execute the command CaptureSnapshotToBase64String and pass the given format",function(){
            testObjectUnderTest.snapshot({format:"bmp"});

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args,["CaptureSnapshotToBase64String","bmp"]);
        });

        it("should default the format to png",function(){
            testObjectUnderTest.snapshot({});

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args,["CaptureSnapshotToBase64String","png"]);
        });

        it("should create default object in case no options is given",function(){
            testObjectUnderTest.snapshot();

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args,["CaptureSnapshotToBase64String","png"]);
        });

        it("should return the result given from the execute command",function(){
            testObjectUnderTest._executeCommand.returns(42);
            var res = testObjectUnderTest.snapshot();

            assert.strictEqual(res,42);
        });
    });

    describe("getVisibleText", function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeUtilityCommand");
        });

        it("should execute the command GetTestObjectVisibleText with ExecuteTestObjectOcrCommand command type and GetTestObjectVisibleText method name, and pass default rectangle value", function(){
            testObjectUnderTest.getVisibleText();

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectVisibleText", -1, -1, -1, -1]);
        });

        it("should execute the command GetTestObjectVisibleText with the given rectangle values", function(){
            testObjectUnderTest.getVisibleText({x:10,y:20,width:30,height:40});

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectVisibleText", 10, 20, 40, 60]);
        });
    });

    describe("getTextLocations", function() {
        beforeEach(function () {
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb){return cb(null);}
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);
        });

        it("should execute the command GetTestObjectTextLocations with ExecuteTestObjectOcrCommand command type and GetTestObjectTextLocations method name, Text as text to search for, and default rectangle parameter values", function(){
            var result = testObjectUnderTest.getTextLocations("Text");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectTextLocations", "Text", -1, -1, -1, -1]);
            assert.equal(result, null);
        });

        it("should execute the command GetTestObjectTextLocations with the given rectangle values", function(){
            var result = testObjectUnderTest.getTextLocations("Text", {x:10,y:20,width:30,height:40});

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectTextLocations", "Text", 10, 20, 40, 60]);
            assert.equal(result, null);
        });

        it("should throw exception if text argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.getTextLocations();
            });
        })
    });


    describe("verifyImageExists", function() {
        beforeEach(function () {
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            testObjectUnderTest.notifyWithEvents =  function(func) {
                return func.call(this);
            };

            var resultPromise = {
                then: function(cb){return cb(null);}
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);
        });

        it("should execute the command FindBitmapInTestObject with ExecuteTestObjectImageCommand command type and FindBitmapInTestObject method name, Base64String as imageToFind parameter and empty string as last parameter", function(){
            testObjectUnderTest.verifyImageExists("Base64String");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args.splice(0,4), ["ExecuteTestObjectImageCommand", "FindBitmapInTestObject", "Base64String", ""]);
        });

        it("should execute the command FindBitmapInTestObject and return the point if the similarity argument passed is less than the actual similarity returned", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        actualSimilarity: 10,
                        point: {
                            x: 20,
                            y: 30
                        }
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultPoint = testObjectUnderTest.verifyImageExists("Base64String", 5);

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(resultPoint, {x:20, y:30});
        });

        it("should execute the command FindBitmapInTestObject and return the point if the similarity argument passed as numeric string is less than the actual similarity returned", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        actualSimilarity: "10",
                        point: {
                            x: 20,
                            y: 30
                        }
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultPoint = testObjectUnderTest.verifyImageExists("Base64String", 5);

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(resultPoint, {x:20, y:30});
        });

        it("should execute the command FindBitmapInTestObject and return null if the similarity argument passed is larger than the actual similarity returned", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        actualSimilarity: 5,
                        point: {
                            x: 20,
                            y: 30
                        }
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultPoint = testObjectUnderTest.verifyImageExists("Base64String", 10);

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(resultPoint, null);
        });

        it("should throw exception if imageToFind argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists();
            });
        });

        it("should throw exception if similarity is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists("Base64String", -1);
            });
        });

        it("should throw exception if similarity is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists("Base64String", 200);
            });
        });

        it("should throw exception if similarity passed as string is not a numeric string", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists("Base64String", "10a");
            });
        });
    });

    describe("verifyImageMatch", function() {
        beforeEach(function () {
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            testObjectUnderTest.notifyWithEvents = function(func) {
                return func.call(this);
            };
            var resultPromise = {
                then: function(cb){return cb(null);}
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);
        });

        it("should execute the command CompareTestObjectWithBitmap with ExecuteTestObjectImageCommand command type and FindBitmapInTestObject method name, Base64String1 as expectedImage parameter and string empty as maskAreaImage parameter", function(){
            testObjectUnderTest.verifyImageMatch("Base64String1");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args.slice(0,6), ["ExecuteTestObjectImageCommand", "CompareTestObjectWithBitmap", "Base64String1", "", 0, 0]);
        });

        it("should throw exception if expectedImage argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch();
            });
        });

        it("should throw exception if pixelTolerance is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", -1);
            });
        });

        it("should throw exception if pixelTolerance is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", 200);
            });
        });

        it("should throw exception if pixelTolerance is string", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", "abcd");
            });
        });

        it("should throw exception if rgbTolerance is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", 10, -1);
            });
        });

        it("should throw exception if pixelTolerance is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", 10, 200);
            });
        });

        it("should execute the command CompareTestObjectWithBitmap and return true when the communication result contains true in imagesMatch", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        imagesMatch: true,
                        base64EncodedDiffImage: "Base64String3"
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultValue = testObjectUnderTest.verifyImageMatch("Base64String1");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.equal(resultValue, true);
        });

    });

    describe("verifyImageMatchWithMask", function() {
        beforeEach(function () {
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            testObjectUnderTest.notifyWithEvents = function(func) {
                return func.call(this);
            };
            var resultPromise = {
                then: function(cb){return cb(null);}
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);
        });

        it("should execute the command CompareTestObjectWithBitmap with ExecuteTestObjectImageCommand command type and FindBitmapInTestObject method name, Base64String1 as expectedImage parameter and Base64String2 as maskAreaImage parameter", function(){
            testObjectUnderTest.verifyImageMatchWithMask("Base64String1", "Base64String2");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args.slice(0,6), ["ExecuteTestObjectImageCommand", "CompareTestObjectWithBitmap", "Base64String1", "Base64String2", 0, 0]);
        });

        it("should throw exception if expectedImage argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatchWithMask();
            });
        });

        it("should throw exception if maskAreaImage argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatchWithMask("Base64String1");
            });
        });

        it("should throw exception if pixelTolerance is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatchWithMask("Base64String1", "Base64String2", -1);
            });
        });

        it("should throw exception if pixelTolerance is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatchWithMask("Base64String1", "Base64String2", 200);
            });
        });

        it("should throw exception if rgbTolerance is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatchWithMask("Base64String1", "Base64String2", 10, -1);
            });
        });

        it("should throw exception if pixelTolerance is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatchWithMask("Base64String1", "Base64String2", 10, 200);
            });
        });

        it("should execute the command CompareTestObjectWithBitmap and return true when the communication result contains true in imagesMatch", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        imagesMatch: true,
                        base64EncodedDiffImage: "Base64String3"
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultValue = testObjectUnderTest.verifyImageMatchWithMask("Base64String1", "Base64String2");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.equal(resultValue, true);
        });

    });

    describe("description", function () {
        it("should return the value of the _description member", function () {
            testObjectUnderTest._description = "someDescription";
            assert.strictEqual(testObjectUnderTest.description(), "someDescription");
        });
    });

    describe("parent", function () {
        it("should return the value of the _parent member", function () {
            testObjectUnderTest._parent = "someParent";
            assert.strictEqual(testObjectUnderTest.parent(), "someParent");
        });
    });

    describe("displayName property", function (){
        it("should return null if not initialized",function(){
            var displayName = testObjectUnderTest.displayName;
            assert.deepEqual(displayName, null);
        });

        it("should return null result if displayName object is null",function(){
            testObjectUnderTest.displayName = 'value';
            var displayName = testObjectUnderTest.displayName;
            assert.deepEqual(displayName, 'value');
            testObjectUnderTest.displayName = null;
            displayName = testObjectUnderTest.displayName;
            assert.deepEqual(displayName, null);
        });

        it("should return correct displayName value",function(){
            testObjectUnderTest.displayName = 'value';
            var displayName = testObjectUnderTest.displayName;
            assert.deepEqual(displayName, 'value');
        });
    });

    describe("_useCachedProperties",function() {
        beforeEach(function(){
            testObjectUnderTest._logger = {info:sinon.stub()};
        });

        afterEach(function(){
            delete testObjectUnderTest._logger;
        });

        it("should call the update proxy func if runtime access mode is accessOnUnknownOperationOrProperty", function() {
            var executor = {_executor:{}};
            testObjectUnderTest._executor = executor;
            testObjectUnderTest._useCachedProperties({version:'value'}, 'accessOnUnknownOperationOrProperty');
            assert.notDeepEqual(testObjectUnderTest._executor, executor);
        });

        it("should call the update proxy func if runtime access mode is neverAccess", function() {
            var executor = {_executor:{}};
            testObjectUnderTest._executor = executor;
            testObjectUnderTest._useCachedProperties({version:'value'},  'neverAccess');
            assert.notDeepEqual(testObjectUnderTest._executor, executor);
        });

        it("should not call the update proxy func if runtime access mode is noProxy", function() {
            var executor = {_executor:{}};
            testObjectUnderTest._executor = executor;
            testObjectUnderTest._useCachedProperties({version:'value'},  'noProxy');
            assert.deepEqual(testObjectUnderTest._executor, executor);
        });
    });

    describe("_throwUnsupportedErrorAsync",function() {
        var Q = require("q");

        beforeEach(function () {
            testObjectUnderTest._session = {
                _promiseManager: {
                    syncedBranchThen: function(callback) {
                        try {
                            callback();
                        } catch(e) {
                            return Q.reject(e);
                        }
                    }
                }
            };
        });

        it("should return rejected Promise with Error.isNotSupported === true", function(done) {
            testObjectUnderTest._throwUnsupportedErrorAsync().then(function() {
                done(new Error("error is not thrown"));
            }).catch(function(err) {
                try{
                    assert(err.isNotSupported === true, "should throw Error.isNotSupported === true");
                    done();
                } catch(e) {
                    done(e);
                }
            });
        });
    });

    describe("TestObjectParser",function() {
        describe("createTestObjectFromJson",function() {
            var sessionMock = null;
            var testObjectMock;

            beforeEach(function() {
                testObjectMock = {
                    _nativeClass: "someNativeClass",
                    _useCachedProperties: sinon.mock(),
                    _description:{
                        _properties:[],_insertValue: function(key,value){
                            this._properties[key] = value;
                        }
                    }};

                sessionMock = {
                    factory: {
                        createByNativeClass: sinon.stub()
                    }
                };

                sessionMock.factory.createByNativeClass.returns(testObjectMock);
            });

            it("should return null if session is null", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(null,{},{});
                assert.equal(null, testObject);
            });

            it("should return null if session is undefined", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(undefined,{},{});
                assert.equal(null, testObject);
            });

            it("should return null if jsonInfo is null", function() {
                var testObject = TestObjectParser.createTestObjectFromJson({},null,{});
                assert.equal(null, testObject);
            });

            it("should return null if jsonInfo is undefined", function() {
                var testObject = TestObjectParser.createTestObjectFromJson({},undefined,{});
                assert.equal(null, testObject);
            });

            it("should throw error if cookie and description are not exist", function() {
                assert.throws(function(){
                    TestObjectParser.createTestObjectFromJson({},{},{});
                });
            });

            it("should call createByNativeClass and pass it the class of the TestObject", function() {
                TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass"
                });

                assert(sessionMock.factory.createByNativeClass.calledOnce);
                assert.equal(sessionMock.factory.createByNativeClass.getCall(0).args[0],
                    "SomeClass");
            });

            it("should pass sub class to createByNativeClass if defined", function() {
                TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass",
                    SubTypeInfo: {
                        SimClass: "SubClass"
                    }
                });

                assert(sessionMock.factory.createByNativeClass.calledOnce);
                assert.equal(sessionMock.factory.createByNativeClass.getCall(0).args[0],
                    "SomeClass");
                assert.equal(sessionMock.factory.createByNativeClass.getCall(0).args[1],
                    "SubClass");
            });

            it("should set the cookie of the created test object", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass"
                });

                assert.strictEqual(testObject._cookie, 123);
            });

            it("should set the displayName of the created test object", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass",
                    Name: "MyName"
                });

                assert.strictEqual(testObject.displayName, "MyName");
            });

            it("should put the properties inside the application info in case created test object is application context",function(){
                sessionMock.factory.createByNativeClass.returns({
                    _getApplicationInfo: sinon.stub(),
                    _useCachedProperties: sinon.stub()
                });

                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass",
                    Name: "MyName",
                    Properties: {
                        key: "value"
                    }
                });

                assert.deepEqual(testObject._applicationInfo,{
                    key: "value"
                });
            });

            it("should use the description", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'WinButton',
                    Description : {
                        Properties : {
                        },
                        "Index": 0,
                    }
                });

                assert.strictEqual(testObject._description._indexType, "Index");
                assert.strictEqual(testObject._description._index, 0);
            });

            it("should return description without index", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'WinButton',
                    Description : {
                        Properties : {
                        },
                    }
                });

                assert.strictEqual(testObject._description._indexType, undefined);
                assert.strictEqual(testObject._description._index, undefined);
            });

            it("should return description without index when index is null", function() {
                  var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'WinButton',
                    Description : {
                        Properties : {
                        },
                        Index: null
                    }
                });

                assert.strictEqual(testObject._description._indexType, undefined);
                assert.strictEqual(testObject._description._index, undefined);
            });

            it("should return description with creation time index", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'WinButton',
                    Description : {
                        Properties : {
                        },
                        Index: {
                            creationtime:0
                        }
                    }
                });

                assert.strictEqual(testObject._description._indexType, "creationtime");
                assert.strictEqual(testObject._description._index, 0);
            });

            it("should throw exception since index object contains more than one object creation time index", function() {
                assert.throws(function() {
                    var testObject = TestObjectParser.createTestObjectFromJson(sessionMock, {
                        Class: 'WinButton',
                        Description: {
                            Properties: {},
                            Index: {
                                creationtime: 0,
                                somekey:1
                            }
                        }
                    });
                });
            });


            it("should return description with filtered properties due to IdentificationList", function() {
                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'WinButton',
                    Description : {
                        Identification:["name1"],
                        Properties : {
                            name1:"val1",
                            name1:"val1"
                        },
                        Index: {
                            creationtime:0
                        }
                    }
                });

                assert.strictEqual(testObject._description._properties.name1, "val1");
                assert.strictEqual(testObject._description._properties.name2, undefined);
            });

            it("should create description with grouped item", function() {
                testObjectMock._description._properties.AbsoluteLocation = {
                    _keysMap:{
                        x:"abs_x",
                        y:"abs_y"
                    }
                };

                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'WinButton',
                    Description : {
                        Properties : {
                            abs_x : 1085,
                            abs_y : 556,
                        }
                    },
                    Name : 'Button'
                });
                assert.strictEqual(testObject._description._properties.AbsoluteLocation.x, 1085);
                assert.strictEqual(testObject._description._properties.AbsoluteLocation.y, 556);
            });


            it("should create description with prefixed items", function() {
                testObjectMock._description._properties.Attributes = {
                    _keyPrefix:"attribute/"
                };

                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'WinButton',
                    Description : {
                        Properties : {
                            "attribute/x" : "xxx",
                            "attribute/y" : "yyy"

                        }
                    },
                    Name : 'Button'
                });
        		assert.deepEqual(testObject._description._properties.Attributes,{_keyPrefix:"attribute/",x:"xxx",y:"yyy"});
            });

            it("should set innerText value to text value if test object is a web link", function () {
                testObjectMock._nativeClass = "link";

                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'Link',
                    Description : {
                        Properties : {
                            text : "Link text"
                        }
                    }
                });

                assert.strictEqual(testObject._description._properties.innerText, "Link text");
            });

            it("should set innerText value to text value if test object is a web link with identification in the description", function () {
                testObjectMock._nativeClass = "link";

                var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
                    Class : 'Link',
                    Description : {
                        Identification: [
                            "text"
                        ],
                        Properties : {
                            text : "Link text"
                        }
                    }
                });

                assert.strictEqual(testObject._description._properties.innerText, "Link text");
            });
        });

        //    it("should use the description", function() {
        //        var testObject = TestObjectParser.createTestObjectFromJson(sessionMock,{
        //            Class : 'WinButton',
        //            Description : {
        //                Properties : {
        //                    abs_x : 1085,
        //                    abs_y : 556,
        //                }
        //            },
        //            Name : 'Button'
        //        });
        //
        //        assert.strictEqual(testObject.displayName, "MyName");
        //    });
        //});
    });

});
