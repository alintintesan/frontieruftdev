// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 19/11/2015.
 * Unit tests for the description base object.
 */

var assert = require("assert");
var sinon = require("sinon");
var DescriptionBase = require("../lib/description_base.js");

describe("DescriptionBase",function(){
    var descriptionUnderTest;
    beforeEach(function(){
        descriptionUnderTest = new DescriptionBase();
        descriptionUnderTest._init();
    });

    describe("index method should be called and except a value", function() {

        it("should called once", function () {
            descriptionUnderTest.index = sinon.stub();
            descriptionUnderTest.index(0);
            assert.equal(descriptionUnderTest.index.firstCall.args[0], 0);
        });
        it("when value is given, should add _index to description",function(){
            descriptionUnderTest.index(0);
            assert.strictEqual(descriptionUnderTest._index, 0);
        });
        it("when index is given using property bag, should initialize _index",function(){
            descriptionUnderTest._defineByPropertyBag({
                index: 1
            });
            assert.strictEqual(descriptionUnderTest._index, 1);
        });
        it("when value is given, should return this - builder pattern",function(){
            var result = descriptionUnderTest.index(0);
            assert.strictEqual(result, descriptionUnderTest);
        });
        it("when value is null, should remove '_index' from description",function(){
            descriptionUnderTest._index = 0;
            descriptionUnderTest.index(null);
            assert.strictEqual(descriptionUnderTest._index, null);
            var index = descriptionUnderTest.index();
            assert.strictEqual(index, null);
            descriptionUnderTest.index(7);
            index = descriptionUnderTest.index();
            assert.equal(index, 7);
        });
        it("when value is not given, should return the value of _index from description",function(){
            descriptionUnderTest.index(0);
            var index = descriptionUnderTest.index();
            assert.equal(index, 0);
        });
    });

    describe("vri", function() {
        it("should add _vri to description",function(){
            descriptionUnderTest.vri([{anchor: 'testObject', horizontal: 'left'}]);
            assert.deepEqual(descriptionUnderTest._vri, [{anchor: 'testObject', horizontal: 'left'}]);
        });
        it("should initialize _vri when index is given using property bag",function(){
            descriptionUnderTest._defineByPropertyBag({
                vri: [{anchor: 'testObject', horizontal: 'left'}]
            });
            assert.deepEqual(descriptionUnderTest._vri, [{anchor: 'testObject', horizontal: 'left'}]);
        });
        it("should return this - builder pattern",function(){
            var result = descriptionUnderTest.vri([{anchor: 'testObject', horizontal: 'left'}]);
            assert.strictEqual(result, descriptionUnderTest);
        });
        it("should remove '_vri' from description, when value is null",function(){
            descriptionUnderTest._vri = [{anchor: 'testObject', horizontal: 'left'}];
            descriptionUnderTest.vri(null);
            assert.strictEqual(descriptionUnderTest._vri, undefined);
            var vri = descriptionUnderTest.vri();
            assert.strictEqual(vri, undefined);
            descriptionUnderTest.vri([{anchor: 'testObject', horizontal: 'right'}]);
            vri = descriptionUnderTest.vri();
            assert.deepEqual(vri, [{anchor: 'testObject', horizontal: 'right'}]);
        });
        it("should when value is not given, should return the value of _vri from description",function(){
            descriptionUnderTest.vri([{anchor: 'testObject', horizontal: 'right'}]);
            var vri = descriptionUnderTest.vri();
            assert.deepEqual(vri, [{anchor: 'testObject', horizontal: 'right'}]);
        });
    });

    describe("toJSON",function(){
        it("should create an object with key Properties with the properties that were stored",function(){
            descriptionUnderTest._properties = {key: 12};

            var js = descriptionUnderTest._toJSON();

            assert.deepEqual(js, {
                Properties: {
                    key:12
                },
                Index: undefined,
                VRI: undefined
            })
        });

        it("should create an object with key Properties with the index is correct", function () {
            descriptionUnderTest._properties = { key: 12 };
            descriptionUnderTest._handleIndexDescription = sinon.stub().returns({ location: 0});

            var js = descriptionUnderTest._toJSON();

            assert.deepEqual(js, {
                Properties: {
                    key: 12
                },
                Index: {
                    location: 0
                },
                VRI: undefined
            })
        });

        it("should create an object with key Properties with correct VRI", function () {
            var vriRelation = {
                TestObjectData:{},
                HorizontalRelation: 'horizontal',
                VerticalRelation: 'vertical' ,
                ProximityRelation: 'proximity'
            };

            descriptionUnderTest._properties = { key: 12 };
            descriptionUnderTest._handleVriDescription = sinon.stub().returns(vriRelation);

            var js = descriptionUnderTest._toJSON();

            assert.deepEqual(js, {
                Properties: {
                    key: 12
                },
                Index: undefined,
                VRI: vriRelation
            })
        });

        describe("Special Values",function(){
            var expectedJSON;
            beforeEach(function(){
                expectedJSON = {
                    Properties: null,
                    Index: undefined,
                    VRI: undefined
                };
            });

            describe("Regular Expressions",function(){
                beforeEach(function(){
                    expectedJSON.Properties = {
                        key: {
                            Type: "Regexp",
                            Regexp: "SomeRegEx"
                        }
                    };
                });
                it("should transform native regular expression to LeanFT regex JSON",function(){
                    descriptionUnderTest._properties.key = /SomeRegEx/;

                    var res = descriptionUnderTest._toJSON();

                    assert.deepEqual(res,expectedJSON);

                });

                it("should ignore regular expression options",function(){
                    descriptionUnderTest._properties.key = /SomeRegEx/ig;

                    var res = descriptionUnderTest._toJSON();

                    assert.deepEqual(res,expectedJSON);
                })
            });

            describe("grouped properties", function() {
                it("grouped property should be flatten", function() {
                    descriptionUnderTest._properties.key = {
                        _flat: function() {
                            return {
                                a: "a",
                                b: "b"
                            }
                        }
                    };

                    var res = descriptionUnderTest._toJSON();

                    assert.deepEqual(res, {
                        Properties: {
                            a: "a",
                            b: "b"
                        },
                        Index: undefined,
                        VRI: undefined
                    });
                });

                it("mix of grouped property and regular should be handled correctly", function() {
                    descriptionUnderTest._properties.key = "value";
                    descriptionUnderTest._properties.key2 = {
                        _flat: function () {
                            return {
                                a: "a",
                                b: "b"
                            }
                        }
                    };

                    var res = descriptionUnderTest._toJSON();

                    assert.deepEqual(res, {
                        Properties: {
                            a: "a",
                            b: "b",
                            key: "value"
                        },
                        Index: undefined,
                        VRI: undefined
                    });
                });

                it("should handle grouped property with regExp value correctly", function () {
                    descriptionUnderTest._properties.key = {
                        _flat: function() {
                            return {
                                a: /a/,
                                b: new RegExp("b")
                            }
                        }
                    };

                    var res = descriptionUnderTest._toJSON();

                    assert.deepEqual(res, {
                        Properties: {
                            a: {
                                Type: "Regexp",
                                Regexp: "a"
                            },
                            b: {
                                Type: "Regexp",
                                Regexp: "b"
                            }
                        },
                        Index: undefined,
                        VRI: undefined
                    });
                });
            });
        });
    });

    describe("_handleIndexDescription method", function () {

        it("should return null if index is null", function () {
            descriptionUnderTest.index(null);
            var result = descriptionUnderTest._handleIndexDescription();
            assert.strictEqual(result, null);
        });

        it("should return index if indextype is null", function () {
            descriptionUnderTest.index(0);
            var result = descriptionUnderTest._handleIndexDescription();
            assert.strictEqual(result, 0);
        });

        it("should return index if indextype is 'index'", function () {
            descriptionUnderTest.index(0);
            descriptionUnderTest._indexType = "Index";
            var result = descriptionUnderTest._handleIndexDescription();
            assert.strictEqual(result, 0);
        });

        it("should return object with correct value if indextype is other", function () {
            descriptionUnderTest.index(0);
            descriptionUnderTest._indexType = "location";
            var result = descriptionUnderTest._handleIndexDescription();
            assert.deepEqual(result, { location: 0 });
        });
    });

    describe("_handleVriDescription method", function (){
        var Vertical = require("../lib/visual_relation.js").Vertical;
        var Horizontal = require("../lib/visual_relation.js").Horizontal;
        var Proximity = require("../lib/visual_relation.js").Proximity;

        it("should return null result if vri object is null",function(){
            descriptionUnderTest.vri(null);
            var vri = descriptionUnderTest._handleVriDescription();
            assert.deepEqual(vri, descriptionUnderTest._vri);
        });

        it("should return undefined result if vri object is undefined",function(){
            descriptionUnderTest.vri(undefined);
            var vri = descriptionUnderTest._handleVriDescription();
            assert.deepEqual(vri, descriptionUnderTest._vri);
        });

        it("should generate vri relations array when vri is not array",function(){
            var testObject = {_toJSON:sinon.stub()};
            descriptionUnderTest.vri({anchor: testObject, horizontal: 'left'});
            var vriArray = descriptionUnderTest._handleVriDescription();
            assert(vriArray.length == 1);
            assert.deepEqual(vriArray[0], {
                "HorizontalRelation": 1,
                "ProximityRelation": undefined,
                "TestObjectData": undefined,
                "VerticalRelation": undefined
            });
        });

        it("should not change the vri relations array if vri is array with one item",function(){
            var testObject = {_toJSON:sinon.stub()};
            descriptionUnderTest.vri([{anchor: testObject, horizontal: 'left'}]);
            var vriArray = descriptionUnderTest._handleVriDescription();
            assert(vriArray.length == 1);
            assert.deepEqual(vriArray[0], {
                "HorizontalRelation": 1,
                "ProximityRelation": undefined,
                "TestObjectData": undefined,
                "VerticalRelation": undefined
            });
        });

        it("should not change the vri relations array if vri is array with two items",function(){
            var testObject = {_toJSON:sinon.stub().returns({a:'kuku0'})};
            var testObject2 = {_toJSON:sinon.stub().returns({b:'kuku1'})};
            descriptionUnderTest.vri([{anchor: testObject, horizontal: 'left'},{anchor: testObject2, horizontal: 'right'}]);
            var vriArray = descriptionUnderTest._handleVriDescription();
            assert(vriArray.length == 2);
            assert.deepEqual(vriArray[0], {
                "HorizontalRelation": 1,
                "ProximityRelation": undefined,
                "TestObjectData": {a:'kuku0'},
                "VerticalRelation": undefined
            });
            assert.deepEqual(vriArray[1], {
                "HorizontalRelation": 3,
                "ProximityRelation": undefined,
                "TestObjectData": {b:'kuku1'},
                "VerticalRelation": undefined
            });
        });

        it("should call to _validateRelation on each vri relation",function(){
            var testObject = {_toJSON:sinon.stub().returns("TestObject1")};
            descriptionUnderTest._validateRelation = sinon.stub();
            descriptionUnderTest.vri([{anchor: testObject, horizontal: 'left'},{anchor: testObject, horizontal: 'right'}]);
            descriptionUnderTest._handleVriDescription();
            sinon.assert.callCount(descriptionUnderTest._validateRelation, 2);
            assert.deepEqual(descriptionUnderTest._validateRelation.firstCall.args[0], {anchor: testObject, horizontal: 'left'});
            assert.deepEqual(descriptionUnderTest._validateRelation.secondCall.args[0], {anchor: testObject, horizontal: 'right'});
        });

        it("should call to anchor._toJSON on each vri relation",function(){
            var testObject = {_toJSON:sinon.stub().returns("TestObject22")};
            descriptionUnderTest._validateRelation = sinon.stub();
            descriptionUnderTest.vri([{anchor: testObject, horizontal: 'left'},{anchor: testObject, horizontal: 'right'}]);
            descriptionUnderTest._handleVriDescription();
            sinon.assert.callCount(testObject._toJSON, 2);
        });

        it("should generate vri relation array with VRI data",function(){
            var testObject = {_toJSON:sinon.stub().returns("TestObject3")};
            descriptionUnderTest.vri({anchor: testObject, horizontal: 'left',vertical: 'above', proximity:'contains'});
            var vriArray = descriptionUnderTest._handleVriDescription();
            assert(vriArray.length == 1);
            assert.deepEqual(vriArray[0], {
                "HorizontalRelation": 1,
                "ProximityRelation": 4,
                "TestObjectData": "TestObject3",
                "VerticalRelation": 1
            });
        });

        it("should generate vri relations array with VRI data",function(){
            var testObject = {_toJSON:sinon.stub().returns("TestObject")};
            descriptionUnderTest.vri([{anchor: testObject, horizontal: 'left',vertical: 'above', proximity:'contains'},
                {anchor: testObject, horizontal: 'right',vertical: 'below', proximity:'closestOnXAxis'}]);
            var vriArray = descriptionUnderTest._handleVriDescription();
            assert.strictEqual(vriArray.length, 2);
            assert.deepEqual(vriArray[0], {
                "HorizontalRelation": 1,
                "ProximityRelation": 4,
                "TestObjectData": "TestObject",
                "VerticalRelation": 1
            });
            assert.deepEqual(vriArray[1], {
                "HorizontalRelation": 3,
                "ProximityRelation": 1,
                "TestObjectData": "TestObject",
                "VerticalRelation": 3
            });
        });
    });

    describe("_propertyHandler method", function (){

        it("should return property value for property with capital letters",function(){
            descriptionUnderTest._insertValue('innertext','myText');
            var propValue = descriptionUnderTest._propertyHandler('innerTeXT');
            assert.deepEqual(propValue, 'myText');
        });

        it("should return property value for property with lower case only",function(){
            descriptionUnderTest._insertValue('innertext','myText');
            var propValue = descriptionUnderTest._propertyHandler('innertext');
            assert.deepEqual(propValue, 'myText');
        });

        it("should not return property value for property with capital letters",function(){
            var propValue = descriptionUnderTest._propertyHandler('innerTeXT');
            assert.deepEqual(propValue, null);
        });

        it("should not return property value for property with lower case only",function(){
            var propValue = descriptionUnderTest._propertyHandler('innertext');
            assert.deepEqual(propValue, null);
        });
    });
});