// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

var proxyquire = require("proxyquire");

var sinon = require("sinon");
var assert = require("assert");


describe("WSCommunicationChannel unit tests",function(){
    var WSCommunicationChannelUnderTest;
    var channelMock;

    function getCallbackFromChannel(channelMock,callbackType) {
        return channelMock.on.withArgs(callbackType).firstCall.args[1];
    }

    beforeEach(function(){
        socketMock = {
            send: sinon.stub(),
            on: sinon.stub()
        };
        var wsConstructor = sinon.stub().returns(socketMock); 
        var ChannelExports = proxyquire("../lib/websocket_communication_channel", {
            'ws': wsConstructor
        });
        var WSCommunicationChannel = ChannelExports.WSCommunicationChannel;

        wsConstructor.returns(socketMock);
        WSCommunicationChannelUnderTest = new WSCommunicationChannel("address");
        WSCommunicationChannelUnderTest.connect();
    });

    afterEach(function() {
    });

    describe("connect",function(){

        it("should listen to socket on 'message'",function(){
            sinon.assert.calledWith(socketMock.on,"message",sinon.match.func);
        });

        it("should listen to socket on 'error'",function(){
            sinon.assert.calledWith(socketMock.on,"error",sinon.match.func);
        });

        it("should listen to socket on 'close'",function(){
            sinon.assert.calledWith(socketMock.on,"close",sinon.match.func);
        });

        it("should listen to socket on 'open'",function(){
            sinon.assert.calledWith(socketMock.on,"open",sinon.match.func);
        });
    });

    describe("on open callback",function () {
        var onOpenCallbackFromSocket;

        beforeEach(function() {
            onOpenCallbackFromSocket = getCallbackFromChannel(socketMock,"open");
        });

        it("should call onConnect when called",function(){
            WSCommunicationChannelUnderTest.onConnect = sinon.mock();
            onOpenCallbackFromSocket();
            sinon.assert.calledWith(WSCommunicationChannelUnderTest.onConnect);
        });

        it("should not throw if no function registered on onConnect", function () {
            assert.doesNotThrow(function () {
                onOpenCallbackFromSocket();
            });
        });
    });

    describe("send", function() {
        var resultCB;
        var onMessageCalback;

        beforeEach(function(){
            resultCB = sinon.mock();
            onMessageCalback = getCallbackFromChannel(socketMock,"message");
        });

        afterEach(function(){
        });

        it("should send a wrapped message with type set as request",function(){
            var requestID = 1;
            WSCommunicationChannelUnderTest.send("SomeMessage",requestID, resultCB);
            var msg = {
                uid: requestID,
                type: "request",
                data: {
                    format:"LeanFT",
                    version:"1",
                    agentType:"leanFTClient",
                    data:"SomeMessage"
                }
            };

            sinon.assert.calledOnce(socketMock.send);
            sinon.assert.calledWith(socketMock.send,JSON.stringify(msg));
        });

        it("should call result callback when on message is called with response for requestId",function(){
            //WSCommunicationChannelUnderTest.send("SomeMessage", resultCB);
            var requestID = 1;

            WSCommunicationChannelUnderTest._pendingRequests[requestID] = resultCB;
            var responseMsg = {
                uid: requestID,
                type: "response",
                data: {
                    data:"SomeResult"
                }
            };

            onMessageCalback(JSON.stringify(responseMsg));

            sinon.assert.calledOnce(resultCB);
            sinon.assert.calledWith(resultCB,responseMsg.data.data);
        });

        it("should call result callback when on message is called with response for uid",function(){
            var requestID = 1;
            WSCommunicationChannelUnderTest._pendingRequests[requestID] = resultCB;
            var responseMsg = {
                uid: requestID,
                type: "response",
                data: {
                    data:"SomeResult"
                }
            };

            onMessageCalback(JSON.stringify(responseMsg));

            sinon.assert.calledOnce(resultCB);
            sinon.assert.calledWith(resultCB,responseMsg.data.data);
        });
    });

    describe("_onClose", function () {
        it("should clear response callbacks", function () {
            WSCommunicationChannelUnderTest._pendingRequests = [sinon.stub(), sinon.stub()];
            WSCommunicationChannelUnderTest._onClose();

            assert.deepEqual(WSCommunicationChannelUnderTest._pendingRequests, []);
        });

        it("should invoke each pending request callback with the disconnected from server error", function () {
            var request1 = sinon.stub();
            var request2 = sinon.stub();

            WSCommunicationChannelUnderTest._pendingRequests = [request1, request2];
            WSCommunicationChannelUnderTest._onClose();

            var disconnectedError = {
                status: -50,
                data: {
                    ErrorMessage: "disconnected from server"
                }
            };

            sinon.assert.calledOnce(request1);
            sinon.assert.calledWith(request1, disconnectedError);
            sinon.assert.calledOnce(request2);
            sinon.assert.calledWith(request2, disconnectedError);
        });

        it("should invoke each pending request even if one of them throws", function () {
            var request1 = sinon.stub().throws(new Error("some error"));
            var request2 = sinon.stub();

            WSCommunicationChannelUnderTest._pendingRequests = [request1, request2];
            WSCommunicationChannelUnderTest._onClose();

            var disconnectedError = {
                status: -50,
                data: {
                    ErrorMessage: "disconnected from server"
                }
            };

            sinon.assert.calledOnce(request1);
            sinon.assert.calledWith(request1, disconnectedError);
            sinon.assert.calledOnce(request2);
            sinon.assert.calledWith(request2, disconnectedError);
        });
    });
});
