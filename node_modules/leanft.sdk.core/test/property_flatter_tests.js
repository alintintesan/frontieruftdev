// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 19/11/2015.
 */

var assert = require("assert");
var PropertyFlatter = require("../lib/property_flatter.js").PropertyFlatter;
var PropertyKeyPrefixFlatter = require("../lib/property_flatter.js").PropertyKeyPrefixFlatter;

describe("PropertyFlatter unit tests",function(){
    describe("construction", function() {
        it("should save keysMap as is", function() {
            var keysMap = {
                key1: "nativeKey1",
                key2: "nativeKey2"
            };

            var propertyFlatterUnderTest = new PropertyFlatter(null,keysMap);

            assert.deepEqual(propertyFlatterUnderTest._keysMap, keysMap);
        });

        it("all keys from value should be added to the property flatter", function() {
            var valueMap = {
                key1: "val1",
                key2: "val2"
            };

            var propertyFlatterUnderTest = new PropertyFlatter(valueMap, {});

            assert("key1" in propertyFlatterUnderTest);
            assert.strictEqual(propertyFlatterUnderTest.key1,  "val1");
            assert("key2" in propertyFlatterUnderTest);
            assert.strictEqual(propertyFlatterUnderTest.key2, "val2");
        });

        it("should throw if keys map is null", function() {
            assert.throws(function(){
                new PropertyFlatter({}, null)
            });
        });

        it("should throw if keys map is undefined", function() {
            assert.throws(function(){
                new PropertyFlatter({})
            });
        });
    });

    describe("_flat", function() {
       it("empty keys map, value should be ignored and empty map returned", function() {
           var valueMap = {
               key1: "val1",
               key2: "val2"
           };

           var propertyFlatterUnderTest = new PropertyFlatter(valueMap, {});

           var res = propertyFlatterUnderTest._flat();

           assert.deepEqual(res, {});
       });

        it("null value map, should return empty map", function() {
            var keysMap = {
                key1: "val1",
                key2: "val2"
            };

            var propertyFlatterUnderTest = new PropertyFlatter(null, keysMap);

            var res = propertyFlatterUnderTest._flat();

            assert.deepEqual(res, {});
        });

        it("values and keys given, should take keys from the key map and values from the value map", function() {
            var valueMap = {
                usrKey1: "val1",
                usrKey2: "val2"
            };

            var keysMap = {
                usrKey1: "nativeKey1",
                usrKey2: "nativeKey2"
            };

            var expected = {
                nativeKey1: "val1",
                nativeKey2: "val2"
            };

            var res = new PropertyFlatter(valueMap, keysMap)._flat();

            assert.deepEqual(res, expected);
        });

        it("value and keys given, should ignore values if its key is not in the keys map", function() {
            var valueMap = {
                usrKey1: "val1",
                usrKey2: "val2",
                extraKey: "extraValue"
            };

            var keysMap = {
                usrKey1: "nativeKey1",
                usrKey2: "nativeKey2"
            };

            var expected = {
                nativeKey1: "val1",
                nativeKey2: "val2"
            };

            var res = new PropertyFlatter(valueMap, keysMap)._flat();

            assert.deepEqual(res, expected);
        });

        it("modify values after construction, should take keys from the key map and the updated values", function() {
            var valueMap = {
                usrKey1: "val1",
                usrKey2: "val2"
            };

            var keysMap = {
                usrKey1: "nativeKey1",
                usrKey2: "nativeKey2"
            };

            var expected = {
                nativeKey1: "val1 - updated",
                nativeKey2: "val2"
            };


            var propertyFlatterUnderTest = new PropertyFlatter(valueMap, keysMap);
            propertyFlatterUnderTest.usrKey1 = "val1 - updated";
            var res = propertyFlatterUnderTest._flat();


            assert.deepEqual(res, expected);
        });

        it("add key after construction, should take keys from the key map and the updated values", function() {
            var valueMap = {
                usrKey2: "val2"
            };

            var keysMap = {
                usrKey1: "nativeKey1",
                usrKey2: "nativeKey2"
            };

            var expected = {
                nativeKey1: "val1 - updated",
                nativeKey2: "val2"
            };


            var propertyFlatterUnderTest = new PropertyFlatter(valueMap, keysMap);
            propertyFlatterUnderTest.usrKey1 = "val1 - updated";
            var res = propertyFlatterUnderTest._flat();


            assert.deepEqual(res, expected);
        });
    });
});

describe("PropertyKeyPrefixFlatter unit tests", function() {
    describe("construction", function() {
        it("all keys from value should be added to the property flatter", function() {
            var valueMap = {
                key1: "val1",
                key2: "val2"
            };

            var propertyFlatterUnderTest = new PropertyKeyPrefixFlatter(valueMap, "somePrefix");

            assert("key1" in propertyFlatterUnderTest);
            assert.strictEqual(propertyFlatterUnderTest.key1, "val1");
            assert("key2" in propertyFlatterUnderTest);
            assert.strictEqual(propertyFlatterUnderTest.key2, "val2");
        });

        it("should throw if keyprefix is null", function() {
            assert.throws(function() {
                new PropertyKeyPrefixFlatter({}, null);
            });
        });

        it("should throw if keyprefix is undefined", function() {
            assert.throws(function() {
                new PropertyKeyPrefixFlatter({});
            });
        });

        it("should throw if keyprefix is whitespace", function() {
            assert.throws(function() {
                new PropertyKeyPrefixFlatter({}, "      ");
            });
        });
    });

    describe("_flat unit tests", function() {
        it("should add prefix to all keys", function() {
            var valueMap = {
                key1: "val1",
                key2: "val2"
            };

            var res = new PropertyKeyPrefixFlatter(valueMap, "prefix")._flat();

            assert.deepEqual(res, {
                prefixkey1: "val1",
                prefixkey2: "val2"
            });
        });

        it("update value after construction, should add prefix to all keys and take updated value", function() {
            var valueMap = {
                key1: "val1",
                key2: "val2"
            };

            var propertyFlatterUnderTest = new PropertyKeyPrefixFlatter(valueMap, "prefix");
            propertyFlatterUnderTest.key1 = "val1 - updated";
            var res = propertyFlatterUnderTest._flat();

            assert.deepEqual(res, {
                prefixkey1: "val1 - updated",
                prefixkey2: "val2"
            });
        });

        it("add key and value after construction, should add prefix to all keys including the added one", function() {
            var valueMap = {
                key1: "val1"
            };

            var propertyFlatterUnderTest = new PropertyKeyPrefixFlatter(valueMap, "prefix");
            propertyFlatterUnderTest.key2 = "val2";
            var res = propertyFlatterUnderTest._flat();

            assert.deepEqual(res, {
                prefixkey1: "val1",
                prefixkey2: "val2"
            });
        });
    });
});
