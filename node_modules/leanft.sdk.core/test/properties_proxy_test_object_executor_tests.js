// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 14/09/2016.
 */
var assert = require("assert");
var sinon = require("sinon");
var PropertiesProxyTestObjectExecutor = require("../lib/properties_proxy_test_object_executor.js").PropertiesProxyTestObjectExecutor;
var RuntimeAccessMode = require("../lib/properties_proxy_test_object_executor.js").RuntimeAccessMode;


describe("PropertiesProxyTestObjectExecutor tests",function() {
    var executorUndertest;
    var wrappedExecutor;
    var sandbox;

    beforeEach(function(){
        sandbox = sinon.sandbox.create();

        wrappedExecutor = {_session:{_promiseManager:{}},_testObject:{},executeCommand:function(){}};
        wrappedExecutor._session._promiseManager.syncedBranchThen = sinon.stub();

        executorUndertest = new PropertiesProxyTestObjectExecutor(wrappedExecutor,{},RuntimeAccessMode.accessOnUnknownOperationOrProperty);
        sandbox.stub(executorUndertest._executorToWrap, "executeCommand");
    });

    afterEach(function(){
        sandbox.restore();
        delete wrappedExecutor._session._promiseManager.syncedBranchThen;
    });

    describe("constructor",function() {
        it("should keep properties from given properties", function(){
            executorUndertest = new PropertiesProxyTestObjectExecutor(wrappedExecutor,{"key": "value"},RuntimeAccessMode.accessOnUnknownOperationOrProperty);
            assert.deepEqual(executorUndertest._properties,{"key": "value"});
        });

        it("should keep properties keys in lower case from given properties", function(){
            executorUndertest = new PropertiesProxyTestObjectExecutor(wrappedExecutor,{"KEY": "value"},RuntimeAccessMode.accessOnUnknownOperationOrProperty);

            assert.deepEqual(executorUndertest._properties,{"key": "value"});
        });
    });    

    describe("executeCommand",function() {
        beforeEach(function(){
            sandbox.stub(executorUndertest._supportedFuncs.GetROProperty, "verify");
            sandbox.stub(executorUndertest._supportedFuncs.GetROProperty, "handle");
            sandbox.stub(executorUndertest._supportedFuncs.GetROProperties, "verify");
            sandbox.stub(executorUndertest._supportedFuncs.GetROProperties, "handle");
        });

        // describe("usage of executeDefault",function() {
        it("should use the default value handler once if method don't have it's handler and the result is not null", function() {
            executorUndertest._executeDefault = sinon.stub();
            executorUndertest.executeCommand("Click");
            sinon.assert.calledOnce(executorUndertest._executeDefault);
        });

        it("should use the default value handler once if verification method result is false", function() {
            executorUndertest._executeDefault = sinon.stub();
            executorUndertest._supportedFuncs.GetROProperty.verify.returns(false);
            executorUndertest.executeCommand("GetROProperty");
            sinon.assert.calledOnce(executorUndertest._supportedFuncs.GetROProperty.verify);
            sinon.assert.calledOnce(executorUndertest._executeDefault);
        });

        it("should use the handle method if verification method result is true", function() {
            executorUndertest._supportedFuncs.GetROProperty.verify.returns(true);
            executorUndertest.executeCommand("GetROProperty");
            sinon.assert.calledOnce(executorUndertest._supportedFuncs.GetROProperty.verify);
            sinon.assert.calledOnce(executorUndertest._supportedFuncs.GetROProperty.handle);
        });

        it("should call the handler with correct method name and simple arg", function() {
            executorUndertest._supportedFuncs.GetROProperty.verify.returns(true);
            executorUndertest.executeCommand("GetROProperty",'text');
            assert.deepEqual(executorUndertest._supportedFuncs.GetROProperty.verify.args[0], ['text']);
            assert.deepEqual(executorUndertest._supportedFuncs.GetROProperty.handle.args[0], ['text']);
        });

        it("should call the handler with correct method name and array arg", function() {
            executorUndertest._supportedFuncs.GetROProperties.verify.returns(true);
            executorUndertest.executeCommand("GetROProperties",['height','width']);
            assert.deepEqual(executorUndertest._supportedFuncs.GetROProperties.verify.args[0], [['height','width']]);
            assert.deepEqual(executorUndertest._supportedFuncs.GetROProperties.handle.args[0], [['height','width']]);
        });
    });

    describe("_supportedFuncs",function() {
        describe("GetROProperty",function() {
            describe("verify",function() {
                it("should return false if key doesn't exist", function() {
                    executorUndertest._properties = {someKey:'someValue'};
                    var result = executorUndertest._supportedFuncs.GetROProperty.verify.call(executorUndertest, 'key');
                    assert.deepEqual(result,false);
                });

                it("should return true if key exist", function() {
                    executorUndertest._properties = {key:'value'};
                    var result = executorUndertest._supportedFuncs.GetROProperty.verify.call(executorUndertest, 'key');
                    assert.deepEqual(result,true);
                });

                it("should return true if key exist ignoring case", function() {
                    executorUndertest._properties = {key:'value'};
                    var result = executorUndertest._supportedFuncs.GetROProperty.verify.call(executorUndertest, 'KEY');
                    assert.deepEqual(result,true);
                });
            });
            describe("handle",function() {
                it("should return property value", function() {
                    executorUndertest._properties = {key:'value'};
                    var result = executorUndertest._supportedFuncs.GetROProperty.handle.call(executorUndertest, 'key');
                    assert.deepEqual(result,'value');
                });
                it("should return property value ignoring case", function() {
                    executorUndertest._properties = {key:'value'};
                    var result = executorUndertest._supportedFuncs.GetROProperty.handle.call(executorUndertest, 'KEY');
                    assert.deepEqual(result,'value');
                });
            });
        });

        describe("GetROProperties",function() {
            describe("verify",function() {
                it("should return true if args are empty", function() {
                    executorUndertest._properties = {};
                    var result = executorUndertest._supportedFuncs.GetROProperties.verify.call(executorUndertest, []);
                    assert.deepEqual(result,true);
                });

                it("should return true value if value is cached", function() {
                    executorUndertest._properties = {height:'1', width:'2'};
                    var result = executorUndertest._supportedFuncs.GetROProperties.verify.call(executorUndertest, ['height']);
                    assert.deepEqual(result,true);
                });

                it("should return false value if not all properties are cached", function() {
                    executorUndertest._properties = { width:'2'};
                    var result = executorUndertest._supportedFuncs.GetROProperties.verify.call(executorUndertest, ['height']);
                    assert.deepEqual(result,false);
                });
            });

            describe("verify",function() {
                it("should return cached values", function() {
                    executorUndertest._properties = {height:'1', width:'2'};
                    var result = executorUndertest._supportedFuncs.GetROProperties.handle.call(executorUndertest, ['height','width']);
                    assert.deepEqual(result,['1','2']);
                });
            });
        });

        describe("_executeDefault",function() {
            it("should not execute wrapped executor if runtime access mode is noProxy", function() {
                wrappedExecutor._session._promiseManager.syncedBranchThen = sinon.stub().returns({then:'value', id:2});
                executorUndertest._runTimeAccessMode = '0';
                var result = executorUndertest._executeDefault.call(executorUndertest, "s");
                assert.deepEqual(result,{
                    "id": 2,
                    "then": "value"
                });
            });

            it("should not execute wrapped executor if runtime access mode is neverAccess", function() {
                wrappedExecutor._session._promiseManager.syncedBranchThen = sinon.stub().returns({then:'value', id:2});
                executorUndertest._runTimeAccessMode = '2';
                var result = executorUndertest._executeDefault.call(executorUndertest, "s");
                assert.deepEqual(result,{
                    "id": 2,
                    "then": "value"
                });
            });

            it("should  execute wrapped executor if runtime access mode is accessOnUnknownOperationOrProperty", function() {
                executorUndertest._runTimeAccessMode = 'accessOnUnknownOperationOrProperty';
                executorUndertest._executorToWrap.executeCommand = sinon.stub();
                var result = executorUndertest._executeDefault.call(executorUndertest,arguments);
                sinon.assert.calledOnce(executorUndertest._executorToWrap.executeCommand);
                assert.deepEqual(executorUndertest._executorToWrap.executeCommand.args, [[]]);
            });
        });
    });
});
