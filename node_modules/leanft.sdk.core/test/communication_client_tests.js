// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 30/11/2015.
 */

var CommunicationClient = require("../lib/communication_client.js").CommunicationClient;
var assert = require("assert");
var sinon = require("sinon");
var Q = require("q");
var PromiseManager = require("../lib/promise_wrapper.js").PromiseManager;

describe("CommunicationClient unit tests", function() {
    var communicationClientUnderTest;
    var promiseManager = new PromiseManager();
    beforeEach(function() {
        promiseManager._reset();
        communicationClientUnderTest = new CommunicationClient({address: undefined}, promiseManager);
    });

    describe("Construction",function(){
        it("should connect to message event on the web socket channel",function(){
            assert.notStrictEqual(communicationClientUnderTest._wsChannel.onMessage,null);
        });

        it("should connect to disconnect event on the web socket channel",function(){
            assert.notStrictEqual(communicationClientUnderTest._wsChannel.onDisconnect,null);
        });

        it("should construct a web socket channel with the given address",function(){
            communicationClientUnderTest = new CommunicationClient({address: "address"});
            assert.notEqual(communicationClientUnderTest._wsChannel, null);
            assert.strictEqual(communicationClientUnderTest._wsChannel._address,"address");
        });

        it("should construct a web socket channel with the given http upgrade headers",function(){
            communicationClientUnderTest = new CommunicationClient("address", undefined, {httpUpgradeHeaders: {headerKey:"headerValue"}});
            assert.deepEqual(communicationClientUnderTest._wsChannel._httpUpgradeHeaders,{headerKey:"headerValue"});
        });

        it("should set sessionID to empty guid",function(){
            var EMPTY_SESSION_ID = "00000000-0000-0000-0000-000000000000"; //Needs to be initialized with empty GUID.
            assert.strictEqual(communicationClientUnderTest._sessionID,EMPTY_SESSION_ID);
        });

        it("should set the _sessionMode member to 0 if no value passed in config", function () {
            assert.strictEqual(communicationClientUnderTest._sessionMode, 0);
        });

        [["replay", 0], ["interactive",1]].forEach(function (input) {
            var sdkMode = input[0];
            var expectedMode = input[1];
            it("should set the _sessionMode to " + expectedMode + " if the mode in the passed config is " + sdkMode, function () {
                var clientUnderTest = new CommunicationClient({address: undefined, mode: sdkMode}, promiseManager);
                assert.strictEqual(clientUnderTest._sessionMode, expectedMode);
            });
        });
    });

    describe("connect",function(){
        var channelMock;
        beforeEach(function(){
            channelMock = {
                connect: sinon.stub(),
                send: function () {}
            };

            sinon.stub(channelMock, "send", function(msg, handler) {
                handler({
                    status:0,
                    data: {
                        NewSessionId: "result session id"
                    }
                });
            });

            communicationClientUnderTest._wsChannel = channelMock;
            // sinon.stub(communicationClientUnderTest,"send");
            // communicationClientUnderTest.send.returns({
            //     NewSessionId: "result session id"
            // });
        });

        it("should connect to the channel",function(){
            communicationClientUnderTest._sessionMode = "someMode";
            var promise = communicationClientUnderTest.connect().then(function(){
                assert(channelMock.connect.calledOnce);
            });

            //triggering the connect method.
            setTimeout(function () {
                channelMock.onConnect();
            }, 0);

            return promise;
        });

        it("should send the new session message with mode value set to _sessionMode after it was connected",function(){
            communicationClientUnderTest._sessionMode = "someMode";
            var promise = communicationClientUnderTest.connect().then(function(){
                sinon.assert.calledOnce(channelMock.send);
                sinon.assert.calledWith(channelMock.send, {
                    data: { SessionMode: "someMode", perSessionSettings: null, sdk: "JavaScript" },
                    sessionId: "00000000-0000-0000-0000-000000000000",
                    type: "NEW_SESSION"
                });
            });

            //triggering the connect method.
            setTimeout(function () {
                channelMock.onConnect();
            }, 0);

            return promise;
        });

        it("should set the response session id",function(){
            communicationClientUnderTest.connect().then(function(){
                assert.strictEqual(communicationClientUnderTest._sessionID,"result session id");
            });
            //triggering the connect method.
            setTimeout(function () {
                channelMock.onConnect();
            }, 0);
        });
    });

    describe("send method", function() {
        var callOrder;

        beforeEach(function() {
            callOrder = [];
            sinon.stub(communicationClientUnderTest,"_send",function(msgType,data){
                callOrder.push(msgType+" start");
                var timeout = data.timeout || 0;

                var deferred = Q.defer();

                setTimeout(function(){
                    callOrder.push(msgType+" end");
                    deferred.resolve(null);
                }, timeout);


                return deferred.promise;
            });

            promiseManager._reset();
        });

        it("should call all send commands in a sequential order", function() {
            communicationClientUnderTest.send("someType", {timeout: 10});
            return communicationClientUnderTest.send("someType1", {timeout: 1}).then(function() {
                assert.deepEqual(callOrder, ["someType start", "someType end", "someType1 start", "someType1 end"]);
            });
        });

        it("should call then methods in BFS order", function() {
            communicationClientUnderTest.send("someType", {timeout: 10}).then(function() {
                callOrder.push("my func1");
            });

            return communicationClientUnderTest.send("someType1", {timeout: 1}).then(function() {
                callOrder.push("my func2");
            }).then(function() {
                assert.deepEqual(callOrder, ["someType start",
                    "someType end",
                    "my func1",
                    "someType1 start",
                    "someType1 end",
                    "my func2"]);
            });
        });

        describe("handle response",function(){
            beforeEach(function(){
                communicationClientUnderTest._send.restore();
            });

            it("should reject the promise in case the result that is provided is null",function(){
                sinon.stub(communicationClientUnderTest._wsChannel,"send",function(msg,responseCallback) {
                    responseCallback(null);
                });

                return communicationClientUnderTest.send(null,null).then(function(){
                    assert(false,"We shouldn't be here");
                },function(e){
                    assert.notEqual(e,null);
                });
            });

            it("should resolve the promise with the result data",function(){
                sinon.stub(communicationClientUnderTest._wsChannel,"send",function(msg,responseCallback) {
                    responseCallback({
                        data: 42,
                        status: 0
                    });
                });

                return communicationClientUnderTest.send(null,null).then(function(res){
                    assert.strictEqual(res,42);
                },function(e){
                    assert(false, "We shouldn't be here!!!: " + e);
                });
            });

            it("should throw an error in case the status field is missing",function(){
                sinon.stub(communicationClientUnderTest._wsChannel,"send",function(msg,responseCallback) {
                    responseCallback({
                        data: 42
                    });
                });

                return communicationClientUnderTest.send(null,null).then(function(){
                    assert(false, "We shouldn't be here!!!: " + e);
                },function(){
                    assert(true,"Got called");
                });
            });

            it("should use the type of the exception in case it is general error code",function(){
                sinon.stub(communicationClientUnderTest._wsChannel,"send",function(msg,responseCallback) {
                    responseCallback({
                        status: -101,
                        data: {

                        }
                    });
                });

                return communicationClientUnderTest.send(null,null).then(function(){
                    assert(false, "We shouldn't be here!!!: ");
                },function(e){
                    assert.strictEqual(e.message,"ServerIsShuttingDownException:"+" with code " + -101);
                });
            });

            it("should add the error message from the runtime in case it is present",function(){
                sinon.stub(communicationClientUnderTest._wsChannel,"send",function(msg,responseCallback) {
                    responseCallback({
                        status: -101,
                        data: {
                            ErrorMessage: "SomeMessage"
                        }
                    });
                });

                return communicationClientUnderTest.send(null,null).then(function(){
                    assert(false, "We shouldn't be here!!!: ");
                },function(e){
                    assert.strictEqual(e.message,"ServerIsShuttingDownException: SomeMessage");
                });
            });

            it("should use general run error exception type in case the error code is unknown",function(){
                sinon.stub(communicationClientUnderTest._wsChannel,"send",function(msg,responseCallback) {
                    responseCallback({
                        status: 42,
                        data: {
                            ErrorMessage: "SomeMessage"
                        }
                    });
                });

                return communicationClientUnderTest.send(null,null).then(function(){
                    assert(false, "We shouldn't be here!!!: ");
                },function(e){
                    assert.strictEqual(e.message,"GeneralLeanFtException: SomeMessage");
                });
            });

            it("should add the error code in case error message is not present in the result",function(){
                sinon.stub(communicationClientUnderTest._wsChannel,"send",function(msg,responseCallback) {
                    responseCallback({
                        status: 42,
                        data: {
                        }
                    });
                });

                return communicationClientUnderTest.send(null,null).then(function(){
                    assert(false, "We shouldn't be here!!!: ");
                },function(e){
                    assert.strictEqual(e.message,"GeneralLeanFtException:"+" with code " + 42);
                });
            });
        });
    });
});
