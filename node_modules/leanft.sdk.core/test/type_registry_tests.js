// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

var assert = require("assert");
var sinon = require("sinon");

var TypeRegistry = require("../lib/type_registry.js").TypeRegistry;

describe("TypeRegistry",function() {
    var typeRegistryUnderTest = TypeRegistry;
    var testObject = null;

    describe("getPropertiesNames",function() {
        beforeEach(function(){
            testObject = {property1:{}, property2:{} ,property3:{}, property4:{}};
        });

        it("should return correct propertyNames", function () {
            var behavior1 = {_properties: {property1:{}, property2:{}}};
            var behavior2 = {_properties: {property3:{}, property4:{}}};
            testObject._behaviors = [behavior1,behavior2];
            var propertyNames = typeRegistryUnderTest.getPropertiesNames(testObject);
            assert.deepEqual(propertyNames,["property1", "property2","property3","property4"]);
        });

        it("should return uniques propertyNames", function () {
            var behavior1 = {_properties: {property1:{}, property2:{}}};
            var behavior2 = {_properties: {property2:{}, property3:{}}};
            testObject._behaviors = [behavior1,behavior2];
            var propertyNames = typeRegistryUnderTest.getPropertiesNames(testObject);
            assert.deepEqual(propertyNames,["property1", "property2","property3"]);
        });

        it("should return correct propertyNames only from first behavior", function () {
            var behavior1 = {_properties: {property1:{}, property2:{}}};
            var behavior2 = {_methods:{method1:sinon.stub(), method2:sinon.stub()}};
            testObject._behaviors = [behavior1,behavior2];
            var propertyNames = typeRegistryUnderTest.getPropertiesNames(testObject);
            assert.deepEqual(propertyNames,["property1", "property2"]);
        });

        it("should remove properties that were deleted from the testObject", function () {
            var behavior1 = {_properties: {property1:{}, property2:{}}};
            var behavior2 = {_methods:{method1:sinon.stub(), method2:sinon.stub()}};
            testObject._behaviors = [behavior1,behavior2];
            delete testObject.property1;
            var propertyNames = typeRegistryUnderTest.getPropertiesNames(testObject);
            assert.deepEqual(propertyNames,["property2"]);
        });

        it("should return null if object doesn't have behaviors", function () {
            testObject = {a:1,b:2};
            var propertyNames = typeRegistryUnderTest.getPropertiesNames(testObject);
            assert.equal(propertyNames,null);
        });
    });

    describe("addPropertyWithEnum",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedEnums = {};
        });

        it("should not add new enum property if test object is null", function () {
            typeRegistryUnderTest.addPropertyWithEnum(null,'kuku',{});
            assert.deepEqual(typeRegistryUnderTest._supportedEnums,{});
        });

        it("should not add new enum property if test object don't have valid description object", function () {
            typeRegistryUnderTest.addPropertyWithEnum({},'kuku',{});
            assert.deepEqual(typeRegistryUnderTest._supportedEnums,{});
        });

        it("should add new enum property", function () {
            typeRegistryUnderTest.addPropertyWithEnum({_description:{leanFTType:{technology:'tech',leanftType:'type'}}},'kuku',{myEnum:{}});
            assert.deepEqual(typeRegistryUnderTest._supportedEnums['tech']['type']['kuku'] ,{myEnum:{}});
        });
    });

    describe("addPropertyWithUint",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedUints = {};
        });

        it("should not add new uint property if test object is null", function () {
            typeRegistryUnderTest.addPropertyWithUint(null,'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedUints,{});
        });

        it("should not add new uint property if test object don't have valid description object", function () {
            typeRegistryUnderTest.addPropertyWithUint({},'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedUints,{});
        });

        it("should add new uint property", function () {
            typeRegistryUnderTest.addPropertyWithUint({_description:{leanFTType:{technology:'web',leanftType:'button'}}},'count');
            assert.deepEqual(typeRegistryUnderTest._supportedUints['web']['button']['count'] ,true);
        });
    });

    describe("addPropertyWithNotRegexString",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedNotRegexString = {};
        });

        it("should not add new notregex property if test object is null", function () {
            typeRegistryUnderTest.addPropertyWithNotRegexString(null,'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedNotRegexString,{});
        });

        it("should not add new notregex property if test object don't have valid description object", function () {
            typeRegistryUnderTest.addPropertyWithNotRegexString({},'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedNotRegexString,{});
        });

        it("should add new notregex property", function () {
            typeRegistryUnderTest.addPropertyWithNotRegexString({_description:{leanFTType:{technology:'mobile',leanftType:'application'}}},'myapp');
            assert.deepEqual(typeRegistryUnderTest._supportedNotRegexString['mobile']['application']['myapp'] ,true);
        });
    });

    describe("addPropertyWithDouble",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedDoubles = {};
        });

        it("should not add new double property if test object is null", function () {
            typeRegistryUnderTest.addPropertyWithDouble(null,'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedDoubles,{});
        });

        it("should not add new double property if test object don't have valid description object", function () {
            typeRegistryUnderTest.addPropertyWithDouble({},'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedDoubles,{});
        });

        it("should add new double property", function () {
            typeRegistryUnderTest.addPropertyWithDouble({_description:{leanFTType:{technology:'web',leanftType:'slider'}}},'max');
            assert.deepEqual(typeRegistryUnderTest._supportedDoubles['web']['slider']['max'] ,true);
        });
    });
	
	describe("addPropertyWithDate",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedDates = {};
        });

        it("should not add new date property if test object is null", function () {
            typeRegistryUnderTest.addPropertyWithDate(null,'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedDates,{});
        });

        it("should not add new date property if test object don't have valid description object", function () {
            typeRegistryUnderTest.addPropertyWithDate({},'prop1');
            assert.deepEqual(typeRegistryUnderTest._supportedDates,{});
        });

        it("should add new date property", function () {
            typeRegistryUnderTest.addPropertyWithDate({_description:{leanFTType:{technology:'sapui5',leanftType:'calendar'}}},'date');
            assert.deepEqual(typeRegistryUnderTest._supportedDates['sapui5']['calendar']['date'] ,true);
        });
    });

    describe("isEnumValue",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedEnums = {};
        });

        it("should return null if test object is null", function () {
            var value = typeRegistryUnderTest.isEnumValue('kuku',{});
            assert.deepEqual(value,null);
        });

        it("should return null if test object's description equals null", function () {
            var value = typeRegistryUnderTest.isEnumValue('kuku',{_description:null});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Enums doesn't contain the relevant technology", function () {
            var value = typeRegistryUnderTest.isEnumValue('kuku',{_description:{leanFTType:{technology:'tech',leanftType:'type'}}});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Enums doesn't contain the relevant leanfttype under existing technonlogy", function () {
            typeRegistryUnderTest.addPropertyWithEnum({_description:{leanFTType:{technology:'tech',leanftType:'type'}}},'kuku',{myEnum:{}});
            var value = typeRegistryUnderTest.isEnumValue('kuku',{_description:{leanFTType:{technology:'tech',leanftType:'type2'}}});
            assert.deepEqual(value,null);
        });

        it("should return enum object", function () {
            typeRegistryUnderTest.addPropertyWithEnum({_description:{leanFTType:{technology:'tech',leanftType:'type'}}},'kuku',{myEnum:{}});
            var value = typeRegistryUnderTest.isEnumValue('kuku',{_description:{leanFTType:{technology:'tech',leanftType:'type'}}});
            assert.deepEqual(value,{myEnum:{}});
        });
    });

    describe("isDictionaryValue",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedDictionaries = {};
        });

        it("should return null if test object is null", function () {
            var value = typeRegistryUnderTest.isDictionaryValue('kuku',{});
            assert.deepEqual(value,null);
        });

        it("should return null if test object's description equals null", function () {
            var value = typeRegistryUnderTest.isDictionaryValue('kuku',{_description:null});
            assert.deepEqual(value,null);
        });

        it("should return null if supported dictionary doesn't contain the relevant technology", function () {
            var value = typeRegistryUnderTest.isDictionaryValue('kuku',{_description:{leanFTType:{technology:'tech',leanftType:'type'}}});
            assert.deepEqual(value,null);
        });

        it("should return null if supported dictionary doesn't contain the relevant leanfttype under existing technonlogy", function () {
            typeRegistryUnderTest.addPropertyWithDictionary({_description:{leanFTType:{technology:'tech',leanftType:'type'}}},'kuku');
            var value = typeRegistryUnderTest.isDictionaryValue('kuku',{_description:{leanFTType:{technology:'tech',leanftType:'type2'}}});
            assert.deepEqual(value,null);
        });

        it("should return true object", function () {
            typeRegistryUnderTest.addPropertyWithDictionary({_description:{leanFTType:{technology:'tech',leanftType:'type'}}},'kuku');
            var value = typeRegistryUnderTest.isDictionaryValue('kuku',{_description:{leanFTType:{technology:'tech',leanftType:'type'}}});
            assert.deepEqual(value,true);
        });
    });

    describe("isUintValue",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedUints = {};
        });

        it("should return null if test object is null", function () {
            var value = typeRegistryUnderTest.isUintValue('prop1',{});
            assert.deepEqual(value,null);
        });

        it("should return null if test object's description equals null", function () {
            var value = typeRegistryUnderTest.isUintValue('prop1',{_description:null});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Uints doesn't contain the relevant technology", function () {
            var value = typeRegistryUnderTest.isUintValue('prop1',{_description:{leanFTType:{technology:'web',leanftType:'button'}}});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Uints doesn't contain the relevant leanfttype under existing technonlogy", function () {
            typeRegistryUnderTest.addPropertyWithUint({_description:{leanFTType:{technology:'web',leanftType:'button'}}},'prop1');
            var value = typeRegistryUnderTest.isUintValue('prop1',{_description:{leanFTType:{technology:'web',leanftType:'edit'}}});
            assert.deepEqual(value,null);
        });

        it("should return true object", function () {
            typeRegistryUnderTest.addPropertyWithUint({_description:{leanFTType:{technology:'web',leanftType:'edit'}}},'prop1');
            var value = typeRegistryUnderTest.isUintValue('prop1',{_description:{leanFTType:{technology:'web',leanftType:'edit'}}});
            assert.deepEqual(value,true);
        });
    });

    describe("isNotRegexStringValue",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedNotRegexString = {};
        });

        it("should return null if test object is null", function () {
            var value = typeRegistryUnderTest.isNotRegexStringValue('prop1',{});
            assert.deepEqual(value,null);
        });

        it("should return null if test object's description equals null", function () {
            var value = typeRegistryUnderTest.isNotRegexStringValue('prop1',{_description:null});
            assert.deepEqual(value,null);
        });

        it("should return null if supported notregex doesn't contain the relevant technology", function () {
            var value = typeRegistryUnderTest.isNotRegexStringValue('prop1',{_description:{leanFTType:{technology:'mobile',leanftType:'application'}}});
            assert.deepEqual(value,null);
        });

        it("should return null if supported notregex doesn't contain the relevant leanfttype under existing technonlogy", function () {
            typeRegistryUnderTest.addPropertyWithNotRegexString({_description:{leanFTType:{technology:'mobile',leanftType:'application'}}},'prop1');
            var value = typeRegistryUnderTest.isNotRegexStringValue('prop1',{_description:{leanFTType:{technology:'mobile',leanftType:'button'}}});
            assert.deepEqual(value,null);
        });

        it("should return true object", function () {
            typeRegistryUnderTest.addPropertyWithNotRegexString({_description:{leanFTType:{technology:'mobile',leanftType:'application'}}},'prop1');
            var value = typeRegistryUnderTest.isNotRegexStringValue('prop1',{_description:{leanFTType:{technology:'mobile',leanftType:'application'}}});
            assert.deepEqual(value,true);
        });
    });

    describe("isDoubleValue",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedDoubles = {};
        });

        it("should return null if test object is null", function () {
            var value = typeRegistryUnderTest.isDoubleValue('prop1',{});
            assert.deepEqual(value,null);
        });

        it("should return null if test object's description equals null", function () {
            var value = typeRegistryUnderTest.isDoubleValue('prop1',{_description:null});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Doubles doesn't contain the relevant technology", function () {
            var value = typeRegistryUnderTest.isDoubleValue('prop1',{_description:{leanFTType:{technology:'web',leanftType:'button'}}});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Doubles doesn't contain the relevant leanfttype under existing technonlogy", function () {
            typeRegistryUnderTest.addPropertyWithDouble({_description:{leanFTType:{technology:'web',leanftType:'button'}}},'prop1');
            var value = typeRegistryUnderTest.isDoubleValue('prop1',{_description:{leanFTType:{technology:'web',leanftType:'edit'}}});
            assert.deepEqual(value,null);
        });

        it("should return true object", function () {
            typeRegistryUnderTest.addPropertyWithDouble({_description:{leanFTType:{technology:'web',leanftType:'edit'}}},'prop1');
            var value = typeRegistryUnderTest.isDoubleValue('prop1',{_description:{leanFTType:{technology:'web',leanftType:'edit'}}});
            assert.deepEqual(value,true);
        });
    });
	
	describe("isDateValue",function() {
        beforeEach(function(){
            typeRegistryUnderTest._supportedDates = {};
        });

        it("should return null if test object is null", function () {
            var value = typeRegistryUnderTest.isDateValue('prop1',{});
            assert.deepEqual(value,null);
        });

        it("should return null if test object's description equals null", function () {
            var value = typeRegistryUnderTest.isDateValue('prop1',{_description:null});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Dates doesn't contain the relevant technology", function () {
            var value = typeRegistryUnderTest.isDateValue('prop1',{_description:{leanFTType:{technology:'sapui5',leanftType:'calendar'}}});
            assert.deepEqual(value,null);
        });

        it("should return null if supported Dates doesn't contain the relevant leanfttype under existing technonlogy", function () {
            typeRegistryUnderTest.addPropertyWithDate({_description:{leanFTType:{technology:'sapui5',leanftType:'date'}}},'date');
            var value = typeRegistryUnderTest.isDateValue('prop1',{_description:{leanFTType:{technology:'sapui5',leanftType:'edit'}}});
            assert.deepEqual(value,null);
        });

        it("should return true object", function () {
            typeRegistryUnderTest.addPropertyWithDate({_description:{leanFTType:{technology:'sapui5',leanftType:'calendar'}}},'date');
            var value = typeRegistryUnderTest.isDateValue('date',{_description:{leanFTType:{technology:'sapui5',leanftType:'calendar'}}});
            assert.deepEqual(value,true);
        });
    });
});

