// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 13/10/2015.
 * This file contains helper utility objects to work with object and array types.
 */

//@type {{extend: Function, inherit: Function, map:Function, identity:Function}}

/**
 * Static object that contains helper functions for working with objects.

 * @class
 * @static
 * @private
 * @ignore
 */
var ObjectUtils = {
    /*jshint unused:true, eqnull:true*/
    /**
     * Adds the properties from one object to another object. In case of conflict, the given new property
     * replaces the property that is located on the object.
     * @function
     * @param {Object} obj The object that receives the new properties.
     * @param {Object} properties The properties that are added to the object.
     * @returns {*| Object} the merged object.
     */
    extend:function(obj,properties){
        return this._extend({preserveUndefined: false}, obj, properties);
    },
    /**
     * Same as extend, but keeps obj properties that are undefined unless reset by properties
     * @function
     * @param {Object} obj The object that receives the new properties.
     * @param {Object} properties The properties that are added to the object.
     * @returns {*| Object} the merged object.
     */
    extendAndPreserveUndefined:function(obj,properties){
        return this._extend({preserveUndefined: true}, obj, properties);
    },
    _extend:function(options, obj, properties){
	var preserveUndefined = options ? options.preserveUndefined: false;
        if(properties == null)
            return obj;

        Object.keys(properties).forEach(function(key){
            if(properties[key] === undefined && !preserveUndefined) {
                return;
            }

            var propertyDesc = Object.getOwnPropertyDescriptor(properties, key);
            if(propertyDesc && (propertyDesc.get || propertyDesc.set)) {
                Object.defineProperty(obj, key, propertyDesc);
            } else if(Array.isArray(properties[key])) {
                obj[key] = properties[key].slice();
            } else {
                obj[key] = properties[key];
            }
        });

        return obj;
    },
    /**
     * Performs prototype inheritance between two constructor functions.
     * The function adds property __super, which contains the prototype of the base. <br/>
     * To call the function from the base (where you have overridden) use:
     * childObj.__super.myBaseFunc.call(this,param1,...);
     * @function
     * @param {Object} child The constructor function of the child.
     * @param {Object} base The constructor function of the base.
     * @param {Object} childPrototypeObj The definition of the child.
     */
    inherit: function(child,base,childPrototypeObj){
        var baseProto = base.prototype;
        child.prototype = Object.create(baseProto);
        var childProto = child.prototype;
        childProto.constructor = child;
        childProto.__super = baseProto;

        ObjectUtils.extend(childProto,childPrototypeObj);
    },
    /**
     * Creates a new mapping of key, value pairs from the original mapping, given the key transformation callback and the value transformation callback.
     * @function
     * @param {Object} originalMap The original mapping of key value to transform.
     * @param {Object} keyTransformFunc The callback to transform the keys (Function).
     * @param {Object} valueTransformFunc The callback to transform the values.
     * @returns {{}} a new mapping.
     */
    map: function(originalMap,keyTransformFunc,valueTransformFunc){
        var result = {};
        if(originalMap == null)
            return null;

        Object.keys(originalMap).forEach(function(key){
            result[keyTransformFunc(key)] = valueTransformFunc(originalMap[key]);
        });

        return result;
    },
    /**
     * The identity function is a helper for various cases when an empty callback needs to be passed.
     * @function
     * @param {Object} x The value to return.
     * @returns {*} the value passed to the function.
     */
    identity: function(x){ return x;},

    /**
     * Creates a cloned copy of an object
     * @function
     * @param {Object} object The object to clone.
     */
    clone: function(object){
        return JSON.parse(JSON.stringify(object));
    },

    /**
     * Creates a new behavior with merged properties, methods, and helper functions of the desired behavior for unit tests.
     * @function
     * @param {Object} object The behavior to merge.
     */
    mergeTestBehavior: function (behavior)  {
        //this require can't be done at the top of the file since it causes circular require
        var MergeBehavior = require("./merge_behavior.js");
        var behaviorTest = {};
        ObjectUtils.extend(behaviorTest, MergeBehavior);
        behaviorTest._mergeBehavior.call(behaviorTest, behavior);
        return behaviorTest;
    },

    /**
     * Combines two behaviors on the _properties, _methods, and _helper functions keys.
     * @param {Object} behavior1 The behavior to merge to.
     * @param {Object} behavior2 The behavior to merge from.
     */
    combineBehaviors: function(behavior1, behavior2){
        ObjectUtils._mergeObjectProperty(behavior1, behavior2, '_properties');
        ObjectUtils._mergeObjectProperty(behavior1, behavior2, '_methods');
        ObjectUtils._mergeObjectProperty(behavior1, behavior2, '_helpers');
    },

    _mergeObjectProperty: function(behavior1, behavior2, property){
        if (typeof behavior2[property] === 'object') {
            var origObject = behavior1[property] != null ? behavior1[property]  : {};
            behavior1[property] = Object.assign(origObject, behavior2[property]);
        }
    },

    findKeyNameIgnoreCase: function (obj, propName) {
        propName = propName.toLowerCase();
        for(var key in obj) {
            if(key.toLowerCase() === propName) {
                return key;
            }
        }

        return null;
    }
};
//@type {{first: Function, toArray: Function}}

/**
 * Static object that contains helper functions for working with arrays.
 *
 * @class
 * @static
 * @private
 */
var ArrayUtils = {
    /*jshint unused:true, eqnull:true */
    /**
     * Returns the first element in the array which satisfies the predicate.
     * @param {Object} array The array to operate on.
     * @param {Object} predicate The predicate to test the elements on. This function takes the following arguments:<br />
     *  element - The element to test.<br />
     *  index - The index of the element in the array<br />
     *  array - The instance of the array
     * @param {Object} thisArg The predicate's 'this' object.
     * @returns the element; if not found, returns null.
     */
    first: function(array,predicate,thisArg){
        var result = null;
        Array.prototype.some.call(array,function(element, i, arr){
            var p = false;

            if(thisArg != null)
                p = predicate.call(thisArg,element,i,arr);
            else
                p = predicate(element,i,arr);

            if(p === true){
                result = element;
            }
            return p;
        });

        return result;
    },
    /**
     * Converts an array-like object to an array.
     * @param {Object} obj The object to convert.
     * @returns {*|Object[]} the array after conversion.
     */
    toArray: function(obj){
        return Array.prototype.map.call(obj,function(x){return x;});
    }
};

//@type {{isNullOrWhiteSpace: Function}}

/**
 * Static object that contains helper functions for working with strings.
 *
 * @class
 * @static
 */
var StringUtils = {
    /**
     * Returns true if the string is null or contains only whitespaces.
     * @param {string} str The string to check.
     * @returns {boolean} true if the string is null or only whitespaces.
     */
    isNullOrWhiteSpace: function(str) {
        return (str === null || str.match(/^ *$/) !== null);
    },

    lowerFirstLetter: function(string) {
        return string[0].toLowerCase() + string.slice(1);
    },

    /*jshint eqnull:true */
    /**
     * Returns true if the string is null or empty.
     * @param {string} str The string to check.
     * @returns {boolean} true if the string is null or empty.
     */
    isNullOrEmpty : function(str) {
        return (str == null || str.length === 0);
    },

    /*jshint eqnull:true */
    /**
     * Removes characters from the beginning of the string.
     * @param {string} str The string to remove.
     * @param {string} charList The characters to remove.
     * @returns {string} the string after removing the left characters.
     */
    trimLeft : function(str, charList) {
        if (charList == null) {
            charList = "";
        }
        return str.replace(new RegExp("^[" + charList + "]+"), "");
    },

    /*jshint eqnull:true */
    /**
     * Removes characters from the end of the string.
     * @param {string} str The string to remove.
     * @param {string} charList The characters to remove.
     * @returns {string} the string after removing the right characters.
     */
    trimRight : function(str, charList) {
        if (charList == null) {
            charList = "";
        }
        return str.replace(new RegExp("[" + charList + "]+$"), "");
    },

    /**
     * Removes characters from the left and right of the string.
     * @param {string} str The string to remove.
     * @param {string} charList The characters to remove.
     * @returns {void} the string after removing the left and right characters.
     */
    trim: function(str, charList) {
        return StringUtils.trimRight(StringUtils.trimLeft(str, charList), charList);
    },

    /**
     * Returns a function which performs Array.join and can be passed as a continuation.
     * @param {string} delimiter The delimiter that should be used for join.
     * @returns {Function} the continuation function that will perform the desired join.
     */
    joinFunc: function (delimiter) {
        return function (arr) {
            return arr.join(delimiter);
        };
    },

    /**
     * Returns a function which performs string.split and can be passed as a continuation.
     * @param {string} delimiter The delimiter that should be used for splitting the string to tokens.
     * @returns {Function} the continuation function that will perform the desired split.
     */
    splitFunc: function (delimiter) {
        return function (str) {
            // trims the delimiter so that an empty element won't be added.
            str = str.replace(new RegExp("[" + delimiter + "]$"), "");
            return str.split(delimiter);
        };
    }
};

module.exports.ObjectUtils = ObjectUtils;
module.exports.ArrayUtils = ArrayUtils;
module.exports.StringUtils = StringUtils;
