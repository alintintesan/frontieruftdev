// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/*
 * Created on 13/10/2015.
 * This file contain the base test object methods and functionality such as event dispatching and JSON conversion.
 */

var Logger = require("./logger.js").Logger;
var ArrayUtils = require("./object_utils.js").ArrayUtils;
var ObjectUtils = require("./object_utils.js").ObjectUtils;
var Convert = require("./convert.js").Convert;
var ReplayErrorsBehavior = require("./replay_errors.js");
var RectangleUtils = require("./helper_utils.js").RectangleUtils;
var NotifyEventsBehavior = require("./notify_events_behavior.js");
var TestObjectExecutor = require("./test_object_executor.js");
var RuntimeAccessMode = require("./properties_proxy_test_object_executor.js").RuntimeAccessMode;
var PropertiesProxyTestObjectExecutor = require("./properties_proxy_test_object_executor.js").PropertiesProxyTestObjectExecutor;
var MergeBehavior = require("./merge_behavior.js");

/**
 * Represents the base test object methods and additional functionality, such as event dispatching and JSON conversion.<br/>
 * Remark: This method should not be called. Inherit this object and then call the _init method to initialize it.
 * @abstract
 * @class TestObjectBase
 *
 */
function TestObjectBase(){
}

TestObjectBase.prototype = {
    _logger: null,
    _description: null,
    _cookie: null,

    _parent: null,
    _nativeClass: null,
    _session: null,
    _executor: null,

    /**
     * Returns the object display name defined in the Application Model.
     * @returns {string} the object display name.
     */
    displayName: null,

    /**
     * Returns the description for this test object. The test object must be obtained using the $ method, otherwise, this method returns null.
     * @returns {*} the description for this test object.
     */
    description: function(){
        return this._description;
    },

    /**
     * Returns the parent test object of this test object. The child object must be obtained using the $ method, otherwise, this method returns null.
     * @returns {*} the parent test object of this test object.
     */
    parent: function(){
        return this._parent;
    },

    /**
     * Creates a child test object of this test object.
     * This operation does not cause UFT Developer to search for the object in the AUT. UFT Developer interacts with the application only when a step runs that performs an operation on the AUT object.
     * @param {Description} description The description of the test object.  Can be a full test object description or a string.  If a string is provided, it is interpreted as a CSS selector with a default test object type of WebElement.
     * @returns {*} the new child test object with the provided description.
     */
    $: function(description){
        var child = this._session.factory.create(description.leanFTType,description);
        child._parent = this;

        return child;
    },

    /**
     *
     * @returns {*}
     * @private
     * @ignore
     */
    _toJSON: function(){
        if(this._cookie !== null) {
            return {
                ServerCookie: this._cookie
            };
        }

        return {
            Class: this._nativeClass,
            Description: this._description ? this._description._toJSON(): null,
            Parent: this._parent ? this._parent._toJSON() : null
        };
    },

    _toFullJson: function () {
        var json = {};
        if(this._cookie !== null) {
            json.ServerCookie = this._cookie;
        }

        json.Class = this._nativeClass;
        json.Description = this._description ? this._description._toJSON(): null;
        json.Parent = this._parent ? this._parent._toFullJson() : null;
        json.Name = this.displayName;

        if(this._getApplicationInfo) {
            json.ApplicationInfo = this._getApplicationInfo();
        }

        return json;
    },

    /**
     * Handles all execution requests to engine.
     * The method will invoke the additional data event if result contains additionaldata.
     * @param methodName
     * @returns {Promise}
     * @private
     * @ignore
     */
    _executeCommand: function(methodName) {
        return this._executor.executeCommand.apply(this._executor, arguments);
    },

    _executeVoidCommand: function() {
        return this._executor.executeCommand.apply(this._executor, arguments).then(function(){
            return null;
        });
    },

    _executeEvents: function (methodArgs,  originalArgumentsObject, onError, func, name, caller) {
        var args = ArrayUtils.toArray(methodArgs);
        args.splice(0, 1);

        var exec = function (id) {
            args.push(this._notifyAdditionalData.bind(this, id));
            var res = func.apply(this, args);
            return res;
        }.bind(this);
        var options = { sender: this, onError:onError, calleeArguments: originalArgumentsObject, type: "TestObject", name: name, caller: caller};
        return this.notifyWithEvents(exec ,args ,options);
    },

    /**
     * Handles the execution of the SDK operations with report event handling.
     * The method should be used if the operation should always appear on the report. <br/>
     * For example: 'return this._executeWithEvents(arguments, "Navigate", url);'
     * @param {Arguments} originalArgumentsObject The calling method arguments object instance.
     * @param {string} methodName The native method name.
     * @private
     */
    _executeWithEvents : function(originalArgumentsObject, methodName) {
        return this._executeEvents(arguments, originalArgumentsObject, false, this._executeCommand);
    },

    _executeWithEventsWithName: function(originalArgumentsObject, methodName, sdkMethodName) {
        var args = ArrayUtils.toArray(arguments);
        args.splice(2,1); //remove the sdkMethodName
        return this._executeEvents(args, originalArgumentsObject, false, this._executeCommand, sdkMethodName);
    },

    /**
     * Handles the execution of the SDK operations with report event handling.
     * The method should be used if the operation should appear on the report only on error (like in getROProperty).
     * For example: 'return this._executeWithEvents(arguments, "Navigate", url);'
     * @param {Arguments} originalArgumentsObject The calling method arguments object instance.
     * @param {string} methodName The native method name.
     * @private
     * @ignore
     */
    _executeWithEventsOnError : function(originalArgumentsObject, methodName) {
        return this._executeEvents(arguments, originalArgumentsObject, true, this._executeCommand);
    },

    /**
     * @private
     * @ignore
     */
    _notifyAdditionalData : function (cmdId, additionalData) {
        this._session.fireEvent("onAdditionalDataReceivedCommand", {
            commandId: cmdId,
            sender: this,
            additionalData: additionalData
        });
    },


    /**
     *
     * @param commandType
     * @param methodName
     * @returns {*}
     * @private
     * @ignore
     */
    _executeUtilityCommand: function(commandType, methodName){
        // Remove the first two arguments since they are the command type and methodName
        var args = ArrayUtils.toArray(arguments);
        args.splice(0,2);

        //checks if there is an additional data callback.
        var additionalDataHandler = ObjectUtils.identity;
        if(typeof(args[args.length -1]) === "function"){
            additionalDataHandler = args.pop();
        }

        var msg = {
            type: commandType,
            Operation: methodName,
            Parameters: args,
            Object: this._toJSON()
        };

        return this._session._communication.send("ExecuteUtilityObjectCommand",msg).then(function(data) {
            if(!data) //we expect to receive an object here
                return null;
            additionalDataHandler(data.AdditionalInfo);
            return this._getResultValue(data.Result);
        }.bind(this),function(error){
            additionalDataHandler(error._additionalInfo);
            this._handleError(error);
        }.bind(this));
    },

    /**
     *
     * @param propertyName
     * @returns {*}
     * @private
     * @ignore
     */
    _getROProperty: function(propertyName, methodArguments) {
        if (!methodArguments){
            return this._getROPropertyWithoutEvents(propertyName);
        }
        return this._executeWithEventsOnError(methodArguments, "GetROProperty", propertyName);
    },

    /**
     *
     * @param propertyName
     * @param [params] additional params if needed.
     * @returns {*}
     * @private
     * @ignore
     */
    _getROPropertyWithoutEvents: function(propertyName, params) {
        var args = ["GetROProperty"].concat(ArrayUtils.toArray(arguments));
        return this._executeCommand.apply(this, args);
    },

    /**
     *
     * @returns {*}
     * @private
     * @ignore
     */
    _getROProperties: function(methodArguments) {
        if (typeof(methodArguments) !== "object"){
            return this._getROPropertiesWithoutEvents.apply(this, arguments);
        }
        return this._executeWithEventsOnError(methodArguments, "GetROProperties", ArrayUtils.toArray(arguments).splice(1));
    },

    /**
     *
     * @returns {*}
     * @private
     * @ignore
     */
    _getROPropertiesWithoutEvents: function() {
        return this._executeCommand("GetROProperties", ArrayUtils.toArray(arguments));
    },

    /**
     *
     * @param nativeClass
     * @param session
     * @param description
     * @private
     * @ignore
     */
    _init: function (nativeClass,session,description) {
        this._nativeClass = nativeClass;
        this._session = session;
        this._description = description;
        this._executor = new TestObjectExecutor(this);
        this._logger = new Logger(description? description.leanFTType.leanftType : "TestObjectBase");


        ObjectUtils.extend(this, TestObjectUtilsBehavior);
        ObjectUtils.extend(this, ReplayErrorsBehavior);
        ObjectUtils.extend(this, NotifyEventsBehavior);
        ObjectUtils.extend(this, MergeBehavior);
    },

    /**
     * Handles case where the test object should contain cached properties
     * @param properties
     * @param runTimeAccessMode
     * @private
     * @ignore
     */
    _useCachedProperties: function (properties, runTimeAccessMode) {
        if (runTimeAccessMode.toLowerCase() === RuntimeAccessMode.noProxy.toLowerCase()) {
            return;
        }

        this._logger.info("updating executor to caching executor, test object = " + this._cookie);
        this._executor = new PropertiesProxyTestObjectExecutor(this._executor,
            properties, runTimeAccessMode);
    },

    /*jshint eqnull:true */
    /**
     * Checks whether this object exists in the AUT.
     * @function
     * @param {number} [timeout] The time (in seconds) to wait for this object before returning a result of true or false. <br/> By default, uses the object synchronization timeout defined in the runtime engine settings.
     * @returns {Promise<boolean>} a promise that is fulfilled with a boolean indicating whether the object exists.
     */
    exists: function(timeout){
        if(timeout === null)
            throw new Error("timeout passed to exists() method must be a number");

        args = ["Exist"];
        if(timeout != null) {
            args.push(Convert.toNumber(timeout));
        }

        if (this._session._config._saveLastAdditionalInfo) {
            // If aditional data handler function is added it is the last parameter to _executeCommand
            var _this = this;
            args.push(function (additionalData) {
                _this._lastAdditionalData = additionalData;
            });
        }
        return this._executeCommand.apply(this, args);
    },

    /**
     * Waits until this test object exists or until the specified timeout elapses.
     * This method is useful for synchronizing your test with your application.
     * @function
     * @param {number} [timeout] The time (in seconds) to wait for this object to exist. <br/> By default, uses the object synchronization timeout defined in the runtime engine settings.
     * @returns {Promise<boolean>} a promise that is fulfilled with a boolean indicating whether the object exists.
     */
    waitUntilExists: function (timeout) {
        return this.exists(timeout);
    },

    /**
     * Highlights this object in the AUT. <br/>
     * Remark: This may be useful when debugging a test.
     * @function
     * @returns {Promise<void>} a promise that is fulfilled when the highlighting operation ends.
     */
    highlight: function(){
        return this._executeWithEvents(arguments, "highlight");
    },

    /*jshint eqnull:true */
    /**
     * Returns all visible text from this object.
     * @function
     * @param {Object} [rectangle] The rectangular area in the test object to return the text from.
     * @returns {Promise<string>} a promise that is fulfilled with all the visible text from this object.
     */
    getVisibleText: function(rectangle){
        var rect = RectangleUtils.getRectangleOrDefault(rectangle);
        return this._executeUtilityCommand("ExecuteTestObjectOcrCommand", "GetTestObjectVisibleText", rect._left, rect._top, rect._right, rect._bottom);
    },

    /*jshint eqnull:true */
    /**
     * Returns all rectangular areas containing the specified text within this object.
     * @function
     * @param {string} text The text to search for in the test object.
     * @param {Object} [rectangle] The rectangular area in the test object to search for the text.
     * @returns {Promise<Object>} a promise that is fulfilled with an array of rectangles containing all rectangular areas containing the specified text within this object.
     */
    getTextLocations: function(text, rectangle){
        if (text == null)
            throw new Error("text parameter must be supplied");

        var rect = RectangleUtils.getRectangleOrDefault(rectangle);
        return this._executeUtilityCommand("ExecuteTestObjectOcrCommand", "GetTestObjectTextLocations", text, rect._left, rect._top, rect._right, rect._bottom).then(function(rectanglesArray){
            if (rectanglesArray!==null) {
                return RectangleUtils.convertNumArrayToRectArray(rectanglesArray);
            }
            return null;
        });
    },

    /*jshint eqnull:true */
    /**
     * Checks whether a snapshot of this object contains the supplied image.
     * @function
     * @param {string} imageToFind A Base64 string representation of the image to look for within the test object's snapshot.
     * @param {number} [similarity] The minimum similarity between the two images (as a percentage), above which the find is considered a match. Default = 100.
     * @returns {Promise<Object>} a promise that is fulfilled with an object representing the point where the image was located, or null if it was not found.
     */
    verifyImageExists: function(imageToFind, similarity){
        var func = function(id) {
            if (imageToFind == null || typeof(imageToFind) !== 'string')
                throw new Error("imageToFind parameter must be supplied correctly");
            if (similarity == null) {
                similarity = 100;
            }
            else {
                similarity = Convert.toNumber(similarity);
                if (similarity < 0 || similarity > 100)
                    throw new Error("Similarity value must be between 0 and 100");
            }
            return this._executeUtilityCommand("ExecuteTestObjectImageCommand", "FindBitmapInTestObject", imageToFind, "", this._notifyAdditionalData.bind(this, id));
        };
        var options = { sender: this, onError: false, calleeArguments: arguments, type: "BitmapCheckpoint"};
        return this.notifyWithEvents(func, arguments, options).then(function(result){
            if (result!==null) {
                if (result.actualSimilarity < similarity)
                    return null;
                return result.point;
            }
            return null;
        });
    },

    /*jshint eqnull:true */
    /**
     * Checks whether a snapshot of this object and the supplied image are a match.
     * @param {string} expectedImage A Base64 string representation of the image to compare to the test object snapshot.
     * @param {string} maskAreaImage A Base64 string representation of the image mask area to use in the image comparison.
     * @param {number} [pixelTolerance] The percentage of pixels that can differ between the two images, and still be considered a match. Default = 0.
     * @param {number} [rgbTolerance] The percentage by which the RGB values of the pixels in the two images can differ, and still be considered a match. Default =
     * @param {number} [id] The id of the operation.
     * @returns {Promise<boolean>} a promise that is fulfilled with a boolean representing the comparison result.
     * @private
     * @ignore
     */
    _executeImageMatchCommand: function(expectedImage, maskAreaImage, pixelTolerance, rgbTolerance, id){
        if (expectedImage == null || typeof(expectedImage) !== 'string')
            throw new Error("expectedImage parameter must be supplied correctly");
        if (maskAreaImage == null || typeof(maskAreaImage) !== 'string')
            throw new Error("maskAreaImage parameter must be supplied correctly");
        if (pixelTolerance == null) {
            pixelTolerance = 0;
        }
        else {
            pixelTolerance = Convert.toNumber(pixelTolerance);
            if (pixelTolerance < 0 || pixelTolerance > 100)
                throw new Error("pixelTolerance value must be between 0 and 100");
        }
        if (rgbTolerance == null) {
            rgbTolerance = 0;
        }
        else {
            rgbTolerance = Convert.toNumber(rgbTolerance);
            if (rgbTolerance < 0 || rgbTolerance > 100)
                throw new Error("rgbTolerance value must be between 0 and 100");
        }

        return this._executeUtilityCommand("ExecuteTestObjectImageCommand", "CompareTestObjectWithBitmap", expectedImage, maskAreaImage, pixelTolerance, rgbTolerance, this._notifyAdditionalData.bind(this, id));
    },

    /*jshint eqnull:true */
    /**
     * Checks whether a snapshot of this object and the supplied image are a match.
     * @function
     * @param {string} expectedImage A Base64 string representation of the image to compare to the test object snapshot.
     * @param {number} [pixelTolerance] The percentage of pixels that can differ between the two images, and still be considered a match. Default = 0.
     * @param {number} [rgbTolerance] The percentage by which the RGB values of the pixels in the two images can differ, and still be considered a match. Default = 0.
     * @returns {Promise<boolean>} a promise that is fulfilled with a boolean representing the comparison result.
     */
    verifyImageMatch: function(expectedImage, pixelTolerance, rgbTolerance){
        var func = function(id) {
            return this._executeImageMatchCommand(expectedImage, "", pixelTolerance, rgbTolerance, id);
        };
        var options = { sender: this, onError: false, calleeArguments: arguments, type: "BitmapCheckpoint"};
        return this.notifyWithEvents(func, arguments, options).then(function(result){
            if (result !== null) {
                return result.imagesMatch;
            }
            return false;
        });
    },

    /*jshint eqnull:true */
    /**
     * Checks whether a snapshot of this object and the supplied image are a match.
     * @function
     * @param {string} expectedImage A Base64 string representation of the image to compare to the test object snapshot.
     * @param {string} maskAreaImage A Base64 string representation of the image mask area to use in the image comparison.
     * @param {number} [pixelTolerance] The percentage of pixels that can differ between the two images, and still be considered a match. Default = 0.
     * @param {number} [rgbTolerance] The percentage by which the RGB values of the pixels in the two images can differ, and still be considered a match. Default = 0.
     * @returns {Promise<boolean>} a promise that is fulfilled with a boolean representing the comparison result.
     */
    verifyImageMatchWithMask: function(expectedImage, maskAreaImage, pixelTolerance, rgbTolerance){
        var func = function(id) {
            return this._executeImageMatchCommand(expectedImage, maskAreaImage, pixelTolerance, rgbTolerance, id);
        };
        var options = { sender: this, onError: false, calleeArguments: arguments, type: "BitmapCheckpoint"};
        return this.notifyWithEvents(func, arguments, options).then(function(result){
            if (result !== null) {
                return result.imagesMatch;
            }
            return false;
        });
    },

    /*jshint eqnull:true */
    /**
     * Returns all child objects of this object that match the supplied test object description.
     * @function
     * @param description A description object that defines the test object type and the set of properties and values that should be common to all objects that are returned.
     * @param {boolean} [dontFilterByType = false] Set this parameter to true to avoid limiting the returned objects to a specific test object type.
     * @returns {Promise<TestObject[]>} a promise that is fulfilled with an array of test objects that match the supplied description.
     */
    $$: function(description, dontFilterByType) { //find children
        return this._findChildrenHandler("ChildObjects", description, dontFilterByType);
    },
    /**
     * Highlights all children that match the supplied test object description.
     * @function
     * @param description A description object that defines the test object type and the set of properties and values that should be common to all objects that are highlighted.
     * @param {boolean} [dontFilterByType = false] Set this parameter to true to avoid limiting the highlighted objects to a specific test object type.
     * @returns {Promise<number>} a promise that is fulfilled with the number of matches that are found and highlighted.
     */
    highlightMatches: function(description, dontFilterByType){
        var func = function() {
            return this._findChildrenHandler("HighlightAllMatchingChildren", description, dontFilterByType);
        };
        var options = { sender: this, onError: true, calleeArguments: arguments, type: "TestObject"};
        return this.notifyWithEvents(func, arguments, options);
    },

    /**
     * Captures and returns a Base64 representation of this test object.
     * @function
     * @param {Object} [options] An options object that defines the image capture preferences.
     * @param {string} [options.format = "png"] The format of the image.  Possible values: png, bmp.
     * @returns {Promise<string>} a promise that is fulfilled with the Base64 string of the test object's image.
     */
    snapshot: function(options){
        options = options || {};
        var format = options.format || "png";
        if(format !== "png" && format !== "bmp")
            throw new Error("Unsupported image format " + format);
        return this._executeCommand("CaptureSnapshotToBase64String",format);
    },

    /**
     * Handles the request from the $$ and highlightMatches methods.
     * @param commandName The name of the method to execute.
     * @param description description The description of the children to look for.
     * The description explicitly defines which type of test objects to look for.
     * @param {boolean} [dontFilterByType = false] Set this parameter to true to look for test objects of all types matching the given description.
     * @returns {Promise<number|boolean>} a promise that is fulfilled with the number of matches found and highlighted, or true if all types match the given description.
     * @private
     * @ignore
     */
    _findChildrenHandler: function(commandName, description, dontFilterByType){
        if(description == null)
            return this._executeCommand(commandName, null);

        var childFilter = description._toJSON();
        childFilter.Type = "Description";

        if(!dontFilterByType) { //add the type to the filter
            var testObject = this._session.factory.create(description.leanFTType, null);
            var nativeTypeFieldName = testObject._nativeTypeFieldName || "micclass";

            childFilter.Properties[nativeTypeFieldName] = testObject._nativeClass;
        }
        return this._executeCommand(commandName, childFilter);
    },

    /**
     *
     * @param onFirstAction
     * @param onRestAction
     * @param items
     * @param itemTransform
     * @param firstArg
     * @returns {*}
     * @private
     * @ignore
     */
    _executeOnItemsCollection: function(originalArguments, onFirstAction, onRestAction, items, itemTransform, firstArg) {
        var func = function (id) {
            itemTransform = itemTransform || ObjectUtils.identity;

            if(items === null || items.length === 0)
                return;

            var lastPromise;
            //execute first action on first item
            if (typeof firstArg === 'undefined')
                lastPromise = this._executeCommand(onFirstAction, itemTransform(items[0]), this._notifyAdditionalData.bind(this, id));
            else
                lastPromise = this._executeCommand(onFirstAction, firstArg, itemTransform(items[0]), this._notifyAdditionalData.bind(this, id));

            var restItems = items.splice(1,items.length - 1);
            //execute rest action on rest items - chain promises
            restItems.forEach(function(item) {
                if (typeof firstArg === 'undefined')
                    lastPromise = lastPromise.then( function () {
                        return this._executeCommand(onRestAction, itemTransform(item), this._notifyAdditionalData.bind(this, id));
                    }.bind(this));
                else
                    lastPromise = lastPromise.then( function () {
                        return this._executeCommand(onRestAction, firstArg, itemTransform(item), this._notifyAdditionalData.bind(this, id));
                    }.bind(this));
            },this);

            return lastPromise;
        };
        var options = { sender: this, onError:false, calleeArguments: originalArguments , type: "TestObject"};
        return this.notifyWithEvents(func, arguments, options);
    },

    /**
     *
     * @param command
     * @param items
     * @param itemTransform
     * @returns {*}
     * @private
     * @ignore
     */
    _executeSingleOpOnCollection: function(originalArguments, command, items, itemTransform) {
        return this._executeOnItemsCollection(originalArguments, command, command, items, itemTransform);
    },

    /**
     * Handles the errors that are returned from the runtime engine.
     * The method should be used in the rejection of the promise.
     * @param {Error} error The exception object if the error is returned from the runtime engine; a field of statusCode should be included.
     * @returns {*}
     * @private
     * @ignore
     */
    _handleError: function(error){
        if(!error._handled) {
            error.message = this._convertNativeErrorToLeanFt(error.statusCode, error.message);
        }

        this.handleReplayError(error);
    },

    /**
     *
     * @param errorCode
     * @param errorMessage
     * @returns {*}
     * @private
     * @ignore
     */
    _convertNativeErrorToLeanFt: function(errorCode, errorMessage) {
        var to = this;
        var convertedMessage = errorMessage;

        while(to != null) {
            var nativeType = "[ " + to._nativeClass + " ]";
            var description = to._description;
            if(description) {
                var leanFtType = description.leanFTType.technology + "." + description.leanFTType.leanftType;
                convertedMessage = convertedMessage.replace(nativeType, leanFtType);
            }
            to = to._parent;
        }

        if (errorCode === -111) {
            //Replay object not found - remove the (of class *) pattern
            convertedMessage = convertedMessage.replace(/\s\(of class \w+\)/, "");
        }
        return convertedMessage;
    },

    /**
     *
     * @returns {*}
     * @private
     * @ignore
     */
    _canParticipateInOptimizedPath: function() {
        return true;
    },

    /**
     *
     * @returns {Promise} rejected Promise with reason Error.isNotSupported = true
     * @private
     * @ignore
     */
    _throwUnsupportedErrorAsync: function(methodName) {
        return this._session._promiseManager.syncedBranchThen(function() {
            var e = new Error("The " + methodName + " method is not supported for this test object.");
            e.isNotSupported = true;

            throw e;
        });
    }


};

/**
 * @ignore
 */
var TestObjectUtilsBehavior = {
    /*jshint eqnull:true */
    /**
     *
     * @param result
     * @returns {*}
     * @private
     * @ignore
     */
    _getResultValue: function(result) {
        if(result == null)
            return result;

        if(Array.isArray(result)) {
            return result.map(function (elem) {
                return this._getResultValue(elem);
            }, this);
        }

        if(!result.Type)
            return result;

        return this._specialValueHandler[result.Type].call(this, result);
    },

    _specialValueHandler: {
        TestObject: function(result) {
            return TestObjectParser.createTestObjectFromJson(this._session, result);
        },

        DynamicProxy: function(result) {
            var NativeObject = require("./native_object.js");
            if(result.ServerCookie == null)
                throw new Error("server cookie can't be null");

            return new NativeObject(result.ServerCookie, this._session)._fillKeysFromMembers();
        },

        BitmapFindLocationResult: function(result) {
            return {
                actualSimilarity: result.Similarity,
                point: {
                    x: result.X,
                    y: result.Y
                }};
        },

        BitmapGetImageLocationsResult: function(result) {
            return result.Points.filter(function (el) {
                return el !== null && el !== undefined && el.X >=0 && el.Y >= 0;
            }).map(function(point) { return {x: point.X, y: point.Y};});
        },

        BitmapComparisonResult: function(result) {
            return {
                imagesMatch: result.ImagesMatch,
                base64EncodedDiffImage: result.EncodedDiffImage
            };
        }
    }
};

var TestObjectParser = {
    /*jshint eqnull:true */
    createTestObjectFromJson : function (session, jsonInfo, runTimeAccessMode) {
        if (!jsonInfo || !session)
            return null;

        runTimeAccessMode = runTimeAccessMode || RuntimeAccessMode.accessOnUnknownOperationOrProperty;

        if (jsonInfo.ServerCookie == null && jsonInfo.Description == null)
            throw new Error("server cookie and description can't be null");

        var testObj = session.factory.createByNativeClass(jsonInfo.Class,
            jsonInfo.SubTypeInfo != null ? jsonInfo.SubTypeInfo.SimClass : null);

        if (jsonInfo.Description) {
            testObj._description = TestObjectParser.createDescriptionFromJson(testObj, jsonInfo.Description);
        }

        testObj._cookie = jsonInfo.ServerCookie;
        testObj.displayName = jsonInfo.Name;

        testObj._useCachedProperties(jsonInfo.Properties || {}, runTimeAccessMode);
        // In case this is an application context fill its actual application info properties
        if(testObj._getApplicationInfo && jsonInfo.Properties){
            testObj._applicationInfo = jsonInfo.Properties;
        }

        testObj._parent = TestObjectParser.createTestObjectFromJson(session, jsonInfo.Parent, runTimeAccessMode);

        return testObj;
    },

    /*jshint eqnull:true */
    createDescriptionFromJson: function(testObj, descriptionInfo) {
        var description = testObj._description;

        var properties = descriptionInfo.Properties;

        if (properties == null)
            return description;

        var identificationFieldObject = descriptionInfo.Identification;

        if (identificationFieldObject != null){
            var filteredProperties = {};
            Object.keys(properties).filter(function(propertyKey){
                return (identificationFieldObject.indexOf(propertyKey)!==-1);
            }).forEach(function(filteredKey){
                filteredProperties[filteredKey] = properties[filteredKey];
            });

            properties = filteredProperties;
        }

        //work around for Web.Link (relevant for result from Native engine only)
        if(testObj._nativeClass.toLowerCase() === "link") {
            if(properties.text) {
                properties.innerText = properties.text;
            }
        }

        this._mergeDescriptions(description,properties);

        var indexDescription = descriptionInfo.Index;
        if (indexDescription != null){
            if(typeof indexDescription === 'object') {
                var keys = Object.keys(indexDescription);
                if (keys.length != 1)
                    throw new Error("Index should have only one value.");

                description._indexType = keys[0];
                description._index = indexDescription[keys[0]];
            }
            else{
                description._indexType = "Index";
                description._index = indexDescription;
            }
        }

        return description;
    },

    _mergeDescriptions: function (description, properties) {
        Object.keys(description._properties).forEach(function(item){
            if (description._properties[item]._keysMap != null) {
                this._initFromKeyMap(description._properties[item], properties);
            } else if (description._properties[item]._keyPrefix != null) {
                this._initFromPrefix(description._properties[item], properties);
            }
        },this);

        Object.keys(properties).forEach(function (item) {
            description._insertValue(item, properties[item]);
        });
    },

    _initFromKeyMap: function (groupedProperty, properties) {
        Object.keys(groupedProperty._keysMap).forEach(function(item){
            var value = properties[groupedProperty._keysMap[item]];
            if (value != null){
                groupedProperty[item] = value;
                delete properties[groupedProperty._keysMap[item]];
            }
        });
    },

    _initFromPrefix: function (groupedProperty, properties) {
        var prefix = groupedProperty._keyPrefix;
        Object.keys(properties).forEach(function(key){
            if (key.startsWith(prefix)) {
                var value = properties[key];
                var propKey = key.substr(prefix.length);
                groupedProperty[propKey] = value;
                delete properties[key];
            }
        });
    }

};




module.exports.TestObjectBase = TestObjectBase;
module.exports.TestObjectUtilsBehavior = TestObjectUtilsBehavior;
module.exports.TestObjectParser = TestObjectParser;
