// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 11/10/2015.
 * The file contains a definition to communication client which wraps the logic that is needed inorder to communicate with
 * LeanFT runtime engine, the communication is performed currently using promises and the bridge between the communication's callback into
 * promises is performed using this class.
 */

 /** @private */
var Logger = require("./logger.js").Logger;
 /** @private */
var WSCommunicationChannel = require("./websocket_communication_channel.js").WSCommunicationChannel;
 /** @private */
var Q = require("q");

var EMPTY_SESSION_ID = "00000000-0000-0000-0000-000000000000"; //Needs to be initialized with empty GUID.

/*jshint eqnull:true */
function sdkModeTranslate(sdkMode) {
    sdkMode = sdkMode != null ? sdkMode.toLowerCase() : "replay";

    switch (sdkMode) {
        case "replay":
            return 0;
        case "interactive":
            return 1;
        default:
            return 0;
    }
}

/**
 * Communication Client
 *
 * @class
 * @ignore
*/
function CommunicationClient(config, promiseManager, channelOptions){
    this._logger = new Logger("CommunicationChannel");
    this._address = config.address;
    this._sessionMode = config.mode != null? sdkModeTranslate(config.mode) : 0; //0 - Replay
    this._perSessionSettings = null; //currently no per session settings
    this._wsChannel = new WSCommunicationChannel(this._address, channelOptions);
    this._sessionID = EMPTY_SESSION_ID;
    this._promiseManager = promiseManager;

    //connects to events
    this._wsChannel.onDisconnect = this._onDisconnect.bind(this);
    this._wsChannel.onMessage = this._onMessage.bind(this);
}

CommunicationClient.prototype = {
    _logger: null,
    _address: null,
    _sessionMode: null,
    _perSessionSettings: null,
    _sessionID: null,
    _wsChannel: null,
    _promiseManager: null,

    /*********** Events ****/
    onMessage: null,
    onDisconnect: null,

    /**
	 * connect function
	 * @function
     * @ignore
	 */
    connect: function(){
        return this._promiseManager.syncedBranchThen(this._connect.bind(this));
    },

    _connect: function () {
        this._logger.info("_connect: Called to " + this._address);
        var deferred = Q.defer();
        this._wsChannel.onConnect = this._onConnect.bind(this,deferred);
        this._wsChannel.onDisconnect = this._onDisconnect.bind(this,deferred);
        this._wsChannel.connect();

        var connectPromise  = deferred.promise.then(function() {
            this._logger.info("_onConnect: Got connection to " + this._address);
            var newSessionMsg = {
                "SessionMode": this._sessionMode,
                "perSessionSettings": this._perSessionSettings,
                "sdk": "JavaScript"
            };
            //When returning a promise during fulfill function it will wait for the returned promise to be resolved
            //before moving towards to the next promise in chain.
            return this._send("NEW_SESSION", newSessionMsg);
        }.bind(this))
            .then(function(data){
                this._sessionID = data.NewSessionId;
                this._logger.info("_onConnect: The new session id is: " + this._sessionID);
            }.bind(this));

        return connectPromise;
    },

	/**
	 * send function
	 * @function
     * @ignore
	 */
    send: function(msgType,data) {
        var storedStack = new Error().stack;
        return this._promiseManager.syncedBranchThen(this._send.bind(this,msgType,data,storedStack));
    },

    _send: function(msgType,data,storedStack){
        var msg = {
            type: msgType,
            sessionId: this._sessionID,
            data: data
        };

        var deferred = Q.defer();

        this._wsChannel.send(msg,this._handleResponse.bind(this,deferred,storedStack));

        return deferred.promise;
    },

    _notify: function(msgType, data) {
            var msg = {
                type: msgType,
                sessionId: this._sessionID,
                data: data
            };

            this._wsChannel.notify(msg);
    },

    sendCB: function (msgType, data, responseCB, errorCB) {
        var storedStack = new Error().stack;
        var msg = {
            type: msgType,
            sessionId: this._sessionID,
            data: data
        };

        this._wsChannel.send(msg,this._handleResponseCB.bind(this, responseCB, errorCB, storedStack));
    },

	/**
	 * disconnect function
	 * @function
     * @ignore
	 */
    disconnect: function(){
        this._logger.info("disconnect: called");
        if(this._sessionID === EMPTY_SESSION_ID) {
            //no session was created so no need to close it.
            return this._promiseManager.syncedBranchThen(this._closeConnection.bind(this));
        }

        return this.send("CLOSE_SESSION",null).then(this._closeConnection.bind(this));
    },


    /**
     * @private
     */
    _closeConnection: function(){
        this._wsChannel.disconnect();
        this._sessionID = EMPTY_SESSION_ID;
    },

    //*************** Event Handlers ************/
    /**
     *
     * @param {Object} connectPromise
     * @private
     */
    _onConnect: function(connectPromise){
        this._logger.info("connect: Got connected to " + this._address);
        connectPromise.resolve();
    },
    /**
     *
     * @param {Object} request
     * @param {Object} wsChannelResponseCB
     * @private
     */
    _onMessage: function(request, wsChannelResponseCB){
        this._logger.trace("_onMessage: Got the following request");

        if(this.onMessage)
            this.onMessage(request, this._sendResponseCB.bind(this, wsChannelResponseCB, request.type));
        else
            this._logger.warn("no onMessage handler is set, message ignored");
    },

    _sendResponseCB: function (wsChannelResponseCB, msgType, data) {
        var msg = {
            type: msgType,
            sessionId: this._sessionID,
            data: data
        };

        wsChannelResponseCB(msg);
    },

    /**
     *
     * @private
     */
    _onDisconnect: function(connectPromise){
        this._logger.info("_onDisconnect: Got disconnected from : " + this._address);
        this._sessionID = EMPTY_SESSION_ID;
        if(!connectPromise.promise.isFulfilled()){
            this._logger.info("_onDisconnect: We are during connection lets reject the promise");
            connectPromise.reject(new Error("Failed to connect to LeanFT runtime on " + this._address));
        }

        if(this.onDisconnect)
            this.onDisconnect(this);
    },
    /**
     * Handles the response that is returned from the runtime.     * @param messageDeferred This is the deferred object that was created during the send of the request to the engine. (This should be used by the bind.)
     * @param {Object} storedStack
     * @param {Object} response The response message, including the session and the type of the message.
     * @private
     */
    _handleResponse: function(messageDeferred,storedStack,response){
        this._handleResponseCB(function (response) {
            messageDeferred.resolve(response);
        }, function (error) {
            messageDeferred.reject(error);
        }, storedStack, response);
    },

    _handleResponseCB: function(responseCB, errorCB, storedStack, response){
        var resError;
        if(response === null){
            this._logger.error("_handleResponse: Got response without any data");
            resError = new Error("Empty response");
            resError.lftStack = storedStack;
            errorCB(resError);
            return;
        }

        var resultData = response.data;
        var status = response.status;
        if(status === 0){
            responseCB(resultData);
            return;
        }

        var errorMessage = (this._generalErrors[status.toString()] || "GeneralLeanFtException") + ": ";
        errorMessage += resultData.ErrorMessage || "with code " + status;

        resError = new Error(errorMessage);
        resError.statusCode = status;

        if (status === -123) {
            resError.isNotSupported = true;
        }
        resError.lftStack = storedStack;
        resError._additionalInfo = resultData.AdditionalInfo;
        this._logger.debug("_handleResponse: Going to reject with the following message:" + errorMessage);
        errorCB(resError);
    },

    /**
     * This is the mapping between the status code to the type of the exception.
     */
    _generalErrors:{
        "-100": "GeneralServerErrorException",
        "-101": "ServerIsShuttingDownException",
        "-102": "MessageTypeNotSupportedException",
        "-103": "EmptySessionIdException",
        "-104": "SessionNotFoundExceptionException",
        "-106": "InvalidFormatException",
        "-107": "InvalidVersionException",
        "-108": "InvalidMessageFieldException",
        "-109": "InvalidAgentException",
        "-121": "ServerAlreadyInRecordModeException",
        "-122": "NoValidLicenseException",
        "-123": "NotSupportedException",
        "-200": "MobileCenterNotConnectedException",
        "-201": "LabNotConnectedException"
    }
};
module.exports.CommunicationClient = CommunicationClient;
