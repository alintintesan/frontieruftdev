// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 22/05/2016.
 */
var Logger = require("./logger.js").Logger;
var Q = require("q");
var ArrayUtils = require("./object_utils.js").ArrayUtils;
var ObjectUtils = require("./object_utils.js").ObjectUtils;

function PromiseManager() {
    this._logger = new Logger("PromiseManager");
    this._promiseManagerImpl = new LftPromiseManager();
}

PromiseManager.prototype = {
    _logger: null,
    _promiseManagerImpl: null,

    /*jshint eqnull:true*/
    config: function (executionSynchronization) {
        if(executionSynchronization == null) {
            return;
        }

        this._reset();

        if(executionSynchronization === false || executionSynchronization.toLowerCase() == "false") {
            this._logger.info("config: going to use: NativePromiseManager");
            this._promiseManagerImpl = new NativePromiseManager();
        } else {
            this._logger.info("config: going to use: LftPromiseManager");
            this._promiseManagerImpl = new LftPromiseManager();
        }
    },

    init: function(nativePromiseToWrap) {
        return this._promiseManagerImpl.init(nativePromiseToWrap);
    },

    syncedBranchThen: function(fulfilled, rejected) {
        return this._promiseManagerImpl.syncedBranchThen(fulfilled, rejected);
    },

    _reset: function() {
        return this._promiseManagerImpl._reset();
    },

    whenDone: function (done) {
        return this._promiseManagerImpl.whenDone(done);
    },

    wrapPromiseFunctionWithNotifyEvents: function (onStart, promiseFuncToWrap, onFinishOK, onFinishErr) {
        return this._promiseManagerImpl.wrapPromiseFunctionWithNotifyEvents(onStart, promiseFuncToWrap, onFinishOK, onFinishErr);
    }
};


function NativePromiseManager() {
    this._logger = new Logger("NativePromiseManager");
}

NativePromiseManager.prototype = {
    _logger: null,
    
    init: function(nativePromiseToWrap) {
        return nativePromiseToWrap;
    },

    syncedBranchThen: function(fulfilled/*, rejected*/) {
        return Q.resolve(fulfilled());
    },

    _reset: function() {
        return Q.resolve(null);
    },

    whenDone: function () {
        this._logger.warn("whenDone is not supported by the DummyPromiseManager");
    },

    wrapPromiseFunctionWithNotifyEvents: function (onStart, promiseFuncToWrap, onFinishOK, onFinishErr) {
        try {
            onStart();
        } catch (e) {
            this._logger.warn("onStart failed: " + e);
        }

        return promiseFuncToWrap().then(function (res) {
            try {
                onFinishOK(res);
            } catch(e) {
                this._logger.warn("onFinishOK failed: " + e);
            }

            return res;
        }.bind(this), function (err) {
            try {
                onFinishErr(err);
            } catch(e) {
                this._logger.warn("onFinishErr failed: " + e);
            }

            //re-throw
            throw err;
        }.bind(this));
    }
};

function LftPromiseManager(promiseStateStrategy) {
    this._logger = new Logger("PromiseManager");
    this._generation = 0;

    this._promiseStateStrategy = promiseStateStrategy || PromiseStateStrategy;
}

LftPromiseManager.prototype = {
    _logger: null,
    _nextPromiseId: 0,
    _syncedBranchPromise: null,
    _syncedBranchId: null,
    _syncedBranchesMap: null,
    _generation: null,
    _promiseStateStrategy: null,

    /**
     * This method creates the synced PromiseWrapper and performs initializations.
     * @param {Object} nativePromiseToWrap The native promise to be wrapped by the synced PromiseWrapper.
     * @returns {PromiseWrapper}
     */
    init: function(nativePromiseToWrap) {
        return this._reset(nativePromiseToWrap);
    },

    _reset: function(nativePromise) {
        this._generation++;

        var nativePromiseToWrap = nativePromise || Q.resolve(null);
        var syncedPromise = new PromiseWrapper(this, nativePromiseToWrap);
        this._syncedBranchesMap = {};
        this._syncedBranchesMap[syncedPromise._id] = syncedPromise;
        this._syncedBranchPromise = syncedPromise;
        this._syncedBranchId = syncedPromise._id;
        return syncedPromise;
    },

    whenDone: function (done) {
        //this wrapping ensures the done is not called with the result of
        //previous synced promise, which causes a failure in Mocha
        //Before calling done we should reset the PromiseManager since all non-finished promises are no longer relevant
        var doneFulfilled = function () {
            this._reset();
            done();
        }.bind(this);

        var doneReject = function (error) {
            this._reset();
            if (done.fail) { //Jasmine style
                this._logger.debug("done.fail is called");
                return done.fail(error);
            } else { //Mocha style
                this._logger.debug("done(error) is called");
                return done(error);
            }
        }.bind(this);

        this.syncedBranchThen(doneFulfilled, doneReject);
    },

    startSyncedBranch: function(syncedBranchOwnerPromise) {
        if(this.isCancelled(syncedBranchOwnerPromise)) {
            return;
        }
        var newSyncedPromise = new PromiseWrapper(this, Q.resolve(null));
        this._syncedBranchesMap[syncedBranchOwnerPromise._id] = newSyncedPromise;
        this._syncedBranchPromise = newSyncedPromise;
        this._syncedBranchId = syncedBranchOwnerPromise._id;
    },

    /**
     * Returns a promise which will be resolved once all synced promises of the current synced branch
     * are resolved (and all their sub trees) or rejected if one of the leafs of the synced promises of the current synced branch
     * is rejected.
     * @param {Object} syncedBranchOwnerPromise the owenr of synced branch.
     * @ignore
     */
    endSyncedBranch: function(syncedBranchOwnerPromise) {
        return this.getSyncedBranchState().finally(function () {
            delete this._syncedBranchesMap[syncedBranchOwnerPromise._id];
        }.bind(this));
    },

    syncedBranchThen: function(fulfilled, rejected) {
        this._syncedBranchPromise = this.addStateStrategyToPromiseWrapper(this._syncedBranchPromise)._then(fulfilled, rejected);
        this._syncedBranchesMap[this._syncedBranchId] = this._syncedBranchPromise;
        return this._syncedBranchPromise;
    },

    addStateStrategyToPromiseWrapper: function(promiseWrapper) {
        var fulfilled = this._promiseStateStrategy.fulfilled ?
            this._promiseStateStrategy.fulfilled.bind(undefined, promiseWrapper, PromiseTreeTraversal) : null;

        var rejected = this._promiseStateStrategy.rejected ?
            this._promiseStateStrategy.rejected.bind(undefined, promiseWrapper, PromiseTreeTraversal) : null;

        return promiseWrapper._thenNoWrap(fulfilled, rejected);
    },

    getSyncedBranchState: function() {
        var fulfilled = this._promiseStateStrategy.fulfilled ?
            this._promiseStateStrategy.fulfilled.bind(undefined, this._syncedBranchPromise, PromiseTreeTraversal) : null;

        var rejected = this._promiseStateStrategy.rejected ?
            this._promiseStateStrategy.rejected.bind(undefined, this._syncedBranchPromise, PromiseTreeTraversal) : null;

        return this._syncedBranchPromise._wrapped.then(fulfilled, rejected); //Q promise
    },

    isCancelled: function(promise) {
        return (promise._promiseManager !== this || promise._generation != this._generation);
    },

    getNextPromiseId: function() {
        return LftPromiseManager.prototype._nextPromiseId++;
    },

    wrapPromiseFunctionWithNotifyEvents: function (onStart, promiseFuncToWrap, onFinishOK, onFinishErr) {
        this.syncedBranchThen(onStart);
        var promise = promiseFuncToWrap();
        promise._setOnFinish(onFinishOK, onFinishErr);
        return promise;
    }
};


function PromiseWrapper(promiseManager, promiseToWrap){
    this._logger = new Logger("PromiseWrapper");

    this._promiseManager = promiseManager;
    this._wrapped = promiseToWrap;
    this._id = this._promiseManager.getNextPromiseId();
    this._generation = this._promiseManager._generation;
    this._thenNodes = [];
}

PromiseWrapper.prototype = {
    _wrapped: null,
    _logger: null,
    _promiseManager: null,
    _thenNodes: null,
    _id: null,
    _generation: null,

    _isLeaf: function () {
        return this._thenNodes.length === 0;
    },

    _init: function(parentPromiseWrapper, fulfilled, rejected) {
        var wrappedFulfilled = this._wrapFulfilled.bind(this, fulfilled);
        var wrappedRejected = this._wrapRejected.bind(this, rejected);

        this._wrapped = parentPromiseWrapper._wrapped.then(wrappedFulfilled, wrappedRejected);
    },

    _initNoWrap: function (parentPromiseWrapper, fulfilled, rejected) {
        this._wrapped = parentPromiseWrapper._wrapped.then(fulfilled, rejected);
    },

    /*jshint eqnull:true*/
    /**
     * Chains fulfilled and rejected callbacks to this PromiseWrapper instance.
     * @param {Function} fulfilled The callback that is called upon successful ending of this PromiseWrapper.
     * @param {Function} rejected The callback that is called if the current PromiseWrapper fails.
     * @returns {*} a new instance of the PromiseWrapper with the given fulfilled and rejected callbacks chained to it.
     */
    then: function(fulfilled,rejected){
        var thenPromiseWrapper = this._then(fulfilled, rejected);
        this._thenNodes.push(thenPromiseWrapper);
        return thenPromiseWrapper;
    },

    /**
     * Performs the 'then' promise chaining, does not update the _thenNodes.
     * @param {Function} fulfilled the fulfilled callback
     * @param {Function} rejected the rejected callback
     * @returns {PromiseWrapper} the PromiseWrapped wrapping the 'then' chained promise.
     * @private
     */
    _then: function(fulfilled,rejected){
        var thenPromiseWrapper = new PromiseWrapper(this._promiseManager);
        thenPromiseWrapper._init(this, fulfilled, rejected);
        return thenPromiseWrapper;
    },

    /**
     * Performs the 'then' promise chaining, does not update the _thenNodes
     * and does not wrap the fulfilled and rejected callbacks.
     * @param {Function} fulfilled the fulfilled callback
     * @param {Function} rejected the rejected callback
     * @returns {PromiseWrapper} the PromiseWrapped wrapping the 'then' chained promise.
     * @private
     */
    _thenNoWrap: function(fulfilled,rejected){
        var thenPromiseWrapper = new PromiseWrapper(this._promiseManager);
        thenPromiseWrapper._initNoWrap(this, fulfilled, rejected);
        return thenPromiseWrapper;
    },

    /**
     * This function can be used to catch exceptions of the current PromiseWrapper.
     * If an exception occurs, the passed cb is called with the exception as an argument.
     * @param {Function} cb The callback to call and pass the exception to, if an exception occurs in this promise.
     * @returns {PromiseWrapper}
     */
    catch: function(cb) {
        return this.then(ObjectUtils.identity, cb);
    },

    _wrapFulfilled: function(fulfilled) {
        this._logger.debug("start fulfill of id: " + this._id);
        var args = ArrayUtils.toArray(arguments);
        args.splice(0,1);
        if(this._promiseManager.isCancelled(this)) {
            //this promise was cancelled, so don't perform any code on this branch
            this._logger.debug("Promise id: " + this._id + " cancelled: " + this._promiseManager.isCancelled(this));
            return;
        }

        if(!fulfilled) {
            return undefined;
        }

        return this._wrapCallbackHelper(fulfilled, args);
    },

    _wrapRejected: function(cb, error){
        this._logger.debug("start wrapRejected of id: " + this._id);
        var args = ArrayUtils.toArray(arguments);
        args.splice(0,1);
        if(this._promiseManager.isCancelled(this)) {
            this._logger.debug("Promise id: " + this._id + " is cancelled");
            return;
        }

        if(!cb) {
            //empty reject or catch called re-throw the error
            throw error;
        }

        return this._wrapCallbackHelper(cb, args);
    },

    _wrapCallbackHelper: function (cb, args) {
        try {
            this._promiseManager.startSyncedBranch(this);
            var res = cb.apply(this, args);

            return this._promiseManager.endSyncedBranch(this)
                .then(function () {return res;});
        } catch(e) {
            //synchronic error occurred
            return this._promiseManager.endSyncedBranch(this).then(function () {
                throw e;
            });
        }
    },

    _setOnFinish: function(onFinishOK, onFinishErr) {
        this._wrapped = this._wrapped.then(this._wrapOnFinishOK.bind(this,onFinishOK),
            this._wrapOnFinishErr.bind(this,onFinishErr));
    },

    _wrapOnFinishOK: function (onFinishOK, result) {
        if(!onFinishOK)
            return result;

        try {
            onFinishOK(result);
        } catch(e) {
            this._logger.warn("onFinishOK failed: " + e);
        }

        return result;
    },

    _wrapOnFinishErr: function (onFinishErr, error) {
        if(!onFinishErr)
            throw error;

        try {
            onFinishErr(error);
        } catch(e) {
            this._logger.warn("onFinishErr failed: " + e);
        }

        throw error;
    }
};

var PromiseStateStrategy = {
    fulfilled: function (promiseWrapper, promiseTreeTraversal, resToReturn) {
        if(promiseWrapper._isLeaf())
            return resToReturn;

        var allLeafsWrappers = promiseTreeTraversal.getAllLeafs(promiseWrapper);
        var allLeafsInnerPromises = allLeafsWrappers.map(function (promiseWrapperLeaf) {
            return promiseWrapperLeaf._wrapped;
        });

        return Q.all(allLeafsInnerPromises).then(function () {
            return resToReturn;
        });
    },

    rejected: function (promiseWrapper, promiseTreeTraversal, error) {
        if(promiseWrapper._isLeaf())
            throw error; //re-throw error

        var allLeafsWrappers = promiseTreeTraversal.getAllLeafs(promiseWrapper);
        var allLeafsInnerPromises = allLeafsWrappers.map(function (promiseWrapperLeaf) {
            return promiseWrapperLeaf._wrapped;
        });

        return Q.all(allLeafsInnerPromises).then(function () {
            return undefined;
        });
    }
};

var PromiseTreeTraversal = {
    getAllLeafs: function (promiseWrapper) {
        if(promiseWrapper._isLeaf())
            return [promiseWrapper];

        var leafsFound = [];
        var processedWrappers = [];
        var wasProcessed = function (promiseWrapper) {
            return processedWrappers.find(function (processedWrapper) {
                return processedWrapper._id == promiseWrapper._id;
            });
        };

        PromiseTreeTraversal._getAllLeafsHelper(promiseWrapper, leafsFound, processedWrappers, wasProcessed);
        return leafsFound;
    },

    _getAllLeafsHelper: function (promiseWrapper, leafsFound, processedWrappers, wasProcessed) {
        if(wasProcessed(promiseWrapper))
            return;

        processedWrappers.push(promiseWrapper);

        if(promiseWrapper._isLeaf()) {
            leafsFound.push(promiseWrapper);
            return;
        }

        promiseWrapper._thenNodes.forEach(function (thenNode) {
            PromiseTreeTraversal._getAllLeafsHelper(thenNode, leafsFound, processedWrappers, wasProcessed);
        });
    }
};


var delay = function (promiseManager, milliseconds) {
  return promiseManager.syncedBranchThen(function () {
      return Q.delay(milliseconds);
  });
};

/*
Algorithm:
    1) insert one promise to the synched branch (which executes the checkFunc)
    2) insert another promise to the synched branch returning a promise from a new deferred - this makes the whole synch branch to hold.
    3) add a then on the promise returned in step 1 (starting a private synched branch):
       3.1) if checkFunc result is true, resolve the deferred with true.
       3.2) else:
            3.2.1) if timeout, resolve the deferred with false.
            3.2.2) else:
                    3.2.2.1) delay 500 milli seconds
                    3.2.2.2) call checkFunc again and add a then to step 3.1 (creating a loop)
 */
var waitUntil = function(promiseManager, checkFunc, timeout) {
    var logger = new Logger("waitUntil");
    var startTime = Date.now();
    var checkPromise = promiseManager.syncedBranchThen(checkFunc);
    var deferred = Q.defer();

    var resultPromise = promiseManager.syncedBranchThen(function() {
        return deferred.promise;
    });

    function checkIfTimeout(additionalTimeToAdd) {
        if(timeout) {
            additionalTimeToAdd = additionalTimeToAdd || 0;
            var currentTime = Date.now() + additionalTimeToAdd;
            if(currentTime - startTime > timeout) {
                logger.trace("checkIfTimeout: timeout occurred");
                return true;
            }
        }

        return false;
    }

    function retryCheckFunc(result) {
        if(result) {
            logger.trace("checkFunc resolved");
            deferred.resolve(true);
            return;
        }

        return promiseManager.syncedBranchThen(function() {
            if(checkIfTimeout(500)) {
                logger.trace("timeout occurred, won't perform additional checks");
                deferred.resolve(false);
                return;
            }

            return Q.delay(500).then(checkFunc).then(retryCheckFunc);
        });
    }

    checkPromise.then(retryCheckFunc);

    return resultPromise;
};


module.exports.whenDone = PromiseManager.whenDone;
module.exports.PromiseManager = PromiseManager;
module.exports.delay = delay;
module.exports.waitUntil = waitUntil;
//for unit tests
module.exports.PromiseWrapper = PromiseWrapper;
module.exports.LftPromiseManager = LftPromiseManager;
module.exports.NativePromiseManager = NativePromiseManager;