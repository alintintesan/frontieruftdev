// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 28/09/2016.
 */

var StringUtils = require("./object_utils.js").StringUtils;
var ObjectUtils = require("./object_utils.js").ObjectUtils;

var TypeRegistry = {
    _supportedEnums : {},
    _supportedDictionaries : {},
    _supportedUints: {},
    _supportedDoubles: {},
    _supportedDates: {},
    _supportedTimes: {},
    _supportedDateRanges: {},
    _supportedNotRegexString: {},
    _testObjectMetaInformation: {},

    /*jshint eqnull:true */
    getPropertiesNames : function(sdkObject){
        if (!sdkObject || !sdkObject._behaviors)
            return null;

        var properties = {};
        //calculate a unique list of properties names from all behaviors
        sdkObject._behaviors.forEach(function (behavior) {
            if(behavior._properties == null) {
                return;
            }

            Object.keys(behavior._properties).forEach(function (behaviorProperty) {
               properties[behaviorProperty] = true;
            });
        }, this);

        return Object.keys(properties).filter(function(prop){
            return sdkObject[prop];
        });
    },

    // returns string[] - listof leanFT names of properties that are only in the description and not in the test object.
    getDescritptionOnlyProperties: function(leanFtType) {
        return this._testObjectMetaInformation[leanFtType.technology]
        [leanFtType.leanftType].descriptionOnlyProperties;
    },


    /*jshint eqnull:true */
    addPropertyWithEnum: function(testObject, propertyName, enumObject){
        this._addPropertyWithType(this._supportedEnums, testObject, propertyName, enumObject);
    },

    addPropertyWithDictionary: function(testObject, propertyName){
        this._addPropertyWithType(this._supportedDictionaries, testObject, propertyName, true);
    },

    addPropertyWithUint: function(testObject, propertyName){
        this._addPropertyWithType(this._supportedUints, testObject, propertyName, true);
    },

    addPropertyWithDouble: function(testObject, propertyName){
        this._addPropertyWithType(this._supportedDoubles, testObject, propertyName, true);
    },

    addPropertyWithDate: function(testObject, propertyName){
        this._addPropertyWithType(this._supportedDates, testObject, propertyName, true);
    },

    addPropertyWithTime: function(testObject, propertyName){
        this._addPropertyWithType(this._supportedTimes, testObject, propertyName, true);
    },

    addPropertyWithDateRange: function(testObject, propertyName){
        this._addPropertyWithType(this._supportedDateRanges, testObject, propertyName, true);
    },

    addPropertyWithNotRegexString: function(testObject, propertyName){
        this._addPropertyWithType(this._supportedNotRegexString, testObject, propertyName, true);
    },

    isEnumValue:function(propertyName, testObject){
        var enumObject = this._isTypeValue(this._supportedEnums, propertyName, testObject);

        // remove private methods for enums
        if (enumObject && enumObject.values) {
            var enumObjectCopy = ObjectUtils.clone(enumObject);
            var values = {};
            Object.keys(enumObject.values).forEach(function(prop) {
                if (!prop.startsWith("_")) {
                    values[prop] = enumObject.values[prop];
                }
            });

            enumObjectCopy.values = values;
            return enumObjectCopy;
        }

        return enumObject;
    },

    isDictionaryValue:function(propertyName, testObject){
        return this._isTypeValue(this._supportedDictionaries, propertyName, testObject);
    },

	isDateValue:function(propertyName, testObject){
        return this._isTypeValue(this._supportedDates, propertyName, testObject);
    },

    isTimeValue:function(propertyName, testObject){
        return this._isTypeValue(this._supportedTimes, propertyName, testObject);
    },

    isDateRangeValue:function(propertyName, testObject){
        return this._isTypeValue(this._supportedDateRanges, propertyName, testObject);
    },

    isUintValue:function(propertyName, testObject){
        return this._isTypeValue(this._supportedUints, propertyName, testObject);
    },

    isDoubleValue:function(propertyName, testObject){
        return this._isTypeValue(this._supportedDoubles, propertyName, testObject);
    },

    isNotRegexStringValue:function(propertyName, testObject){
        return this._isTypeValue(this._supportedNotRegexString, propertyName, testObject);
    },

    _addPropertyWithType: function (supportedTypeCache, testObject, propertyName, value) {
        if (testObject == null || testObject._description == null)
            return;

        var technology = testObject._description.leanFTType.technology;
        var leanftType = testObject._description.leanFTType.leanftType;

        if (supportedTypeCache[technology] == null)
            supportedTypeCache[technology] = {};

        if (supportedTypeCache[technology][leanftType] == null)
            supportedTypeCache[technology][leanftType] = {};

        supportedTypeCache[technology][leanftType][propertyName] = value;
    },

    _isTypeValue:function(supportedTypeCache, propertyName, testObject){
        if (testObject == null || testObject._description == null)
            return;

        var technology = testObject._description.leanFTType.technology;
        var leanftType = testObject._description.leanFTType.leanftType;

        if (!supportedTypeCache[technology] || !supportedTypeCache[technology][leanftType])
            return null;

        return supportedTypeCache[technology][leanftType][propertyName] || null;
    },

    getSdkToWiredPropsTranslation: function (leanftType, propsToTranslate) {
        return TypeRegistry._getSdkToWiredPropsWithFilter(leanftType, propsToTranslate, "leanFtToWired");
    },

    getSdkToWiredDescPropsTranslation: function (leanftType, propsToTranslate) {
        return TypeRegistry._getSdkToWiredPropsWithFilter(leanftType, propsToTranslate, "leanFtToWired",
            function (propInfo) { return !propInfo.nonDescribable; });
    },

    /*jshint eqnull:true */
    _getSdkToWiredPropsWithFilter: function (leanftType, propsToTranslate, specialTranslatorKey, propsFilter) {
        if(propsToTranslate == null) {
            return null;
        }

        if(typeof propsToTranslate === 'string') {
            propsToTranslate = [propsToTranslate];
        }

        if(propsFilter == null) {
            propsFilter = function () { return true; };
        }

        var table = TypeRegistry._getSdkToWiredPropsTranslationTable(leanftType);

        return propsToTranslate.map(function(propToTranslate) {
            var propertyInfo = table[propToTranslate];

            if(propertyInfo) {
                return propsFilter(propertyInfo)? propertyInfo.wiredName : undefined;
            }

            //check if special
            var specialTranslation = this._tryTranslateSpecial(leanftType, specialTranslatorKey, propToTranslate);

            return specialTranslation.isSpecial ?
                specialTranslation.result : undefined;
        }, this);
    },

    _getSdkToWiredPropsTranslationTable: function(leanFtType) {
        return this._testObjectMetaInformation[leanFtType.technology]
            [leanFtType.leanftType].sdkToWiredPropsTable;
    },

    getWiredToSdkPropsTranslation: function (leanftType, propsToTranslate) {
        return TypeRegistry._getWiredToSdkPropsWithFilter(leanftType, propsToTranslate, "wiredToLeanFt");
    },

    getWiredToSdkDescPropsTranslation: function (leanftType, propsToTranslate) {
        return TypeRegistry._getWiredToSdkPropsWithFilter(leanftType, propsToTranslate, "wiredToLeanFt",
            function (propInfo) { return !propInfo.nonDescribable; });
    },

    /*jshint eqnull:true */
    _getWiredToSdkPropsWithFilter: function (leanftType, propsToTranslate, specialTranslatorKey, propsFilter) {
        if(propsToTranslate == null) {
            return null;
        }

        if(typeof propsToTranslate === 'string') {
            propsToTranslate = [propsToTranslate];
        }

        if(propsFilter == null) {
            propsFilter = function () { return true; };
        }

        var sdkToWiredTable = TypeRegistry._getSdkToWiredPropsTranslationTable(leanftType);

        var wiredToSdkTable = {};

        //reverse table and toLower wiredNames
        for(var key in sdkToWiredTable){
            var wiredName = sdkToWiredTable[key].wiredName.toLowerCase();

            wiredToSdkTable[wiredName] = {
                sdkName: key,
                filterResult: propsFilter(sdkToWiredTable[key])
            };
        }

        var additionalWiredToSdkPropsTable = this._testObjectMetaInformation[leanftType.technology]
            [leanftType.leanftType].additionalWiredToSdkPropsTable;

        Object.keys(additionalWiredToSdkPropsTable).forEach(function (additionalProp) {
            var propInfo = additionalWiredToSdkPropsTable[additionalProp];
            wiredToSdkTable[additionalProp] = {
                sdkName: propInfo.sdkName,
                filterResult: propsFilter(propInfo)
            };
        });

        return propsToTranslate.map(function (propToTranslate) {
            var translatedProp = wiredToSdkTable[propToTranslate.toLowerCase()];
            if (translatedProp) {
                return translatedProp.filterResult ? translatedProp.sdkName : undefined;
            }

            //check if special
            var specialTranslation = this._tryTranslateSpecial(leanftType, specialTranslatorKey, propToTranslate);

            return specialTranslation.isSpecial ?
                specialTranslation.result : undefined;
        }, this);
    },

    _tryTranslateSpecial: function (leanFtType, specialTranslatorKey, propToTranslate) {
        var allSpecialTranslators =  this._testObjectMetaInformation[leanFtType.technology]
            [leanFtType.leanftType].specialTranslators;

        var relevantSpecialTranslators = Object.keys(allSpecialTranslators)
            .map(function (specialTranslatorName) {
                return allSpecialTranslators[specialTranslatorName][specialTranslatorKey];
            }).filter(function (relevantSpecialTranslator) {
                return relevantSpecialTranslator; //filter out undefined
            });

        for(var i=0; i<relevantSpecialTranslators.length; i++) {
            var translator = relevantSpecialTranslators[i];
            if(translator.isSpecial(propToTranslate)) {
                return {
                    isSpecial: true,
                    result: translator.translate(propToTranslate)
                };
            }
        }

        return {
            isSpecial: false
        };
    },

    _registerTestObjectMetaInfo: function (testObject) {
        var leanFtType = testObject._description.leanFTType;

        if(!this._testObjectMetaInformation[leanFtType.technology]) {
            this._testObjectMetaInformation[leanFtType.technology] = {};
        }

        //extract meta data
        this._testObjectMetaInformation[leanFtType.technology]
            [leanFtType.leanftType] =
            this._extractMetaDataFromTestObject(testObject);
    },

    _extractMetaDataFromTestObject: function(testObject) {
        var behaviors = testObject._behaviors;

        var metaData = {
            sdkToWiredPropsTable: {},
            additionalWiredToSdkPropsTable: {},
            specialTranslators: {},
            sdkToWiredMethodsTable: {},
            descriptionOnlyProperties: {}
        };

        behaviors.forEach(function (behavior) {
            //handle properties and additional properties meta data
            var properties = behavior._properties;
            var additionalProperties = behavior._additionalProperties;

            this._getSdkToWiredTranslationHelper(metaData.sdkToWiredPropsTable, metaData.specialTranslators, undefined, properties, testObject._description);
            this._getSdkToWiredTranslationHelper(metaData.sdkToWiredPropsTable, metaData.specialTranslators, undefined, additionalProperties);

            //handle additional wired properties meta data
            var additionalWiredToSdkProps = behavior._additionalNativeProperties;

            if(additionalWiredToSdkProps) {
                Object.keys(additionalWiredToSdkProps).forEach(function (wiredProp) {
                    metaData.additionalWiredToSdkPropsTable[wiredProp.toLowerCase()] =
                        additionalWiredToSdkProps[wiredProp];
                });
            }

            this._getSdkToWiredMethodTranslationHelper(metaData.sdkToWiredMethodsTable, behavior._methods);
            metaData.descriptionOnlyProperties = Object.keys(testObject._description).filter(function(propName){
                // Filter out private members of the description
                if (propName === "leanFTType" || propName[0] === "_") {
                    return false;
                }

                // Filter out properties that are in the test object
                if (testObject[propName]) {
                        return false;
                }
                
                return true;
            });
        }, this);

        return metaData;
    },

    _getSdkToWiredTranslationHelper: function (table, specialTranslators, prefix, properties, describableProperties) {
        if (!properties) {
            return;
        }

        Object.keys(properties).forEach(function (property) {
            var propertyValue = properties[property];
            var adjustPropName = StringUtils.trimLeft(property, "_");
            var tableEntry = prefix ? prefix + "." + adjustPropName : adjustPropName;

            if (propertyValue.nonTranslatable) {
                //delete it from table in case it is an override
                delete table[tableEntry];
                return;
            }

            if(propertyValue.specialTranslator) {
                specialTranslators[adjustPropName] = propertyValue.specialTranslator;
            }

            if (propertyValue.type === 'grouped') {
                var groupedTransTable = propertyValue.properties;

                //if grouped property is not describable then all inner properties should be nonDescribable
                //otherwise, all should be describable.
                var groupedDescribableProperties = describableProperties && (!describableProperties[adjustPropName]) ?
                    {} : undefined;

                this._getSdkToWiredTranslationHelper(table, specialTranslators, property, groupedTransTable, groupedDescribableProperties);
            } else {
                
                var propMetaInfo = ObjectUtils.clone(propertyValue);
                propMetaInfo.onlyDescribable = property[0] === "_";
                if(describableProperties) {
                    if(!describableProperties[adjustPropName]) {
                        propMetaInfo.nonDescribable = true;
                    }
                }

                table[tableEntry] = propMetaInfo;

            }
        }, this);
    },

    /*jshint eqnull:true */
    _getSdkToWiredMethodTranslationHelper: function (sdkToWiredMethodsTable, behaviorMethods) {
        if(behaviorMethods == null) {
            return;
        }

        Object.keys(behaviorMethods).forEach(function (methodName) {
            sdkToWiredMethodsTable[methodName] = ObjectUtils.clone(behaviorMethods[methodName]);
        });
    },

    /*jshint eqnull:true */
    getSdkToWiredMethodTranslation: function (leanFtType, methodsToTranslate) {
        if(methodsToTranslate == null) {
            return null;
        }

        if(typeof methodsToTranslate === 'string') {
            methodsToTranslate = [methodsToTranslate];
        }

        var table = this._testObjectMetaInformation[leanFtType.technology]
            [leanFtType.leanftType].sdkToWiredMethodsTable;

        return methodsToTranslate.map(function (methodToTranslate) {
           return table[methodToTranslate]? table[methodToTranslate].wiredName : undefined;
        });
    }
};


module.exports.TypeRegistry = TypeRegistry;
