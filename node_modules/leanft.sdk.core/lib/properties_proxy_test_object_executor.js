// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
var ArrayUtils = require("./object_utils.js").ArrayUtils;
var ObjectUtils = require("./object_utils.js").ObjectUtils;
var Q = require("q");
var Logger = require("./logger.js").Logger;

/*jshint eqnull:true */
function PropertiesProxyTestObjectExecutor(executorToWrap, properties, runTimeAccessMode){
    this._executorToWrap = executorToWrap;
    this._runTimeAccessMode = runTimeAccessMode;
    this._session = executorToWrap._session;
    var propertiesToSave = {};
    if (properties) {
        Object.keys(properties).forEach(function(propName){
            propertiesToSave[propName.toLowerCase()] = properties[propName];
        });
    }
    this._properties = propertiesToSave;
    this._logger = new Logger("PropertiesProxyTestObjectExecutor");
}

PropertiesProxyTestObjectExecutor.prototype = {
    _session: null,
    _logger: null,

    /**
     * Handles all execution requests to engine with caching.
     * The method will try to retrieve the property/properties from cache first, if not value/s won't exist - default
     * executor will be invoked
     * @param {string} methodName
     * @returns Promise
     * @private
     * @ignore
     */
    /*jshint eqnull:true */
    executeCommand: function(methodName) {
        var handler = this._supportedFuncs[methodName];

        // use default execution in case method is not handled
        if (!handler) {
            return this._executeDefault(arguments);
        }

        //removes the first argument since it is the methodName
        var result = null;
        var args = ArrayUtils.toArray(arguments);
        args.splice(0, 1);

        // verify that value is cached
        if (handler.verify.apply(this, args)) {
            result = handler.handle.apply(this, args);

            this._logger.debug("Retrieving values from cache for '" + methodName +"' method");
            // generate promise with result
            return this._session._promiseManager.syncedBranchThen(function () {
                return result;
            });
        }

        // if property/properties are not exist - use the default execution
        return this._executeDefault(arguments);
    },

    _executeDefault: function (args) {
        if (this._runTimeAccessMode == RuntimeAccessMode.accessOnUnknownOperationOrProperty){
            this._logger.debug("Calling to default executeCommand for '" + args[0] +"' method");
            return this._executorToWrap.executeCommand.apply(this._executorToWrap, args);
        }

        return this._session._promiseManager.syncedBranchThen(function () {
            return null;
        });
    },

    _countOfArgsExceptAdditionalFunc: function (args) {
        if (typeof(args[args.length-1]) === 'function')
            return args.length-1;

        return args.length;
    },

    _supportedFuncs: {
        /*jshint eqnull:true */
        GetROProperty: {
            verify: function (propName) {
                var lowerCasePropName = propName.toLowerCase();
                // verification method - the args length should be 2 - the second value is additional method func for the executor
                return ((lowerCasePropName in this._properties) && this._countOfArgsExceptAdditionalFunc(arguments) === 1);
            },
            handle: function (propName) {
                var lowerCasePropName = propName.toLowerCase();
                return this._properties[lowerCasePropName];
            }
        },

        /*jshint eqnull:true */
        GetROProperties: {
            verify: function (propNames) {
                return propNames.every(function(propName){
                    return this._supportedFuncs.GetROProperty.verify.call(this, propName);
                }, this);
            },
            handle: function (propNames) {
                return propNames.map(this._supportedFuncs.GetROProperty.handle, this);
            }
        }
    }
};

var RuntimeAccessMode = {
    /**
     * always access the runtime.
     */
    noProxy: 'noProxy',

    /**
     * access the runtime for unknown operations or properties.
     */
    accessOnUnknownOperationOrProperty: 'accessOnUnknownOperationOrProperty',

    /**
     * never access the runtime
     */
    neverAccess: 'neverAccess'
};


module.exports.PropertiesProxyTestObjectExecutor = PropertiesProxyTestObjectExecutor;
module.exports.RuntimeAccessMode = RuntimeAccessMode;