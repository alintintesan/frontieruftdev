// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

//Created on 06/10/2015.

/** @private */
var Logger = require("./logger.js").Logger;
/** @private */
var WebSocket = require('ws');

/**
 * The web socket client communication channel that is used in order to communicate with the
 * LeanFT runtime engine.
 * @param address
 * @param {object} {options} [options = null] options for the channel.
 * @param {number} {options.httpUpgradeHeaders} Object with key-value pair of headers to be sent in the http upgrade request headers
 * @constructor
 * @ignore
 */
function WSCommunicationChannel(address, options){
    this._logger = new Logger("WSCommunicationChannel");
    if(address === null){
        throw new Error("address cannot be null it needs to be in URI format");
    }
    this._address = address;
    this._httpUpgradeHeaders = options ? options.httpUpgradeHeaders : undefined;
    this._init();
}

/**
 * @ignore
 */
WSCommunicationChannel.prototype = {
    _logger: null,
    _address: null,
    _httpUpgradeHeaders : null,
    _socket: null,
    _nextMessageID: 0,
    _pendingRequests: null,
    _disconnectedStatus: -50,

    /*********** Events ****/
    onConnect: null,
    onMessage: null,
    onDisconnect: null,

    /*********** Public Methods *******/

    /**
    * Sets the events for this web socket.
    * @memberof WSCommunicationChannel
    * @instance
    * @function connect
    */
    connect: function(){
        this._logger.info("init: Going to connect to " + this._address);
        if(this._socket !== null){
            this._logger.warn("connect: Called for already connected channel, ignoring");
            return;
        }

        this._socket = new WebSocket(this._address, {headers : this._httpUpgradeHeaders});
        this._socket.on('open', this._onConnect.bind(this));
        this._socket.on('error', this._onError.bind(this));
        this._socket.on('message', this._onMessage.bind(this));
        this._socket.on('close', this._onClose.bind(this));
    },

    send: function(msgToSend,callback){
        this._logger.trace("send: Started");

        var msgId = ++WSCommunicationChannel.prototype._nextMessageID;
        var msg = this._prepareMessage("request", msgId, msgToSend);

        this._pendingRequests[msgId] = callback;
        var msgString = JSON.stringify(msg);
        this._logger.trace("send: Going to send the following message: \n" + msgString);

        if(this._socket == null) {
            delete this._pendingRequests[msgId];
            callback({
                status: this._disconnectedStatus,
                data: {
                    ErrorMessage: "Not connected to server"
                }
            });
            return;
        }

        this._socket.send(msgString);
        return msgId;
    },

    notify: function (msgToSend) {
        this._logger.trace("notify: Started");

        var msgId = ++WSCommunicationChannel.prototype._nextMessageID;
        var msg = this._prepareMessage("voidRequest", msgId, msgToSend);

        var msgString = JSON.stringify(msg);
        this._logger.trace("notify: Going to notify the following message: \n" + msgString);

        if(this._socket == null) {
            callback({
                status: this._disconnectedStatus,
                data: {
                    ErrorMessage: "Not connected to server"
                }
            });
            return;
        }

        this._socket.send(msgString);
    },

    disconnect: function(){
      this._logger.info("disconnect: Called");
      this._cleanPendingRequests();
      if(this._socket) {
          this._socket.close();
          this._socket = null;
      }
    },

    /******** Private Methods *******/
    _init: function () {
        this._socket = null;
        this._pendingRequests = [];
    },

    _handleResponse: function(msg){
        this._logger.trace("WSCommunicationChannel._handleResponse: Got the following response -", msg);

        var msgId = msg.uid;

        var responseCallback = this._pendingRequests[msgId];
        if(!responseCallback){
            this._logger.error("WSCommunicationChannel._handleResponse: The response is for a message that was not sent", msgId, ", ignoring it. message:", msg);
            return;
        }

        delete this._pendingRequests[msgId];

        var msgPaylod = msg.data && msg.data.data;
        if (!msgPaylod) {
            this._logger.error("WSCommunicationChannel._handleResponse: unable to find message payload on response:", msg);
            /* Do not return though */
        }

        try {
            responseCallback(msgPaylod);
        }
        catch(e) {
            this._logger.error("WSCommunicationChannel._handleResponse: Error handling response ", e);
        }
    },

    /*jshint eqnull:true */
    _handleRequest: function(msg){
        var reqId = msg.uid;
        if(this.onMessage)
            this.onMessage(msg.data, this._sendResponseCB.bind(this, reqId));
        else
            this._logger.warn("no onMessage handler is set, message ignored");
    },

    _handleEvent: function(msg) {
        if(this.onMessage)
            this.onMessage(msg.data, function(){});
        else
            this._logger.warn("no onMessage handler is set, message ignored");
    },

    _onError: function(){
        this._logger.info("_onError: Got error while trying to connect to " + this._address);
    },

    _onConnect: function(){
        this._logger.info("_onConnect: Got connection to " + this._address + " Going to send open a new session");

        //Checks if someone is listening on the event and notifies them.
        if(this.onConnect)
            this.onConnect();
    },

    _onMessage: function(msgString){
        var msg = JSON.parse(msgString);
        switch (msg.type){
            case "response":
                this._handleResponse(msg);
                break;
            case "voidRequest":
                this._handleEvent(msg);
                break;
            case "request":
                this._handleRequest(msg);
                break;
            default :
                this._logger.error("_onMessage: Got message type that is not supported " + msg.type);
                return;
        }
    },

    _onClose: function(){
        this._logger.info("_onClose: Disconnected from " + this._address);
        this._cleanPendingRequests();
        this._address = null;
        this._init();
        if(this.onDisconnect)
            this.onDisconnect(this);
    },

    _prepareMessage: function(type, uid, msgData) {
        return {
            uid: uid,
            type: type,
            data: {
                format: "LeanFT",
                version: "1",
                agentType: "leanFTClient",
                data: msgData
            }
        };
    },

    _sendResponseCB: function (uid, msgData) {
        var msg = this._prepareMessage("response", uid, msgData);

        var msgString = JSON.stringify(msg);
        this._logger.trace("send: Going to send the following message: \n" + msgString);

        this._socket.send(msgString);
    },

    _cleanPendingRequests: function () {
        this._logger.info("_cleanPendingRequests: Called");
        var awaitingRequests = this._pendingRequests.filter(function (x) { return x; });
        this._pendingRequests = [];
        if (awaitingRequests.length > 0) {
            this._logger.info("_cleanPendingRequests: Still have pending requests going to notify an error");
            awaitingRequests.forEach(function (request) {
                try {
                    if(request) {
                        request({
                            status: this._disconnectedStatus,
                            data: {
                                ErrorMessage: "disconnected from server"
                            }
                        });
                    }
                }
                catch (e) {
                    this._logger.warn("_cleanPendingRequests: Got exception calling error callback ", e);
                }
            }, this);
        }
    }
};

module.exports.WSCommunicationChannel = WSCommunicationChannel;