// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * This file contains helper utility objects
 */

/** @private */
var ArrayUtils = require("./object_utils.js").ArrayUtils;
var ObjectUtils = require("./object_utils.js").ObjectUtils;
var ReplayErrorsBehavior = require("./replay_errors.js");
var RectangleUtils = require("./helper_utils.js").RectangleUtils;
var Logger = require("./logger.js").Logger;
var TestObjectUtilsBehavior = require("./testobject_base.js").TestObjectUtilsBehavior;
var Convert = require("./convert.js").Convert;

/**
 * ImageUtils namespace
 * @namespace ImageUtils
 */

/**
 * An ImageUtils class for image utilities, such as OCR, image comparisons, and image find operations.
 * @class ImageUtils
 * @memberof ImageUtils
 */

/**
 * Constructor method that is called by the factory.
 * @param {Session} session The session to which the constructed object belongs.
 * @returns {ImageUtils}
 * @constructor
 * @private
 */
function ImageUtils(session){
    this._logger = new Logger("ImageUtils");
    if(session === null){
        throw  new Error("The communication channel is mandatory for creating ImageUtils");
    }

    this._session = session;
    ObjectUtils.extend(this, ReplayErrorsBehavior);
}


ImageUtils.prototype = {
    _logger: null,
    _session: null,

    _executeUtilityCommand: function(commandType, methodName){
        // Remove the first two arguments since they are the command type and methodName
        var args = ArrayUtils.toArray(arguments);
        args.splice(0,2);

        var msg = {
            type: commandType,
            Operation: methodName,
            Parameters: args
        };

        return this._session._communication.send("ExecuteUtilityObjectCommand",msg).then(function(data) {
            if(!data) //we expect to receive an object here
                return null;

            return TestObjectUtilsBehavior._getResultValue(data.Result);
        }.bind(this), this.handleReplayError.bind(this));
    },

    /*jshint eqnull:true */
    /**
     * Returns all text within the supplied image.
     * @param {string} image A Base64 string representation of the image to use for the search.
     * @param {Object} [textArea] An inner rectangle within the image.
     * @returns {Promise<string>} a promise that is fulfilled with all the visible text from the image.
     * @memberof ImageUtils.ImageUtils#
     */
    getText: function(image, textArea){
        if (image == null)
            throw new Error("image parameter must be supplied");

        var rect = RectangleUtils.getRectangleOrDefault(textArea);
        return this._executeUtilityCommand("ExecuteOcrCommand", "GetTestObjectVisibleTextFromBase64Bitmap", image, rect._left, rect._top, rect._right, rect._bottom);
    },

    /*jshint eqnull:true */
    /**
     * Returns all rectangular areas within the supplied image that contain the specified text.
     * @param {string} image A Base64 string representation of the image to use for the search.
     * @param {string} textToFind The text to search for in the test object.
     * @param {Object} [rectangle] An inner rectangle within the image.
     * @returns {Promise<Object>} a promise that is fulfilled with rectangles array containing all rectangular areas containing the specified text within this image.
     * @memberof ImageUtils.ImageUtils#
     */
    locateText: function(image, textToFind, rectangle){
        if (image == null)
            throw new Error("image parameter must be supplied");
        if (textToFind == null)
            throw new Error("textToFind parameter must be supplied");

        var rect = RectangleUtils.getRectangleOrDefault(rectangle);
        return this._executeUtilityCommand("ExecuteOcrCommand", "GetTestObjectTextLocationsFromBase64Bitmap", image, textToFind, rect._left, rect._top, rect._right, rect._bottom).then(function(rectanglesArray){
            if (rectanglesArray!==null) {
                return RectangleUtils.convertNumArrayToRectArray(rectanglesArray);
            }
            return null;
        });
    },

    /*jshint eqnull:true */
    /**
     * Locates an image inside the provided source image.
     * @param {string} sourceImage A Base64 string representation of the source image to check.
     * @param {string} imageToFind A Base64 string representation of the image to locate within the sourceImage.
     * @param {number} [similarity] The minimum similarity between the two images (as a percentage), above which the find is considered a match. Default = 100.
     * @returns {Promise<Object>} a promise that is fulfilled with an object representing the point where the image was located, or null if it was not found.
     * @memberof ImageUtils.ImageUtils#
     */
    locateImage: function(sourceImage, imageToFind, similarity){
        if (sourceImage == null || typeof(sourceImage) !== 'string')
            throw new Error("sourceImage parameter must be supplied correctly");
        if (imageToFind == null || typeof(imageToFind) !== 'string')
            throw new Error("imageToFind parameter must be supplied correctly");
        if (similarity == null) {
            similarity = 100;
        }
        else {
            similarity = Convert.toNumber(similarity);
            if (similarity < 0 || similarity > 100)
                throw new Error("Similarity value must be between 0 and 100");
        }
        return this._executeUtilityCommand("ExecuteImageCommand", "FindBitmapInBitmap", sourceImage, imageToFind, "").then(function(result){
            if (result!==null) {
                if (result.actualSimilarity < similarity)
                    return null;
                return result.point;
            }
            return null;
        });
    },

    /*jshint eqnull:true */
    /**
     * Returns the first 100 locations of an image inside the source image.
     * If the number of images found exceeds 100 images, a GeneralReplayException is thrown.
     * @param {string} sourceImage A Base64 string representation of the source image to check.
     * @param {string} imageToFind A Base64 string representation of the image to locate within the sourceImage.
     * @param {number} [similarity] The minimum similarity between the two images (as a percentage), above which the find is considered a match. Default = 100.
     * @returns {Promise<Object[]>} a promise that is fulfilled with an array of objects representing the point where the image was located.
     * @memberof ImageUtils.ImageUtils#
     */
    getImageLocations: function(sourceImage, imageToFind, similarity){
        if (sourceImage == null || typeof(sourceImage) !== 'string')
            throw new Error("sourceImage parameter must be supplied correctly");
        if (imageToFind == null || typeof(imageToFind) !== 'string')
            throw new Error("imageToFind parameter must be supplied correctly");
        if (similarity == null) {
            similarity = 100;
        }
        else {
            similarity = Convert.toNumber(similarity);
            if (similarity < 0 || similarity > 100)
                throw new Error("Similarity value must be between 0 and 100");
        }

        return this._executeUtilityCommand("ExecuteImageCommand", "GetImageLocations", sourceImage, imageToFind, similarity);
    },

    /*jshint eqnull:true */
    /**
     * Checks whether two images are a match, given the specified pixel and RGB tolerance values.
     * @param {string} firstImage A Base64 string representation of the expected image.
     * @param {string} secondImage A Base64 string representation of the image to compare to the expected image.
     * @param {number} [pixelTolerance] The percentage of pixels that can differ between the two images, and still be considered a match. Default = 0.
     * @param {number} [rgbTolerance] The percent by which the RGB values of the pixels in the two images can differ, and still be considered a match. Default = 0.
     * @returns {Promise<boolean>} a promise that is fulfilled with a boolean indicating if the images match.
     * @memberof ImageUtils.ImageUtils#
     */
    compareImages: function(firstImage, secondImage, pixelTolerance, rgbTolerance){
        return this.compareImagesWithMask(firstImage, secondImage, "", pixelTolerance, rgbTolerance);
    },

    /*jshint eqnull:true */
    /**
     * Checks whether two images are a match, given the mask area image and specified pixel and RGB tolerance values.
     * @param {string} firstImage A Base64 string representation of the expected image.
     * @param {string} secondImage A Base64 string representation of the image to compare to the expected image.
     * @param {string} maskAreaImage A Base64 string representation of the mask area used for the comparison between the expected image and image to compare.
     * This mask area is calculated based on the expected image and should have rectangle areas which specify which part of the image will be included or excluded from the comparison.
     * The rectangle which should include the area in the comparison should be painted with white pixels.
     * The rectangle which should exclude the area in the comparison should be painted with black pixels.
     * If the full image is with white pixels means all the image will be included in the comparison.
     * If the full image is with black pixels means all the image will be excluded in the comparison.
     * @param {number} [pixelTolerance] The percentage of pixels that can differ between the two images, and still be considered a match. Default = 0.
     * @param {number} [rgbTolerance] The percent by which the RGB values of the pixels in the two images can differ, and still be considered a match. Default = 0.
     * @returns {Promise<boolean>} a promise that is fulfilled with a boolean indicating if the images match.
     * @memberof ImageUtils.ImageUtils#
     */
    compareImagesWithMask: function(firstImage, secondImage, maskAreaImage, pixelTolerance, rgbTolerance){
        if (firstImage == null || typeof(firstImage) !== 'string')
            throw new Error("firstImage parameter must be supplied correctly");
        if (secondImage == null || typeof(secondImage) !== 'string')
            throw new Error("secondImage parameter must be supplied correctly");
        if (maskAreaImage == null || typeof(maskAreaImage) !== 'string')
            throw new Error("maskAreaImage parameter must be supplied correctly");
        if (pixelTolerance == null) {
            pixelTolerance = 0;
        }
        else {
            pixelTolerance = Convert.toNumber(pixelTolerance);
            if (pixelTolerance < 0 || pixelTolerance > 100)
                throw new Error("pixelTolerance value must be between 0 and 100");
        }
        if (rgbTolerance == null) {
            rgbTolerance = 0;
        }
        else {
            rgbTolerance = Convert.toNumber(rgbTolerance);
            if (rgbTolerance < 0 || rgbTolerance > 100)
                throw new Error("rgbTolerance value must be between 0 and 100");
        }

        return this._executeUtilityCommand("ExecuteImageCommand", "CompareBase64Bitmaps", firstImage, secondImage, maskAreaImage, pixelTolerance, rgbTolerance).then(function(result){
            if (result!==null)
                return result.imagesMatch;
            else return false;
        });
    }

};

module.exports.ImageUtils = ImageUtils;

