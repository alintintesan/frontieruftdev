// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/* jshint esversion: 6 */

var fs = require('fs');
var util = require('util');
var path = require('path');
var Logger = require('./logger.js').Logger;
var scriptsFolder = path.join(__dirname , "..","scripts");
var iconsFolder = path.join(__dirname , "..","icons");
var extensionsFolder = path.join(__dirname,"..","report_extensions");
var log = new Logger("ReportBuilder");
var loadedFiles = {};
const colors = ["#003366", "#660033","#99ffcc","#6699ff","#336699", "#ccff33","#0099cc", "#33cccc", "#669999","#66ffff","#cc00ff",
"#00ff99","#333399","#666699","#0000ff","#66ffff","#00ff00","#ccccff","#ff66ff","#ffcc99","#ffde00","#999966","#ff3300",
"#993333","#009999","#ff9900","#666633","#990099","#9933ff","#66ff99","#ffcc00","#ffccff","#003300"];



function processConsoleRequest(reqeust) {
    var xmlPath =  reqeust.xmlPath;
    var jsonPath =  reqeust.jsonPath;
    var cssPath =  reqeust.cssPath;
    var htmlPath =  reqeust.htmlPath;

    // check if xml file exist
    var status = fs.existsSync(xmlPath);

    if (status === false) {
        log.error("XML report file could not be found '" + xmlPath +"'");
        process.exit(-2);
    }

    // load xml file
    var xml = fs.readFileSync(xmlPath, 'utf8');

    // generate json file
    var xml2js = require('xml2js');

    xml2js = xml2js.Parser({
        mergeAttrs: 'true', // Merge attributes and child elements as properties of the parent.
        explicitArray: false // Array is created only if there is more than one child element.
    });

    xml2js.parseString(xml, function (err, result) {
        if (err){
            log.error('json file generation failed, error = ' + err );
            process.exit(-1);
        }

        // write the json content to file
        fs.writeFileSync(jsonPath, JSON.stringify(result).replace("Unknown", "Passed"), 'utf-8');

        // populate css files
        populateCssBuilder(result, cssPath);

        // generate the html file
        generateHtmlFile(jsonPath, cssPath, htmlPath);
    });

}

function populateCssBuilder(json, cssPath) {
    var array = ["VerifySuccess", "VerifyFailure", "VerificationRegion"];
    var iconKeys = getIconFromJson(json, array);

    fs.writeFileSync(cssPath, iconKeys.map(getEmbeddedIconStyle).join(""));
}


function getEmbeddedIconStyle(iconKey) {
    if (!iconKey) {
        return;
    }

    // convert icon to base64 string
    var iconPath = path.join(iconsFolder, iconKey + '.png');
    var iconBase64Str = base64_encode(iconPath);

    if (!iconBase64Str && iconKey !== 'Run' && iconKey !== 'Spec'&& iconKey !== 'Suite' &&
        iconKey !== 'RunTimeError') {
        log.error("Failed to add embedded icon due to the failure of converting Icon object to base64 string. Icon key: " + iconKey);
    }

    // create embedded icon style
    var cssStyle = getEmbeddedIconCssStyle(iconKey, iconBase64Str, 16, 16);

    //  add cssStyle to dictionary
    return cssStyle;
}


function getEmbeddedIconCssStyle(iconKey, iconBase64String, iconWidth, iconHeight) {
    // create embedded icon style
    // .c-icon-xxx {
    //    width: ???px;
    //    height: ???px;
    //    background-image: url('data:image/png;base64,?????');
    // }
    return util.format(".c-icon-%s{width:%spx;height:%spx;background-image:url('data:image/png;base64,%s');}",
        iconKey, iconWidth, iconHeight, iconBase64String);
}


function generateHtmlFile(jsonFile, cssFile, resultFile, vitalsPath) {

    var htmlContent = "";
    htmlContent += "<!DOCTYPE html><html style='margin: 0;padding: 0;height: 100%;width: 100%;'><head>";

    // encoding
    htmlContent += "<meta http-equiv='X-UA-Compatible' content='IE=Edge'/>";

    // html revised
    htmlContent += util.format("<meta name='revised' content='%s' />", "12.52.11.22");

    // title
    htmlContent += util.format("<title>%s</title>", "Report");

    // styles (start)
    htmlContent += "<style>";

    // styles - style.css
    htmlContent += getFile(path.join(scriptsFolder, 'style.min-dyn.css'));
    
     // styles - themes css
    htmlContent += getFile(path.join(scriptsFolder, 'themes','dark.min-dyn.css'));
    
    // styles - nv_d3.css
    htmlContent += getFile(path.join(scriptsFolder, 'nv_d3.min.css'));

    // styles - ext.css
    htmlContent += getFile(path.join(extensionsFolder,'extStyles.css'));

    if (cssFile) {
        var dynCSSString = fs.readFileSync(cssFile);

        if (dynCSSString) {
            htmlContent += dynCSSString;
        }
    }

    htmlContent += "</style><script>";

    if (jsonFile) {
        var dynJSONString = fs.readFileSync(jsonFile);


        if (dynJSONString) {
            var dynJSStr = util.format("var %s=%s;", "resultDynData", dynJSONString);
            htmlContent += dynJSStr;
        }
    }

    if(fs.existsSync(vitalsPath)){
        var vitals = fs.readdirSync(vitalsPath);
        if(vitals.length > 0){
            var monitorData = getMonitorData("Mobile Device Vitals", vitalsPath, vitals);

            htmlContent += "\n" + util.format("var %s=%s;", "monitorData", JSON.stringify(monitorData)) + "\n";
        }
    }

    var directoryName = scriptsFolder;

    var resDyncFile = fs.readFileSync(path.join(directoryName,"res.min-dyn.js"), 'utf8');

    if (resDyncFile.charCodeAt(0) === 0xFEFF){
        resDyncFile = resDyncFile.slice(1);
    }

    htmlContent += resDyncFile;

    loadedFiles["res.min-dyn.js"] = true;

    htmlContent += appendAllFiles(directoryName);
    
    //append the theme js
    var themeFile = fs.readFileSync(path.join(directoryName,"themes","theme_loader.min.js"), 'utf8');
    if (themeFile.charCodeAt(0) === 0xFEFF){
        themeFile = themeFile.slice(1);
    }
    htmlContent += themeFile;
    
    htmlContent += fs.readFileSync(path.join(extensionsFolder,'extMain.js'), 'utf8');

    // scripts (end)
    htmlContent += "</script>";

    // end of html content
    htmlContent += "</head><body><div style='display:none;'><div id='system_monitor' class='tab-pane'></div></div></body></html>";
    
    //writting the content of the file in UTF-8 with BOM.
    fs.writeFileSync(resultFile,"\uFEFF" + htmlContent, 'utf8');
}

function getFile(filePath){
	var fileContent = fs.readFileSync(filePath, 'utf8');
	if (fileContent.charCodeAt(0) === 0xFEFF){
        fileContent = fileContent.slice(1);
    }
	
	return fileContent;
}

function appendAllFiles(directory){
    var htmlContent = "";
    var files = fs.readdirSync(directory);

    for(var i=0; i<files.length; i++){
        var file = files[i];
        if (!endsWith(file, ".js")) {
            continue;
        }

        if (loadedFiles[file]){
            continue;
        }

        file = fs.readFileSync(path.join(directory,file), 'utf8');

        if (file.charCodeAt(0) === 0xFEFF){
            file = file.slice(1);
        }

        htmlContent += file;
        loadedFiles[file] = true;
    }

    return htmlContent.replace(/[\u200B-\u200D\uFEFF]/g, '');
}

function endsWith(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

// function to encode file data to base64 encoded string
function base64_encode(file) {
    try {

        if (!fs.existsSync(file)){
            return null;
        }
        // read binary data
        var bitmap = fs.readFileSync(file);
        // convert binary data to base64 encoded string
        return new Buffer(bitmap).toString('base64');
    }
    catch(error){
        log.error("base64 encode failed + ", error);
        return null;
    }
}

function getIconFromJson(obj, array){
    var icon = null;
    for (var k in obj) {
        // check if the value is object and it's not null
        if (typeof obj[k] == "object" && obj[k] !== null) {
            // check if the extension property exist with the IconKey value
            if (obj[k].Extension && obj[k].Extension.Any && obj[k].Extension.Any.IconKey) {
                icon = obj[k].Extension.Any.IconKey;

                // if icon doesn't exist - add to array
                if (array.indexOf(icon) === -1) {
                    array.push(icon);
                }
            }

            if (obj[k].Extension && obj[k].Extension.Any && obj[k].Extension.Any.Descriptive && obj[k].Extension.Any.Descriptive.TestObject && obj[k].Extension.Any.Descriptive.TestObject.Path.Object) {
                var testObjectPath = obj[k].Extension.Any.Descriptive.TestObject.Path.Object;

                for (var i=0; i<testObjectPath.length; i++){
                    icon = testObjectPath[i].IconKey;

                    // if icon doesn't exist - add to array
                    if (array.indexOf(icon) === -1) {
                        array.push(icon);
                    }
                }
            }

            getIconFromJson(obj[k], array);
        }
    }
    return array;
}

function buildReport(files, result) {
    loadedFiles = {};
    var xmlPath =  files.xmlPath;

    // console mode
    if (xmlPath){
        processConsoleRequest(files);
        return;
    }

    var jsonPath =  files.jsonPath;
    var cssPath =  files.cssPath;
    var htmlPath =  files.htmlPath;
    var vitalsPath = files.vitalsPath;

    // write the json content to file
    fs.writeFileSync(jsonPath, JSON.stringify(result).replace("Unknown", "Passed"), 'utf-8');

    // populate css files
    populateCssBuilder(result, cssPath);

    // generate the html file
    generateHtmlFile(jsonPath, cssPath, htmlPath, vitalsPath);
}

function getMonitorData(application, vitalsPath, files){
    var monitorData = {
        application: application,
        startReplayTime: "",
        runResults: []
    };
    var startReplayTime;

    //Select only the most updated file per device
    var selectedFiles = selectFiles(files);

    selectedFiles.forEach((file, index, arr) => {
        var dataObj = {
            cpu : {
                key: "",
                name: "CPU (in %)",
                values: [],
                color: ""
            },
            memory : {
                key: "",
                name: "Memory (in KB)",
                values: [],
                color: ""
            },
            freememory : {
                key: "",
                name: "Free Memory (in KB)",
                values: [],
                color: ""
            },
            totalmemory : {
                key: "",
                name: "Total Memory (in KB)",
                values: [],
                color: ""
            }
        };

        var lines = fs.readFileSync(path.join(vitalsPath, file), "utf8").split("\n");

        //Assume that the first line's timestamp is the start replay time
        startReplayTime = lines[0].split(" ")[2];
        monitorData.startReplayTime = getDateTimeFromMillis(startReplayTime).toString();

        lines.forEach(line => {
            var tokens = line.split(" ");

            switch(tokens[0].toLowerCase()){
                case "cpu":
                    dataObj.cpu.values.push(createMonitorCoordinate(tokens[2], tokens[1], startReplayTime));
                    break;
                case "memory":
                    dataObj.memory.values.push(createMonitorCoordinate(tokens[2], tokens[1], startReplayTime));
                    break;
                case "freememory":
                    dataObj.freememory.values.push(createMonitorCoordinate(tokens[2], tokens[1], startReplayTime));
                    break;
                case "totalmemory":
                    dataObj.totalmemory.values.push(createMonitorCoordinate(tokens[2], tokens[1], startReplayTime));
                    break;

            }
        });

        for(var name in dataObj){
            if(dataObj[name].values.length > 0) {
                var fileName = arr.length > 1 ? file : null;
                monitorData.runResults.push(getProcessedData(dataObj[name], fileName));
            }
        }
    });

    return monitorData;
}

function selectFiles (files){
    var devices = {};
    var sortedArrayOfFiles = files.sort();

    sortedArrayOfFiles.forEach(file => {
        deviceName = getDeviceNameFromFileName(file);
        devices[deviceName] = file;
    });

    return Object.values(devices);
}

function createMonitorCoordinate (timeStamp, value, startTime){
    return {
        x: (Number(timeStamp) - startTime)/1000,
        y: Number(value)
    };
}

function getMaxValue(arr){
    return arr.map(element => {
        return element.y;
    }).reduce((a, b) => {
        return Math.max(a, b);
    });
}

function getNormalizationExponent(maxValue){
    return Math.log10(maxValue != 0 ? maxValue : 10) != 1 ? Math.log10(maxValue) - 1: 0;
}

function normalizeYaxis(arr, exponent){
    arr.forEach(element => {
        element.y = element.y * Math.pow(10, -exponent);
    });
}

function getKeySuffix(runResult, exponent){
    return runResult.name.concat(" *").concat(Math.pow(10, - exponent));
}

function getDeviceNameFromFileName(fileName){
    return fileName.substring(0, fileName.indexOf("_vitals_"));
}

function getProcessedData(runResult, fileName) {
    var key;
    var exponent = getNormalizationExponent(getMaxValue(runResult.values));
    normalizeYaxis(runResult.values, exponent);

    if (fileName) {
        key = getDeviceNameFromFileName(fileName).concat(" ").concat(getKeySuffix(runResult, exponent));
    } else {
        key = getKeySuffix(runResult, exponent);
    }

    return {
        key: key,
        values: runResult.values,
        color: color.next().value
    };
}

function getDateTimeFromMillis(millis){
    var date = new Date(Number(millis));
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    return date;
}

var color = function* () {
    var i = 0;
    while(true){
        yield colors[i++ % colors.length];
    }
}();


module.exports = buildReport;
