// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 11/23/2022.
 */

var Core = require("leanft.sdk.core");
var Utils = Core.ObjectUtils;
var MergeBehavior = Core.MergeBehavior;

/**
 * Contains values used by {@link UIAPro.WindowPattern} to indicate the window interaction state.
 * @typedef {UIAPro.WindowInteractionState} WindowInteractionState
 * @property {string} running Indicates that the window is running. This does not guarantee that the window is responding or ready for user interaction.
 * @property {string} closing Indicates that the window is closing.
 * @property {string} readyForUserInteraction Indicates that the window is ready for user interaction.
 * @property {string} blockedByModalWindow Indicates that the window is blocked by a modal window.
 * @property {string} notResponding Indicates that the window is not responding.
 * @memberof UIAPro
 */
var WindowInteractionState = {
    /**
     * @type {string}
     */
    running: "running",
    /**
     * @type {string}
     */
    closing: "closing",
    /**
     * @type {string}
     */
    readyForUserInteraction: "readyForUserInteraction",
    /**
     * @type {string}
     */
    blockedByModalWindow: "blockedByModalWindow",
    /**
     * @type {string}
     */
    notResponding: "notResponding",
    /**
     * @ignore
     */
    _convertToUFT: {
        running: 0,
        closing: 1,
        readyForUserInteraction: 2,
        blockedByModalWindow: 3,
        notResponding: 4
    },

    /**
     * @param {UIAPro.WindowInteractionState} state
     * @returns {*}
     * @ignore
     */
    _convert: function (state) {
        return WindowInteractionState._convertToUFT[state];
    }
};

/**
 * Contains values used by {@link UIAPro.WindowPattern} to indicate the window visual state.
 * @typedef {UIAPro.WindowVisualState} WindowVisualState
 * @property {string} normal Specifies that the window is normal (restored).
 * @property {string} maximized Specifies that the window is maximized.
 * @property {string} minimized Specifies that the window is minimized.
 * @memberof UIAPro
 */
var WindowVisualState = {
    /**
     * @type {string}
     */
    normal: "normal",
    /**
     * @type {string}
     */
    maximized: "maximized",
    /**
     * @type {string}
     */
    minimized: "minimized",
    /**
     * @ignore
     */
    _convertToUFT: {
        normal: 0,
        maximized: 1,
        minimized: 2
    },

    /**
     * @param {UIAPro.WindowVisualState} state
     * @returns {*}
     * @ignore
     */
    _convert: function (state) {
        return WindowVisualState._convertToUFT[state];
    }
};

/**
 * The UIA Pro Window pattern.
 * @class WindowPattern
 * @mixes UIAPro.WindowPatternBehavior._properties
 * @mixes UIAPro.WindowPatternBehavior._methods
 * @memberof UIAPro
 */
function WindowPattern(owner) {
    Utils.extend(this, MergeBehavior);
    this._mergeBehavior(WindowPatternBehavior);
    this._owner = owner;
    this._name = WindowPattern.name;
}

WindowPattern.prototype = {
    _owner: null
};

/**
 * The methods and properties of WindowPattern object.
 * @memberof UIAPro
 * @ignore
 */
var WindowPatternBehavior = {
    /**
     * @memberof UIAPro.WindowPatternBehavior
     * @ignore
     */
    _properties: {
        /**
         * Indicates whether the window can be maximized.
         * @function
         * @returns {Promise<boolean>} a promise that is fulfilled with an indication of whether the object can be maximized.
         * @memberof UIAPro.WindowPattern#
         */
        canMaximize: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.CanMaximize();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "canMaximize" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Indicates whether the window can be minimized.
         * @function
         * @returns {Promise<boolean>} a promise that is fulfilled with an indication of whether the object can be minimized.
         * @memberof UIAPro.WindowPattern#
         */
        canMinimize: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.CanMinimize();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "canMinimize" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Indicates whether the UIA Pro element is modal.
         * @function
         * @returns {Promise<boolean>} a promise that is fulfilled with an indication of whether the object is modal.
         * @memberof UIAPro.WindowPattern#
         */
        isModal: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.IsModal();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "isModal" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Indicates whether the UIA Pro element is the topmost element in the z-order.
         * @function
         * @returns {Promise<boolean>} a promise that is fulfilled with an indication of whether the object is the topmost element in the z-order.
         * @memberof UIAPro.WindowPattern#
         */
        isTopMost: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.IsTopMost();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "isTopMost" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Gets the {@link UIAPro.WindowPattern.WindowInteractionState} of the UIA Pro element.
         * @function
         * @returns {Promise<WindowInteractionState>} a promise that is fulfilled with the interaction state value.
         * @memberof UIAPro.WindowPattern#
         */
        getWindowInteractionState: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.GetWindowInteractionState().then(function (result) {
                        return WindowInteractionState._convert(result);
                    });
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "getWindowInteractionState" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Gets the {@link UIAPro.WindowPattern.WindowVisualState} of the UIA Pro element.
         * @function
         * @returns {Promise<boolean>} a promise that is fulfilled with the visual state value.
         * @memberof UIAPro.WindowPattern#
         */
        getWindowVisualState: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.GetWindowVisualState().then(function (result) {
                        return WindowVisualState._convert(result);
                    });
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "getWindowVisualState" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Indicates whether the UIA Pro visual state is {@link UIAPro.WindowPattern.WindowVisualState.maximized}.
         * @function
         * @returns {Promise<void>} a promise that is fulfilled.
         * @memberof UIAPro.WindowPattern#
         */
        isMaximized: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.IsMaximized();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "isMaximized" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Indicates whether the UIA Pro visual state is {@link UIAPro.WindowPattern.WindowVisualState.minimized}.
         * @function
         * @returns {Promise<void>} a promise that is fulfilled.
         * @memberof UIAPro.WindowPattern#
         */
        isMinimized: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.IsMinimized();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "isMinimized" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        }
    },

    /**
     * @memberof UIAPro.WindowPatternBehavior
     * @ignore
     */
    _methods: {
        /**
         * Sets the window visual state to {@link UIAPro.WindowPattern.WindowVisualState.maximized}.
         * @function
         * @returns {Promise<void>} a promise that is fulfilled.
         * @memberof UIAPro.WindowPattern#
         */
        maximize: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.Maximize();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "maximize" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Sets the window visual state to {@link UIAPro.WindowPattern.WindowVisualState.minimized}.
         * @function
         * @returns {Promise<void>} a promise that is fulfilled.
         * @memberof UIAPro.WindowPattern#
         */
        minimize: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.Minimize();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "minimize" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Sets the window visual state to {@link UIAPro.WindowPattern.WindowVisualState.normal}.
         * @function
         * @returns {Promise<void>} a promise that is fulfilled.
         * @memberof UIAPro.WindowPattern#
         */
        restore: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.Restore();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "restore" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Attempts to close the current window.
         * @function
         * @returns {Promise<void>} a promise that is fulfilled.
         * @memberof UIAPro.WindowPattern#
         */
        close: function () {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.Close();
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "close" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        },
        /**
         * Causes the calling code to block for the specified time or until the associated process enters an idle state,
         * whichever completes first.
         * @function
         * @param {number} milliseconds The amount of time, in milliseconds, to wait for the associated process to become idle.
         * @returns {Promise<void>} a promise that is fulfilled.
         * @memberof UIAPro.WindowPattern#
         */
        waitForInputIdle: function (milliseconds) {
            var self = this;
            var caleeArguments = arguments;

            return this._owner._executeCommand(this._name).then(function (pattern) {
                var patternOperation = function () {
                    return pattern.WaitForInputIdle(milliseconds);
                };

                var options = { sender: self._owner, onError: true, calleeArguments: caleeArguments, type: "TestObject", name: "waitForInputIdle" };
                return self._owner.notifyWithEvents(patternOperation, arguments, options);
            });
        }
    }
};

module.exports.WindowPattern = WindowPattern;
module.exports.WindowInteractionState = WindowInteractionState;
module.exports.WindowVisualState = WindowVisualState;