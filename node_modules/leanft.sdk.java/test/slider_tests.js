// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 8/23/2016.
 */

var assert = require("assert");
var sinon = require("sinon");
var SliderOrientation = require("../lib/slider.js").SliderOrientation;
var JavaConvertHelper = require("../lib/ui_object_base.js").JavaConvertHelper;

describe("Slider Description", function () {
    var Slider = require("../lib/slider.js").Slider;
    var sliderDescriptionUnderTest;

    beforeEach(function () {
        sliderDescriptionUnderTest = Slider();
    });

    describe("Constructor", function () {
        it("should assign 'Java' and 'Slider' LeanFT type", function () {
            sliderDescriptionUnderTest = new Slider();
            assert.deepEqual(sliderDescriptionUnderTest.leanFTType, {
                technology: "Java",
                leanftType: "Slider"
            });
        });
    });

    describe("containerAttachedText", function () {
        var containerAttachedText = "some text";
        it("should add 'container attached text' to _properties when value is given", function () {
            sliderDescriptionUnderTest.containerAttachedText(containerAttachedText);
            assert.strictEqual(sliderDescriptionUnderTest._properties["container attached text"], containerAttachedText);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = sliderDescriptionUnderTest.containerAttachedText(containerAttachedText);
            assert.strictEqual(result, sliderDescriptionUnderTest);
        });

        it("should remove 'container attached text' from _properties when value is null", function () {
            sliderDescriptionUnderTest._properties["container attached text"] = containerAttachedText;
            sliderDescriptionUnderTest.containerAttachedText(null);
            assert(!("container attached text" in sliderDescriptionUnderTest._properties));
        });

        it("should return the value of 'container attached text' from _properties when value is not given", function () {
            sliderDescriptionUnderTest._properties["container attached text"] = containerAttachedText;
            var result = sliderDescriptionUnderTest.containerAttachedText();
            assert.strictEqual(result, containerAttachedText);
        });
    });

    describe("orientation", function () {
        Object.keys(SliderOrientation).filter(function (key) {
            return !key.startsWith('_');
        }).forEach(function (key) {
            var javaNativeValue = SliderOrientation._sliderOrientationToJavaNative(key);
            describe(key, function () {
                it("should add 'orientation' to _properties when value is given", function () {
                    sliderDescriptionUnderTest.orientation(key);
                    assert.strictEqual(sliderDescriptionUnderTest._properties["orientation"], javaNativeValue);
                });

                it("should return this - builder pattern when value is given", function () {
                    var result = sliderDescriptionUnderTest.orientation(key);
                    assert.strictEqual(result, sliderDescriptionUnderTest);
                });

                it("should remove 'orientation' from _properties when value is null", function () {
                    sliderDescriptionUnderTest._properties["orientation"] = javaNativeValue;
                    sliderDescriptionUnderTest.orientation(null);
                    assert(!("orientation" in sliderDescriptionUnderTest._properties));
                });

                it("should return the value of 'orientation' from _properties when value is not given", function () {
                    sliderDescriptionUnderTest._properties["orientation"] = javaNativeValue;
                    var result = sliderDescriptionUnderTest.orientation();
                    assert.strictEqual(result, key);
                });
            });
        });

        it("should throw error if the slider type is not supported", function () {
            assert.throws(function () {
                sliderDescriptionUnderTest.orientation("notSupport");
            });
        });
    });

    describe("position", function () {
        var position = 50;
        it("should add 'value' to _properties when value is given", function () {
            sliderDescriptionUnderTest.position(position);
            assert.strictEqual(sliderDescriptionUnderTest._properties["value"], position);
        });

        it("should add 'value' to _properties when value is given in string", function () {
            sliderDescriptionUnderTest.position(position.toString());
            assert.strictEqual(sliderDescriptionUnderTest._properties["value"], position);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = sliderDescriptionUnderTest.position(position);
            assert.strictEqual(result, sliderDescriptionUnderTest);
        });

        it("should remove 'value' from _properties when value is null", function () {
            sliderDescriptionUnderTest._properties["value"] = position;
            sliderDescriptionUnderTest.position(null);
            assert(!("value" in sliderDescriptionUnderTest._properties));
        });

        it("should return the value of 'value' from _properties when value is not given", function () {
            sliderDescriptionUnderTest._properties["value"] = position;
            var result = sliderDescriptionUnderTest.position();
            assert.strictEqual(result, position);
        });
    });

    describe("maxPosition", function () {
        var maxPosition = 100;
        it("should add 'max' to _properties when value is given", function () {
            sliderDescriptionUnderTest.maxPosition(maxPosition);
            assert.strictEqual(sliderDescriptionUnderTest._properties["max"], maxPosition);
        });

        it("should add 'max' to _properties when value is given in string", function () {
            sliderDescriptionUnderTest.maxPosition(maxPosition.toString());
            assert.strictEqual(sliderDescriptionUnderTest._properties["max"], maxPosition);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = sliderDescriptionUnderTest.maxPosition(maxPosition);
            assert.strictEqual(result, sliderDescriptionUnderTest);
        });

        it("should remove 'max' from _properties when value is null", function () {
            sliderDescriptionUnderTest._properties["max"] = maxPosition;
            sliderDescriptionUnderTest.maxPosition(null);
            assert(!("max" in sliderDescriptionUnderTest._properties));
        });

        it("should return the value of 'max' from _properties when value is not given", function () {
            sliderDescriptionUnderTest._properties["max"] = maxPosition;
            var result = sliderDescriptionUnderTest.maxPosition();
            assert.strictEqual(result, maxPosition);
        });
    });

    describe("minPosition", function () {
        var minPosition = 0;
        it("should add 'min' to _properties when value is given", function () {
            sliderDescriptionUnderTest.minPosition(minPosition);
            assert.strictEqual(sliderDescriptionUnderTest._properties["min"], minPosition);
        });

        it("should add 'min' to _properties when value is given in string", function () {
            sliderDescriptionUnderTest.minPosition(minPosition.toString());
            assert.strictEqual(sliderDescriptionUnderTest._properties["min"], minPosition);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = sliderDescriptionUnderTest.minPosition(minPosition);
            assert.strictEqual(result, sliderDescriptionUnderTest);
        });

        it("should remove 'min' from _properties when value is null", function () {
            sliderDescriptionUnderTest._properties["min"] = minPosition;
            sliderDescriptionUnderTest.minPosition(null);
            assert(!("min" in sliderDescriptionUnderTest._properties));
        });

        it("should return the value of 'min' from _properties when value is not given", function () {
            sliderDescriptionUnderTest._properties["min"] = minPosition;
            var result = sliderDescriptionUnderTest.minPosition();
            assert.strictEqual(result, minPosition);
        });
    });

    describe("isScrollBar", function () {
        [true, false].forEach(function (isScrollBar) {
            describe(isScrollBar.toString(), function () {
                var isScrollBarAsNumericString = JavaConvertHelper.boolToNumericString(isScrollBar);
                it("should add 'is_scrollbar' to _properties when the '" + isScrollBar + "' value is given", function () {
                    sliderDescriptionUnderTest.isScrollBar(isScrollBar);
                    assert.strictEqual(sliderDescriptionUnderTest._properties["is_scrollbar"], isScrollBarAsNumericString);
                });

                it("should add 'is_scrollbar' to _properties when the '" + isScrollBar + "' value is given in string", function () {
                    sliderDescriptionUnderTest.isScrollBar(isScrollBar.toString());
                    assert.strictEqual(sliderDescriptionUnderTest._properties["is_scrollbar"], isScrollBarAsNumericString);
                });

                it("should return this - builder pattern when the '" + isScrollBar + "' value is given", function () {
                    var result = sliderDescriptionUnderTest.isScrollBar(isScrollBar);
                    assert.strictEqual(result, sliderDescriptionUnderTest);
                });

                it("should remove 'is_scrollbar' from _properties when value is null", function () {
                    sliderDescriptionUnderTest._properties["is_scrollbar"] = isScrollBarAsNumericString;
                    sliderDescriptionUnderTest.isScrollBar(null);
                    assert(!("is_scrollbar" in sliderDescriptionUnderTest._properties));
                });

                it("should return the value of 'is_scrollbar' from _properties when value is not given", function () {
                    sliderDescriptionUnderTest._properties["is_scrollbar"] = isScrollBarAsNumericString;
                    var result = sliderDescriptionUnderTest.isScrollBar();
                    assert.strictEqual(result, isScrollBar);
                });
            });
        });
    });
});

describe("Slider Test Object", function () {
    var SliderTO = require("../lib/slider.js").SliderTO;
    var sliderTestObjectUnderTest;

    beforeEach(function () {
        sliderTestObjectUnderTest = new SliderTO();
        sinon.stub(sliderTestObjectUnderTest, "_getROProperty");
        sinon.stub(sliderTestObjectUnderTest, "_executeWithEvents");
    });

    describe("containerAttachedText method", function () {
        it("should execute _getROProperty 'container attached text'", function () {
            sliderTestObjectUnderTest.containerAttachedText();
            sinon.assert.calledOnce(sliderTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(sliderTestObjectUnderTest._getROProperty, "container attached text", sinon.match({}));
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = sliderTestObjectUnderTest.containerAttachedText();
            assert.strictEqual(res, promiseMock);
        });
    });

    describe("orientation method", function () {
        Object.keys(SliderOrientation).filter(function (key) {
            return !key.startsWith('_');
        }).forEach(function (key) {
            var javaNativeValue = SliderOrientation._sliderOrientationToJavaNative(key);
            describe(key, function () {
                var promiseMock = {
                    then: function (cb) {
                        return cb(javaNativeValue);
                    }
                };
                it("should execute _getROProperty 'orientation'", function () {
                    sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
                    sliderTestObjectUnderTest.orientation();
                    sinon.assert.calledOnce(sliderTestObjectUnderTest._getROProperty);
                    sinon.assert.calledWith(sliderTestObjectUnderTest._getROProperty, "orientation", sinon.match({}));
                });

                it("should return '" + key + "' when promise returns '" + javaNativeValue + "'", function () {
                    sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
                    var res = sliderTestObjectUnderTest.orientation();
                    assert.strictEqual(res, key);
                });
            });
        });
    });

    describe("position method", function () {
        var position = 50;
        var promiseMock = {
            then: function (cb) {
                return cb(position.toString());
            }
        };
        it("should execute _getROProperty 'value'", function () {
            sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
            sliderTestObjectUnderTest.position();
            sinon.assert.calledOnce(sliderTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(sliderTestObjectUnderTest._getROProperty, "value", sinon.match({}));
        });

        it("should return a number value when promise returns a numeric string", function () {
            sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = sliderTestObjectUnderTest.position();
            assert.strictEqual(res, position);
        });
    });

    describe("maxPosition method", function () {
        var maxPosition = 100;
        var promiseMock = {
            then: function (cb) {
                return cb(maxPosition.toString());
            }
        };
        it("should execute _getROProperty 'max'", function () {
            sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
            sliderTestObjectUnderTest.maxPosition();
            sinon.assert.calledOnce(sliderTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(sliderTestObjectUnderTest._getROProperty, "max", sinon.match({}));
        });

        it("should return a number value when promise returns a numeric string", function () {
            sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = sliderTestObjectUnderTest.maxPosition();
            assert.strictEqual(res, maxPosition);
        });
    });

    describe("minPosition method", function () {
        var minPosition = 100;
        var promiseMock = {
            then: function (cb) {
                return cb(minPosition.toString());
            }
        };
        it("should execute _getROProperty 'min'", function () {
            sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
            sliderTestObjectUnderTest.minPosition();
            sinon.assert.calledOnce(sliderTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(sliderTestObjectUnderTest._getROProperty, "min", sinon.match({}));
        });

        it("should return a number value when promise returns a numeric string", function () {
            sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = sliderTestObjectUnderTest.minPosition();
            assert.strictEqual(res, minPosition);
        });
    });

    describe("isScrollBar method", function () {
        ["1", "0"].forEach(function (isScrollBar) {
            var isScrollBarAsBool = JavaConvertHelper.numericStringToBool(isScrollBar);
            describe("promise returns '" + isScrollBar + "'", function () {
                var promiseMock = {
                    then: function (cb) {
                        return cb(isScrollBar);
                    }
                };
                it("should execute _getROProperty 'is_scrollbar'", function () {
                    sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
                    sliderTestObjectUnderTest.isScrollBar();
                    sinon.assert.calledOnce(sliderTestObjectUnderTest._getROProperty);
                    sinon.assert.calledWith(sliderTestObjectUnderTest._getROProperty, "is_scrollbar", sinon.match({}));
                });

                it("should return " + isScrollBarAsBool + " value", function () {
                    sliderTestObjectUnderTest._getROProperty.returns(promiseMock);
                    var res = sliderTestObjectUnderTest.isScrollBar();
                    assert.strictEqual(res, isScrollBarAsBool);
                });
            });
        });
    });

    describe("setPosition method", function () {
        var position = 5;
        it("should execute _executeWithEvents 'Drag' if the 'position' parameter is defined as number", function () {
            sliderTestObjectUnderTest.setPosition(position);
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: position
            }), "Drag", position);
        });

        it("should execute _executeWithEvents 'Drag' if the 'position' parameter is defined as string", function () {
            sliderTestObjectUnderTest.setPosition(position.toString());
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: position.toString()
            }), "Drag", position);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            sliderTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = sliderTestObjectUnderTest.setPosition(position);
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if the 'position' parameter is null", function () {
            assert.throws(function () {
                sliderTestObjectUnderTest.setPosition(null);
            });
        });

        it("should throw error if the 'position' parameter is undefined", function () {
            assert.throws(function () {
                sliderTestObjectUnderTest.setPosition();
            });
        });
    });

    describe("nextLine method", function () {
        var numberOfLines = 5;
        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is defined as number", function () {
            sliderTestObjectUnderTest.nextLine(numberOfLines);
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: numberOfLines
            }), "DragLine", numberOfLines);
        });

        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is defined as string", function () {
            sliderTestObjectUnderTest.nextLine(numberOfLines.toString());
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: numberOfLines.toString()
            }), "DragLine", numberOfLines);
        });

        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is null", function () {
            sliderTestObjectUnderTest.nextLine(null);
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: null
            }), "DragLine", 1);
        });

        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is undefined", function () {
            sliderTestObjectUnderTest.nextLine();
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({}), "DragLine", 1);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            sliderTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = sliderTestObjectUnderTest.nextLine(numberOfLines);
            assert.strictEqual(res, executionPromise);
        });


        it("should throw error if the 'numberOfLines' parameter is 0", function () {
            assert.throws(function () {
                sliderTestObjectUnderTest.nextLine(0);
            });
        });

        it("should throw error if the 'numberOfLines' parameter is -1", function () {
            assert.throws(function () {
                sliderTestObjectUnderTest.nextLine(-1);
            });
        });
    });

    describe("previousLine method", function () {
        var numberOfLines = 5;
        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is defined as number", function () {
            sliderTestObjectUnderTest.previousLine(numberOfLines);
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: numberOfLines
            }), "DragLine", (-1) * numberOfLines);
        });

        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is defined as string", function () {
            sliderTestObjectUnderTest.previousLine(numberOfLines.toString());
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: numberOfLines.toString()
            }), "DragLine", (-1) * numberOfLines);
        });

        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is null", function () {
            sliderTestObjectUnderTest.previousLine(null);
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({
                0: null
            }), "DragLine", -1);
        });

        it("should execute _executeWithEvents 'DragLine' if the 'numberOfLines' parameter is undefined", function () {
            sliderTestObjectUnderTest.previousLine();
            sinon.assert.calledOnce(sliderTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(sliderTestObjectUnderTest._executeWithEvents, sinon.match({}), "DragLine", -1);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            sliderTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = sliderTestObjectUnderTest.previousLine(numberOfLines);
            assert.strictEqual(res, executionPromise);
        });


        it("should throw error if the 'numberOfLines' parameter is 0", function () {
            assert.throws(function () {
                sliderTestObjectUnderTest.previousLine(0);
            });
        });

        it("should throw error if the 'numberOfLines' parameter is -1", function () {
            assert.throws(function () {
                sliderTestObjectUnderTest.previousLine(-1);
            });
        });
    });
});