// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 9/6/2016.
 */

var assert = require("assert");
var sinon = require("sinon");
var CalendarStyle = require("../lib/calendar.js").CalendarStyle;

describe("Calendar Description", function () {
    var Calendar = require("../lib/calendar.js").Calendar;
    var calendarDescriptionUnderTest;

    beforeEach(function () {
        calendarDescriptionUnderTest = Calendar();
    });

    describe("Constructor", function () {
        it("should assign 'Java' and 'Calendar' LeanFT type", function () {
            calendarDescriptionUnderTest = new Calendar();
            assert.deepEqual(calendarDescriptionUnderTest.leanFTType, {
                technology: "Java",
                leanftType: "Calendar"
            });
        });
    });

    describe("style", function () {
        Object.keys(CalendarStyle).filter(function (style) {
            return !style.startsWith('_');
        }).forEach(function (style) {
            describe(style, function () {
                it("should add 'style' to _properties when value is given", function () {
                    calendarDescriptionUnderTest.style("date");
                    assert.strictEqual(calendarDescriptionUnderTest._properties["style"], "date");
                });

                it("should return this - builder pattern when value is given", function () {
                    var result = calendarDescriptionUnderTest.style("date");
                    assert.strictEqual(result, calendarDescriptionUnderTest);
                });

                it("should remove 'style' from _properties when value is null", function () {
                    calendarDescriptionUnderTest._properties["style"] = "date";
                    calendarDescriptionUnderTest.style(null);
                    assert(!("style" in calendarDescriptionUnderTest._properties));
                });

                it("should return the value of 'style' from _properties when value is not given", function () {
                    calendarDescriptionUnderTest._properties["style"] = "date";
                    var result = calendarDescriptionUnderTest.style();
                    assert.strictEqual(result, "date");
                });
            });
        });

        it("should throw error if the calendar style is not supported", function () {
            assert.throws(function(){
                calendarDescriptionUnderTest.style("notSupport");
            });
        });
    });
});

describe("Calendar Test Object", function () {
    var CalendarTO = require("../lib/calendar.js").CalendarTO;
    var calendarTestObjectUnderTest;

    beforeEach(function () {
        calendarTestObjectUnderTest = new CalendarTO();
        sinon.stub(calendarTestObjectUnderTest, "_getROProperty");
        sinon.stub(calendarTestObjectUnderTest, "_getROPropertyWithoutEvents");
        sinon.stub(calendarTestObjectUnderTest, "_executeWithEvents");
    });

    describe("style method", function () {
        it("should execute _getROProperty 'style'", function () {
            calendarTestObjectUnderTest.style();
            sinon.assert.calledOnce(calendarTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTestObjectUnderTest._getROProperty, "style", sinon.match({}));
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            calendarTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTestObjectUnderTest.style();
            assert.strictEqual(res, promiseMock);
        });
    });

    describe("value method", function () {
        it("should execute _getROProperty 'value'", function () {
            calendarTestObjectUnderTest.value();
            sinon.assert.calledOnce(calendarTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTestObjectUnderTest._getROProperty, "value", sinon.match({}));
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            calendarTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTestObjectUnderTest.value();
            assert.strictEqual(res, promiseMock);
        });
    });

    describe("setDate method", function () {
        it("should throw error if date is undefine", function () {
            assert.throws(function () {
                calendarTestObjectUnderTest.setDate();
            });
        });

        it("should throw error if date is null", function () {
            assert.throws(function () {
                calendarTestObjectUnderTest.setDate(null);
            });
        });

        it("should execute _getROPropertyWithoutEvents with 'date' without arguments if data is date", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTestObjectUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            calendarTestObjectUnderTest.setDate( new Date(2016, 2, 17));
            sinon.assert.calledOnce(calendarTestObjectUnderTest._getROPropertyWithoutEvents);
            sinon.assert.calledWith(calendarTestObjectUnderTest._getROPropertyWithoutEvents, "date");
        });

        it("should throw error if result of _getROPropertyWithoutEvents is Unavailable", function () {
            calendarTestObjectUnderTest._getROPropertyWithoutEvents.returns("Unavailable");
            assert.throws(function () {
                calendarTestObjectUnderTest.setDate(new Date(2016, 2, 17));
            });
        });

        it("should call _executeWithEvents with SetDate and correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTestObjectUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            calendarTestObjectUnderTest.setDate(new Date(2016, 2, 7));
            sinon.assert.calledOnce(calendarTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTestObjectUnderTest._executeWithEvents, sinon.match({ 0: new Date(2016, 2, 7) }), "SetDate", "07-Mar-2016");
        });

        it("should return a promise", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("13-Mar-2016");
                }
            };
            calendarTestObjectUnderTest._getROPropertyWithoutEvents.returns(promiseMock);
            var promiseMockExecute = {};
            calendarTestObjectUnderTest._executeWithEvents.returns(promiseMockExecute);

            var res = calendarTestObjectUnderTest.setDate(new Date(2016, 2, 17));
            assert.strictEqual(res, promiseMockExecute);
        });
    });
});