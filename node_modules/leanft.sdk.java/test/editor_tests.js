// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 8/13/2016.
 */

var assert = require("assert");
var sinon = require("sinon");

describe("Editor Description", function () {
    var Editor = require("../lib/editor.js").Editor;
    var editorDescriptionUnderTest;

    beforeEach(function () {
        editorDescriptionUnderTest = Editor();
    });

    describe("Constructor", function () {
        it("should assign 'Java' and 'Editor' LeanFT type", function () {
            editorDescriptionUnderTest = new Editor();
            assert.deepEqual(editorDescriptionUnderTest.leanFTType, {
                technology: "Java",
                leanftType: "Editor"
            });
        });
    });

    describe("isReadOnly", function () {
        it("should add 'editable' to _properties when value is given", function () {
            editorDescriptionUnderTest.isReadOnly(true);
            assert.strictEqual(editorDescriptionUnderTest._properties["editable"], "0");
        });

        it("should add 'editable' to _properties when value is given in string", function () {
            editorDescriptionUnderTest.isReadOnly("true");
            assert.strictEqual(editorDescriptionUnderTest._properties["editable"], "0");
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editorDescriptionUnderTest.isReadOnly(true);
            assert.strictEqual(result, editorDescriptionUnderTest);
        });

        it("should return this - builder pattern when value is null", function () {
            var result = editorDescriptionUnderTest.isReadOnly(null);
            assert.strictEqual(result, editorDescriptionUnderTest);
        });

        it("should remove 'editable' from _properties when value is null", function () {
            editorDescriptionUnderTest._properties["editable"] = "1";
            editorDescriptionUnderTest.isReadOnly(null);
            assert(!("editable" in editorDescriptionUnderTest._properties));
        });

        it("should return the value of 'editable' from _properties when value is not given", function () {
            editorDescriptionUnderTest._properties["editable"] = "1";
            var result = editorDescriptionUnderTest.isReadOnly();
            assert.strictEqual(result, false);
        });
    });

    describe("text", function () {
        it("should add 'value' to _properties when value is given", function () {
            editorDescriptionUnderTest.text("text");
            assert.strictEqual(editorDescriptionUnderTest._properties["value"], "text");
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editorDescriptionUnderTest.text("text");
            assert.strictEqual(result, editorDescriptionUnderTest);
        });

        it("should remove 'value' from _properties when value is null", function () {
            editorDescriptionUnderTest._properties["value"] = "text";
            editorDescriptionUnderTest.text(null);
            assert(!("value" in editorDescriptionUnderTest._properties));
        });

        it("should return the value of 'value' from _properties when value is not given", function () {
            editorDescriptionUnderTest._properties["value"] = "text";
            var result = editorDescriptionUnderTest.text();
            assert.strictEqual(result, "text");
        });
    });
});

describe("Editor Test Object", function () {
    var EditorTO = require("../lib/editor.js").EditorTO;
    var editorTestObjectUnderTest;

    beforeEach(function () {
        editorTestObjectUnderTest = new EditorTO();
        sinon.stub(editorTestObjectUnderTest, "_getROProperty");
        sinon.stub(editorTestObjectUnderTest, "_executeWithEvents");
    });

    describe("isReadOnly method", function () {
        var promiseMock = {
            then: function (cb) {
                return cb("1");
            }
        };
        it("should execute _getROProperty 'editable'", function () {
            editorTestObjectUnderTest._getROProperty.returns(promiseMock);
            editorTestObjectUnderTest.isReadOnly();
            sinon.assert.calledOnce(editorTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editorTestObjectUnderTest._getROProperty, "editable", sinon.match({}));
        });

        it("should return bool value when promise returns numeric string", function () {
            editorTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = editorTestObjectUnderTest.isReadOnly();
            assert.strictEqual(res, false);
        });
    });

    describe("text method", function () {
        it("should execute _getROProperty 'value'", function () {
            editorTestObjectUnderTest.text();
            sinon.assert.calledOnce(editorTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editorTestObjectUnderTest._getROProperty, "value", sinon.match({}));
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            editorTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = editorTestObjectUnderTest.text();
            assert.strictEqual(res, promiseMock);
        });
    });

    describe("activate method", function () {
        it("should execute command 'Activate'", function () {
            editorTestObjectUnderTest.activate();
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({}), "Activate");
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.activate();
            assert.strictEqual(res, executionPromise);
        });
    });

    describe("clickLink method", function () {
        it("should execute command 'ClickLink'", function () {
            editorTestObjectUnderTest.clickLink("linkName");
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({0: "linkName"}), "ClickLink", "linkName");
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.clickLink("linkName");
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if linkName is not given or is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.clickLink();
            });
            assert.throws(function () {
                editorTestObjectUnderTest.clickLink(null);
            });
        });
    });

    describe("setFocus method", function () {
        it("should execute command 'SetFocus'", function () {
            editorTestObjectUnderTest.setFocus();
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({}), "SetFocus");
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.setFocus();
            assert.strictEqual(res, executionPromise);
        });
    });

    describe("delete method", function () {
        var fromLine = 1;
        var fromCharPos = 1;
        var toLine = 4;
        var toCharPos = 5;
        it("should execute _executeWithEvents 'Delete' if the parameters are defined as number", function () {
            editorTestObjectUnderTest.delete(fromLine, fromCharPos, toLine, toCharPos);
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: fromLine,
                1: fromCharPos,
                2: toLine,
                3: toCharPos
            }), "Delete", fromLine, fromCharPos, toLine, toCharPos + 1);
        });

        it("should execute _executeWithEvents 'Delete' if the parameters are defined as string", function () {
            editorTestObjectUnderTest.delete(fromLine.toString(), fromCharPos.toString(), toLine.toString(), toCharPos.toString());
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: fromLine.toString(),
                1: fromCharPos.toString(),
                2: toLine.toString(),
                3: toCharPos.toString()
            }), "Delete", fromLine, fromCharPos, toLine, toCharPos + 1);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.delete(fromLine, fromCharPos, toLine, toCharPos);
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if the 'fromLine' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(null, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if the 'fromLine' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(undefined, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if the 'fromCharPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(fromLine, null, toLine, toCharPos);
            });
        });

        it("should throw error if the 'fromCharPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(fromLine, undefined, toLine, toCharPos);
            });
        });

        it("should throw error if the 'toLine' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(fromLine, fromCharPos, null, toCharPos);
            });
        });

        it("should throw error if the 'toLine' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(fromLine, fromCharPos, undefined, toCharPos);
            });
        });

        it("should throw error if the 'toCharPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(fromLine, fromCharPos, toLine, null);
            });
        });

        it("should throw error if the 'toCharPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(fromLine, fromCharPos, toLine);
            });
        });
    });

    describe("insert method", function () {
        var text = "Text To Insert";
        var line = 1;
        var charPos = 2;
        it("should execute _executeWithEvents 'Insert' if the 'line' and 'charPos' parameters are defined as number", function () {
            editorTestObjectUnderTest.insert(text, line, charPos);
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: text,
                1: line,
                2: charPos
            }), "Insert", text, line, charPos);
        });

        it("should execute _executeWithEvents 'Insert' if the 'line' and 'charPos' parameters are defined as string", function () {
            editorTestObjectUnderTest.insert(text, line.toString(), charPos.toString());
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: text,
                1: line.toString(),
                2: charPos.toString()
            }), "Insert", text, line, charPos);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.insert(text, line, charPos);
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if the 'text' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.insert(null, line, charPos);
            });
        });

        it("should throw error if the 'text' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.insert(undefined, line, charPos);
            });
        });

        it("should throw error if the 'line' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.insert(text, null, charPos);
            });
        });

        it("should throw error if the 'line' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.insert(text, undefined, charPos);
            });
        });

        it("should throw error if the 'charPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.insert(text, line, null);
            });
        });

        it("should throw error if the 'charPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.insert(text, line);
            });
        });
    });

    describe("replace method", function () {
        var text = "Text To Insert";
        var fromLine = 1;
        var fromCharPos = 1;
        var toLine = 4;
        var toCharPos = 5;
        it("should execute _executeWithEvents 'Replace' if the parameters as number are defined as number", function () {
            editorTestObjectUnderTest.replace(text, fromLine, fromCharPos, toLine, toCharPos);
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: text,
                1: fromLine,
                2: fromCharPos,
                3: toLine,
                4: toCharPos
            }), "Replace", fromLine, fromCharPos, toLine, toCharPos + 1, text);
        });

        it("should execute _executeWithEvents 'Replace' if the parameters as number are defined as string", function () {
            editorTestObjectUnderTest.replace(text, fromLine.toString(), fromCharPos.toString(), toLine.toString(), toCharPos.toString());
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: text,
                1: fromLine.toString(),
                2: fromCharPos.toString(),
                3: toLine.toString(),
                4: toCharPos.toString()
            }), "Replace", fromLine, fromCharPos, toLine, toCharPos + 1, text);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.replace(text, fromLine, fromCharPos, toLine, toCharPos);
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if one of the 'text' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(null, fromLine, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if one of the 'text' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(undefined, fromLine, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if one of the 'fromLine' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, null, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if one of the 'fromLine' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, undefined, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if one of the 'fromCharPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, fromLine, null, toLine, toCharPos);
            });
        });

        it("should throw error if one of the 'fromCharPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, fromLine, undefined, toLine, toCharPos);
            });
        });

        it("should throw error if one of the 'toLine' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, fromLine, fromCharPos, null, toCharPos);
            });
        });

        it("should throw error if one of the 'toLine' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, fromLine, fromCharPos, undefined, toCharPos);
            });
        });

        it("should throw error if one of the 'toCharPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, fromLine, fromCharPos, toLine, null);
            });
        });

        it("should throw error if one of the 'toCharPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.replace(text, fromLine, fromCharPos, toLine);
            });
        });
    });

    describe("select method", function () {
        var fromLine = 1;
        var fromCharPos = 1;
        var toLine = 4;
        var toCharPos = 5;
        it("should execute _executeWithEvents 'SetSelection' if the parameters are defined as number", function () {
            editorTestObjectUnderTest.select(fromLine, fromCharPos, toLine, toCharPos);
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: fromLine,
                1: fromCharPos,
                2: toLine,
                3: toCharPos
            }), "SetSelection", fromLine, fromCharPos, toLine, toCharPos + 1);
        });

        it("should execute _executeWithEvents 'SetSelection' if the parameters are defined as string", function () {
            editorTestObjectUnderTest.select(fromLine.toString(), fromCharPos.toString(), toLine.toString(), toCharPos.toString());
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: fromLine.toString(),
                1: fromCharPos.toString(),
                2: toLine.toString(),
                3: toCharPos.toString()
            }), "SetSelection", fromLine, fromCharPos, toLine, toCharPos + 1);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.select(fromLine, fromCharPos, toLine, toCharPos);
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if the 'fromLine' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.select(null, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if the 'fromLine' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.select(undefined, fromCharPos, toLine, toCharPos);
            });
        });

        it("should throw error if the 'fromCharPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.select(fromLine, null, toLine, toCharPos);
            });
        });

        it("should throw error if the 'fromCharPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.select(fromLine, undefined, toLine, toCharPos);
            });
        });

        it("should throw error if the 'toLine' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.select(fromLine, fromCharPos, null, toCharPos);
            });
        });

        it("should throw error if the 'toLine' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.select(fromLine, fromCharPos, undefined, toCharPos);
            });
        });

        it("should throw error if the 'toCharPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.select(fromLine, fromCharPos, toLine, null);
            });
        });

        it("should throw error if the 'toCharPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.delete(fromLine, fromCharPos, toLine);
            });
        });
    });

    describe("setText method", function () {
        it("should execute command 'Set'", function () {
            editorTestObjectUnderTest.setText("Text to set");
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({0: "Text to set"}), "Set", "Text to set");
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.setText("Text to set");
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if the 'text' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setText(null);
            });
        });

        it("should throw error if the 'text' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setText();
            });
        });
    });

    describe("setSecure method", function () {
        it("should execute command 'SetSecure'", function () {
            editorTestObjectUnderTest.setSecure("Text to set");
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({0: "Text to set"}), "SetSecure", "Text to set");
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.setSecure("Text to set");
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if the 'encodedText' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setSecure(null);
            });
        });

        it("should throw error if the 'encodedText' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setSecure();
            });
        });
    });

    describe("setCursorPosition method", function () {
        var line = 1;
        var charPos = 2;
        it("should execute _executeWithEvents 'SetCaretPos' if the parameters are defined as number", function () {
            editorTestObjectUnderTest.setCursorPosition(line, charPos);
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: line,
                1: charPos
            }), "SetCaretPos", line, charPos);
        });

        it("should execute _executeWithEvents 'SetCaretPos' if the parameters are defined as string", function () {
            editorTestObjectUnderTest.setCursorPosition(line.toString(), charPos.toString());
            sinon.assert.calledOnce(editorTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editorTestObjectUnderTest._executeWithEvents, sinon.match({
                0: line.toString(),
                1: charPos.toString()
            }), "SetCaretPos", line, charPos);
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editorTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editorTestObjectUnderTest.setCursorPosition(line, charPos);
            assert.strictEqual(res, executionPromise);
        });

        it("should throw error if the 'line' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setCursorPosition(null, charPos);
            });
        });

        it("should throw error if the 'line' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setCursorPosition(undefined, charPos);
            });
        });

        it("should throw error if the 'charPos' parameter is null", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setCursorPosition(line, null);
            });
        });

        it("should throw error if the 'charPos' parameter is undefined", function () {
            assert.throws(function () {
                editorTestObjectUnderTest.setCursorPosition(line);
            });
        });
    });
});