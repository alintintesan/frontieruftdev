// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 8/25/2016.
 */

var assert = require("assert");
var sinon = require("sinon");

describe("ExpandBar Description", function () {
    var ExpandBar = require("../lib/expand_bar.js").ExpandBar;
    var expandBarDescriptionUnderTest;

    beforeEach(function () {
        expandBarDescriptionUnderTest = ExpandBar();
    });

    describe("Constructor", function () {
        it("should assign 'Java' and 'ExpandBar' LeanFT type", function () {
            expandBarDescriptionUnderTest = new ExpandBar();
            assert.deepEqual(expandBarDescriptionUnderTest.leanFTType, {
                technology: "Java",
                leanftType: "ExpandBar"
            });
        });
    });

    describe("itemsCount", function () {
        var itemsCount = 50;
        it("should add 'count' to _properties when value is given", function () {
            expandBarDescriptionUnderTest.itemsCount(itemsCount);
            assert.strictEqual(expandBarDescriptionUnderTest._properties["count"], itemsCount);
        });

        it("should add 'count' to _properties when value is given in string", function () {
            expandBarDescriptionUnderTest.itemsCount(itemsCount.toString());
            assert.strictEqual(expandBarDescriptionUnderTest._properties["count"], itemsCount);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = expandBarDescriptionUnderTest.itemsCount(itemsCount);
            assert.strictEqual(result, expandBarDescriptionUnderTest);
        });

        it("should remove 'count' from _properties when value is null", function () {
            expandBarDescriptionUnderTest._properties["count"] = itemsCount;
            expandBarDescriptionUnderTest.itemsCount(null);
            assert(!("count" in expandBarDescriptionUnderTest._properties));
        });

        it("should return the value of 'count' from _properties when value is not given", function () {
            expandBarDescriptionUnderTest._properties["count"] = itemsCount;
            var result = expandBarDescriptionUnderTest.itemsCount();
            assert.strictEqual(result, itemsCount);
        });
    });

    describe("expandedItems", function () {
        var expandedItems = ["value1", "value2"];
        it("should add 'value' to _properties when value is given", function () {
            expandBarDescriptionUnderTest.expandedItems(expandedItems);
            assert.strictEqual(expandBarDescriptionUnderTest._properties["value"], expandedItems.join("\u0018"));
        });

        it("should return this - builder pattern when value is given", function () {
            var result = expandBarDescriptionUnderTest.expandedItems(expandedItems);
            assert.strictEqual(result, expandBarDescriptionUnderTest);
        });

        it("should remove 'value' from _properties when value is null", function () {
            expandBarDescriptionUnderTest._properties["value"] = expandedItems.join("\u0018");
            expandBarDescriptionUnderTest.expandedItems(null);
            assert(!("value" in expandBarDescriptionUnderTest._properties));
        });

        it("should return the value of 'value' from _properties when value is not given", function () {
            expandBarDescriptionUnderTest._properties["value"] = expandedItems.join("\u0018");
            var result = expandBarDescriptionUnderTest.expandedItems();
            assert.deepEqual(result, expandedItems);
        });
    });
});

describe("ExpandBar Test Object", function () {
    var ExpandBarTO = require("../lib/expand_bar.js").ExpandBarTO;
    var ExpandBarItem = require("../lib/expandbar_item.js").ExpandBarItem;
    var expandBarTestObjectUnderTest;

    var removeExecutorMethods = function (array) {
        array.map(function (item) {
            delete item._executeWithEventsOnItem;
            delete item._executeWithEventsOnItemOnError;
        });
        return array;
    };

    beforeEach(function () {
        expandBarTestObjectUnderTest = new ExpandBarTO();
        sinon.stub(expandBarTestObjectUnderTest, "_getROProperty");
        sinon.stub(expandBarTestObjectUnderTest, "_executeCommand");
        sinon.stub(expandBarTestObjectUnderTest, "_executeWithEvents");
        sinon.stub(expandBarTestObjectUnderTest, "_executeNotWrapped");
    });

    describe("_itemsCount method", function () {
        var itemsCount = 2;
        var promiseMock = {
            then: function (cb) {
                return cb(itemsCount.toString());
            }
        };
        it("should execute _getROProperty 'count'", function () {
            expandBarTestObjectUnderTest._getROProperty.returns(promiseMock);
            expandBarTestObjectUnderTest._itemsCount();
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._getROProperty, "count", sinon.match({}));
        });

        it("should return a number value when promise returns numeric string", function () {
            expandBarTestObjectUnderTest._getROProperty.returns(promiseMock);
            var res = expandBarTestObjectUnderTest._itemsCount();
            assert.strictEqual(res, itemsCount);
        });
    });

    describe("expandedItems method", function () {
        var itemStrings = "";
        beforeEach(function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(itemStrings);
                }
            };
            expandBarTestObjectUnderTest._getROProperty.returns(promiseMock);
        });
        it("should query the 'value' property", function () {
            expandBarTestObjectUnderTest.expandedItems();
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._getROProperty, "value", sinon.match({}));
        });

        it("should return an empty list if no item is returned", function () {
            var expandedItems = expandBarTestObjectUnderTest.expandedItems();
            assert.deepEqual(expandedItems, []);
        });

        it("should return a list if items are returned", function () {
            itemStrings = "item1\u0018item2";
            var expandedItems = removeExecutorMethods(expandBarTestObjectUnderTest.expandedItems());
            assert.deepEqual(expandedItems, removeExecutorMethods([new ExpandBarItem(expandBarTestObjectUnderTest, "item1", "item1"), new ExpandBarItem(expandBarTestObjectUnderTest, "item2", "item2")]));
        });
    });

    describe("items method", function () {
        var itemsCountStr;
        beforeEach(function () {
            sinon.stub(expandBarTestObjectUnderTest, "_itemsCount");
            var promiseMock = {
                then: function (cb) {
                    return cb(itemsCountStr);
                }
            };
            expandBarTestObjectUnderTest._itemsCount.returns(promiseMock);
        });

        afterEach(function () {
            expandBarTestObjectUnderTest._itemsCount.restore();
        });

        it("should execute command '_itemsCount'", function () {
            itemsCountStr = "";
            expandBarTestObjectUnderTest.items();
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._itemsCount);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._itemsCount);
        });

        it("should return an empty list if no item is in the ExpandBar", function () {
            itemsCountStr = "0";
            var allItems = expandBarTestObjectUnderTest.items();
            assert.deepEqual(allItems, []);
        });

        it("should return a list if items are in the ExpandBar", function () {
            itemsCountStr = "2";
            var allItems = removeExecutorMethods(expandBarTestObjectUnderTest.items());
            assert.deepEqual(allItems, removeExecutorMethods([new ExpandBarItem(expandBarTestObjectUnderTest, 0), new ExpandBarItem(expandBarTestObjectUnderTest, 1)]));
        });
    });

    describe("getItem method", function () {
        it("should create a correct item", function () {
            var item = expandBarTestObjectUnderTest.getItem("some path");
            assert.strictEqual(item._identifier, "some path");
        });

        it("should throw error if the 'text' parameter is null", function () {
            assert.throws(function () {
                expandBarTestObjectUnderTest.getItem(null);
            });
        });

        it("should throw error if the 'text' parameter is undefined", function () {
            assert.throws(function () {
                expandBarTestObjectUnderTest.getItem();
            });
        });
    });

    describe("_getItemLabel method", function () {
        var itemList = [];
        beforeEach(function () {
            var itemsPromise = {
                then: function (cb) {
                    return cb(itemList);
                }
            };
            sinon.stub(expandBarTestObjectUnderTest, "items");
            expandBarTestObjectUnderTest.items.returns(itemsPromise);
        });

        afterEach(function () {
            expandBarTestObjectUnderTest.items.restore();
        });

        it("should execute command 'GetItem' if the 'identifier' parameter is regular", function () {
            expandBarTestObjectUnderTest._getItemLabel(0);
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._executeNotWrapped, sinon.match({0: 0}), "GetItem", 0);
        });

        it("should throw error if no item is in the ExpandBar", function () {
            itemList = [];
            assert.throws(function () {
                expandBarTestObjectUnderTest._getItemLabel(itemLabel);
            });
        });

        it("should throw error if the 'identifier' parameter isn't neither a string nor a number", function () {
            assert.throws(function () {
                expandBarTestObjectUnderTest._getItemLabel(true);
            });
        });
    });

    describe("_itemCollapse method", function () {
        it("should execute command 'Collapse' if the 'identifier' parameter is a number", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("item label");
                }
            };
            expandBarTestObjectUnderTest._executeNotWrapped.returns(promiseMock);
            expandBarTestObjectUnderTest._itemCollapse(0);
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._executeCommand, "Collapse", "item label");
        });

        it("should execute command 'Collapse' if the 'identifier' parameter is a string", function () {
            expandBarTestObjectUnderTest._itemCollapse("item label");
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._executeNotWrapped, sinon.match({0: "item label"}), "Collapse", "item label");
        });

        it("should throw error if the 'identifier' parameter isn't neither a string nor a number", function () {
            assert.throws(function () {
                expandBarTestObjectUnderTest._itemCollapse(true);
            });
        });
    });

    describe("_itemExpand method", function () {
        it("should execute command 'Collapse' if the 'identifier' parameter is a number", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("item label");
                }
            };
            expandBarTestObjectUnderTest._executeNotWrapped.returns(promiseMock);
            expandBarTestObjectUnderTest._itemExpand(0);
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._executeCommand, "Expand", "item label");
        });

        it("should execute command 'Collapse' if the 'identifier' parameter is a string", function () {
            expandBarTestObjectUnderTest._itemExpand("item label");
            sinon.assert.calledOnce(expandBarTestObjectUnderTest._executeNotWrapped);
            sinon.assert.calledWith(expandBarTestObjectUnderTest._executeNotWrapped, sinon.match({0: "item label"}), "Expand", "item label");
        });

        it("should throw error if the 'identifier' parameter isn't neither a string nor a number", function () {
            assert.throws(function () {
                expandBarTestObjectUnderTest._itemExpand(true);
            });
        });
    });

    describe("_createItem method", function () {
        it("should return the ExpandBarItem with identifier as string", function () {
            var res = expandBarTestObjectUnderTest._createItem("Item1", "Item1");
            assert.strictEqual(res._identifier, "Item1");
            assert.strictEqual(res._textRepresentation, "Item1");
            assert.deepEqual(res._ownerExpandBar, expandBarTestObjectUnderTest);
        });

        it("should return the ExpandBarItem with identifier as number", function () {
            var res = expandBarTestObjectUnderTest._createItem(0);
            assert.strictEqual(res._identifier, 0);
            assert.strictEqual(res._textRepresentation, undefined);
            assert.deepEqual(res._ownerExpandBar, expandBarTestObjectUnderTest);
        });
    });
});