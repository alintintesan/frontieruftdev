// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

var assert = require("assert");
var sinon = require("sinon");
var ReporterProvider = require("../lib/report_provider.js").ReporterProvider;
var DefaultReporterBehavior = require('../lib/default_reporter_behavior.js');
var EmptyReporterBehavior = require('../lib/empty_reporter_behavior.js');
var ReportUtils = require("../lib/report_utils").ReportUtils;

describe("ReportProvider Tests",function() {
    var reportProviderUnderTest;
    var promiseManagerMock;
    var sessionMock;

    beforeEach(function () {
        reportProviderUnderTest = new ReporterProvider();
        
        promiseManagerMock = {
            syncedBranchThen: function () {}
        };

        sinon.stub(promiseManagerMock, "syncedBranchThen", function (fulfill) {
           return fulfill();
        });

        sessionMock = {
            _promiseManager: promiseManagerMock
        };

        reportProviderUnderTest._session = sessionMock;
    });

    afterEach(function() {
        delete reportProviderUnderTest._propertyValueHandler
    });

    describe("constructor", function () {
        it("Reporter should have all functions of the empty behavior after construction (without init)", function () {
            Object.keys(EmptyReporterBehavior).forEach(function (key) {
               assert(key in reportProviderUnderTest, "Key: " + key + " is not in ReportProvider");
            });
        });
    });
    
    describe("_specialValueHandler",function() {
        beforeEach(function () {
            reportProviderUnderTest._propertyValueHandler = sinon.stub();
            reportProviderUnderTest._propertyValueHandler.returns(undefined);
            reportProviderUnderTest._specialValueHandler._getTOProperties = sinon.stub();
            reportProviderUnderTest._specialValueHandler._getTestObjectHierarchy = sinon.stub();
            reportProviderUnderTest._specialValueHandler._getWiredNameOrDefault = sinon.stub();
            reportProviderUnderTest._specialValueHandler._getLeanFtTypeFromTestObject = sinon.stub();
            reportProviderUnderTest._specialValueHandler._getTechnologyFromTestObject = sinon.stub();
            reportProviderUnderTest._specialValueHandler.buildArgumentsTable = sinon.stub();
            reportProviderUnderTest._specialValueHandler._buildParametersWithNames = sinon.stub();
        });

        describe("TestObject",function() {
            it("should add textual representation to node if caller that contains item exist",function(){
                var testObjectUnderTest = {"_description":{"isMaximized":function(){return true;}}};
                var data = {sender:testObjectUnderTest, caller:{_getTextRepresentation:sinon.stub()}, methodName:"methodName"}
                reportProviderUnderTest._specialValueHandler._getTestObjectHierarchy.returns([{Name:"kuku"}])
                data.caller._getTextRepresentation.returns("Text");
                reportProviderUnderTest._specialValueHandler._getWiredNameOrDefault.returns("someWiredName");
                var node = reportProviderUnderTest._specialValueHandler.TestObject(data);
                assert.deepEqual(node._reportAdditionalData.textRepresentation, "Text");
                sinon.assert.calledOnce(data.caller._getTextRepresentation);
            });
        });

        describe("APITestRunner",function() {
            beforeEach(function () {
                sinon.stub(reportProviderUnderTest,"buildArgumentsTable");
                sinon.stub(reportProviderUnderTest,"_buildParametersWithNames");
            });
            it("should create API node",function(){
                var testObjectUnderTest = {"_description":{"isMaximized":function(){return true;}}};
                var data = {sender:testObjectUnderTest, caller:{_getTextRepresentation:sinon.stub()}, methodName:"methodName"}
                reportProviderUnderTest._specialValueHandler._getTestObjectHierarchy.returns([{Name:"kuku"}])
                data.caller._getTextRepresentation.returns("Text");
                var node = reportProviderUnderTest._specialValueHandler.APITestRunner.call(reportProviderUnderTest,data);
                assert.deepEqual(node._name, "UFTAPITestRunner.Run");
                assert.deepEqual(node._objectType, "UFTAPITestRun");
            });
            afterEach(function() {
                reportProviderUnderTest._buildParametersWithNames.restore();
                reportProviderUnderTest.buildArgumentsTable.restore();
            });
        });

        afterEach(function() {
            delete reportProviderUnderTest._propertyValueHandler;
            delete reportProviderUnderTest._specialValueHandler._getTOProperties;
            delete reportProviderUnderTest._specialValueHandler._getTestObjectHierarchy;
            delete reportProviderUnderTest._specialValueHandler._getLeanFtTypeFromTestObject;
            delete reportProviderUnderTest._specialValueHandler._getTechnologyFromTestObject;
            delete reportProviderUnderTest._specialValueHandler._buildParametersWithNames;
            delete reportProviderUnderTest._specialValueHandler.buildArgumentsTable;
            delete reportProviderUnderTest._specialValueHandler._getWiredNameOrDefault
        });
    });

    describe("_onAdditionalDataReceivedOperation",function() {
        beforeEach(function () {
            sinon.stub(ReportUtils, "getTechnologyFromTestObject").returns("some_tech");
        });

        afterEach(function () {
            ReportUtils.getTechnologyFromTestObject.restore();
        });

        it("should use the original property value if propertyValueHandler don't handles property type",function(){
            reportProviderUnderTest._propertyValueHandler = sinon.stub();
            reportProviderUnderTest._propertyValueHandler.returns(undefined);

            var testObjectUnderTest = {"_description":{"isMaximized":function(){return true;}},_getApplicationInfo:sinon.stub().returns(undefined)};
            var properties = reportProviderUnderTest._getTOProperties(testObjectUnderTest);
            assert.ok(properties.length == 1)
            assert.deepEqual(properties[0], {name :"isMaximized", value:true});
            sinon.assert.notCalled(reportProviderUnderTest._propertyValueHandler);
        });

        it("should add textual representation to node name and to node operation",function(){
            var testObjectUnderTest = {"_description":{"isMaximized":sinon.stub().returns(true)}};
            var data = {sender:testObjectUnderTest, caller:{_getTextRepresentation:sinon.stub()}, methodName:"methodName", commandId:'1',additionalData:{ReportEventData:"kuku"}}
            data.caller._getTextRepresentation.returns("Text");
            reportProviderUnderTest._updateHierarchyNames = sinon.stub();
            var node = {_reportAdditionalData:{textRepresentation:"item 1"}, _name:"name",_objectPath:[{Name:"obj1"}]};
            reportProviderUnderTest._reportNodesMap['1'] = node;
            reportProviderUnderTest._onAdditionalDataReceivedOperation(data);
            assert.strictEqual(reportProviderUnderTest._reportNodesMap['1']._name, "obj1.Item[\"item 1\"].undefined");
            assert.strictEqual(reportProviderUnderTest._reportNodesMap['1']._objectPath[node._objectPath.length-1].Name , "obj1.Item[\"item 1\"]");
            delete reportProviderUnderTest._updateHierarchyNames;
        });
    });

    describe("_buildParametersWithNames",function() {
        var ReportUtils = require("../lib/report_utils.js").ReportUtils;
        var originalGetParamName = ReportUtils.getParamNames;

        beforeEach(function () {
            sinon.stub(ReportUtils, "getParamNames");
        });

        it("should return null value if method arguments are empty",function(){
            var data = { methodArguments:[]};
            var result = reportProviderUnderTest._buildParametersWithNames(data);
            assert.strictEqual(result, null);
        });

        it("should return array of arguments names and values, where count of names is equal to count of values",function(){
            ReportUtils.getParamNames.returns(['name1', 'name2']);
            var data = { methodArguments:['val1','val2']};
            var result = reportProviderUnderTest._buildParametersWithNames(data);
            assert.deepEqual(result, [{ "name": "name1", "value": "val1" }, {"name": "name2","value": "val2" } ]);
        });

        it("should return array with one item that contains argument name and values array",function(){
            ReportUtils.getParamNames.returns(['items']);
            var data = { methodArguments:['val1','val2']};
            var result = reportProviderUnderTest._buildParametersWithNames(data);
            assert.deepEqual(result, [{ "name": "items", "value":['val1','val2']}]);
        });

        it("should return object with one item with single value when names are bigger than values",function(){
            ReportUtils.getParamNames.returns(['items','items2']);
            var data = { methodArguments:['val1']};
            var result = reportProviderUnderTest._buildParametersWithNames(data);
            assert.deepEqual(result, [ {
                    "name": "items",
                    "value": "val1",
                },
                {
                    "name": "items2",
                    "value": undefined
                }
            ]);
        });

        afterEach(function () {
            ReportUtils.getParamNames.restore();
        });

    });

    describe("_argumentValueHandler",function() {
        beforeEach(function () {
        });

        describe("object",function(){
            describe("array case",function(){

                it("should return presentation for array",function(){
                    var result = reportProviderUnderTest._argumentValueHandler.object.call(reportProviderUnderTest,['Drinks','Hamburgers']);
                    assert.strictEqual(result, "[ Drinks, Hamburgers ]");
                });

                it("should return table presentation for complex object that contains array",function(){
                    var result = reportProviderUnderTest._argumentValueHandler.object.call(reportProviderUnderTest,{item:'key',value:["Drinks","Hamburgers"]});
                    assert.strictEqual(result, "<style>.ex-table{border-collapse: collapse !important;width: auto;height: auto;}.ex-table,.ex-table tr,.ex-table td{border: 1px solid #c6c6c6;}.ex-table td{padding: 5px 10px;vertical-align: top,width: auto,}.ex-table .ex-name{font-size: 13px;font-weight: bold;background-color: #f3f3f3;white-space: nowrap;}.ex-table .ex-value{color: #5a5a5a;}</style><table class='ex-table'><tr><td class='ex-name'>item</td><td class='ex-value'>key</td></tr><tr><td class='ex-name'>value</td><td class='ex-value'>[ Drinks, Hamburgers ]</td></tr></table>");
                });

                it("should return table presentation for complex object that value is array",function(){
                    var result = reportProviderUnderTest._argumentValueHandler.object.call(reportProviderUnderTest,{item:["Drinks","Hamburgers"]});
                    assert.strictEqual(result, "<style>.ex-table{border-collapse: collapse !important;width: auto;height: auto;}.ex-table,.ex-table tr,.ex-table td{border: 1px solid #c6c6c6;}.ex-table td{padding: 5px 10px;vertical-align: top,width: auto,}.ex-table .ex-name{font-size: 13px;font-weight: bold;background-color: #f3f3f3;white-space: nowrap;}.ex-table .ex-value{color: #5a5a5a;}</style><table class='ex-table'><tr><td class='ex-name'>item</td><td class='ex-value'>[ Drinks, Hamburgers ]</td></tr></table>");
                });
            });

            describe("expectedArg",function(){
                it("should return presentation for expect argument",function(){
                    var result = reportProviderUnderTest._argumentValueHandler.object.call(reportProviderUnderTest,{name:'s',value:{expectArg:0}});
                    assert.strictEqual(result, "<style>.ex-table{border-collapse: collapse !important;width: auto;height: auto;}.ex-table,.ex-table tr,.ex-table td{border: 1px solid #c6c6c6;}.ex-table td{padding: 5px 10px;vertical-align: top,width: auto,}.ex-table .ex-name{font-size: 13px;font-weight: bold;background-color: #f3f3f3;white-space: nowrap;}.ex-table .ex-value{color: #5a5a5a;}</style><table class='ex-table'><tr><td class='ex-name'>name</td><td class='ex-value'>s</td></tr><tr><td class='ex-name'>value</td><td class='ex-value'><p>0</p></td></tr></table>");
                });

                it("should return presentation for expect argument with error",function(){
                    var result = reportProviderUnderTest._argumentValueHandler.object.call(reportProviderUnderTest,{name:'s',value:{expectArg:0, error:new Error()}});
                    assert.strictEqual(result, "<style>.ex-table{border-collapse: collapse !important;width: auto;height: auto;}.ex-table,.ex-table tr,.ex-table td{border: 1px solid #c6c6c6;}.ex-table td{padding: 5px 10px;vertical-align: top,width: auto,}.ex-table .ex-name{font-size: 13px;font-weight: bold;background-color: #f3f3f3;white-space: nowrap;}.ex-table .ex-value{color: #5a5a5a;}</style><table class='ex-table'><tr><td class='ex-name'>name</td><td class='ex-value'>s</td></tr><tr><td class='ex-name'>value</td><td class='ex-value'><p style='color:red;'>0</p></td></tr></table>");
                });
            });
        });

        describe("containerItemArray",function(){
            it("should return presentation for item container array",function(){
                var result = reportProviderUnderTest._argumentValueHandler.containerItemArray.call(reportProviderUnderTest,{name:'s',value:[{_identifier:0}]});
                assert.strictEqual(result, "<tr><td class='ex-name'>s</td><td class='ex-value'><style>.ex-table{border-collapse: collapse !important;width: auto;height: auto;}.ex-table,.ex-table tr,.ex-table td{border: 1px solid #c6c6c6;}.ex-table td{padding: 5px 10px;vertical-align: top,width: auto,}.ex-table .ex-name{font-size: 13px;font-weight: bold;background-color: #f3f3f3;white-space: nowrap;}.ex-table .ex-value{color: #5a5a5a;}</style><table class='ex-table'><tr><td class='ex-name'>Identifier</td><td class='ex-value'>0</td></tr></table></td></tr></table>");
            });
        });

        afterEach(function () {
        });
    });

    describe("buildArgumentsTable",function() {
        beforeEach(function () {
            sinon.stub(ReportUtils, "isContainerItemsArray");
        });

        it("should return empty string if data is not array",function(){
            var result = reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,'kuku');
            assert.strictEqual(result,"");
        });

        it("should return empty string if data is empty array",function(){
            var result = reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,[]);
            assert.strictEqual(result,"");
        });

        it("should call the _isContainerItemsArray with array on value type variable",function(){
            reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,[{name:'items',value:'kuku'}]);
            assert(Array.isArray(ReportUtils.isContainerItemsArray.firstCall.args[0]));
            assert.deepEqual(ReportUtils.isContainerItemsArray.firstCall.args[0], ['kuku']);
        });

        it("should call the _isContainerItemsArray with array will not change the array values",function(){
            reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,[{name:'items',value:['kuku','kuku2']}]);
            assert(Array.isArray(ReportUtils.isContainerItemsArray.firstCall.args[0]));
            assert.deepEqual(ReportUtils.isContainerItemsArray.firstCall.args[0], ['kuku','kuku2']);
        });

        it("should call the containerItemArray handler in case that value is containerItem",function(){
            ReportUtils.isContainerItemsArray.returns(true);
            reportProviderUnderTest._argumentValueHandler.containerItemArray = sinon.stub();
            reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,[{name:'items',value:[{_identifier:0}]}]);
            assert.strictEqual(reportProviderUnderTest._argumentValueHandler.containerItemArray.callCount,1);
        });

        it("should call the containerItemArray handler in case that value is containerItemArray",function(){
            ReportUtils.isContainerItemsArray.returns(true);
            reportProviderUnderTest._argumentValueHandler.containerItemArray = sinon.stub();
            reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,[{name:'items',value:[{_identifier:0,_identifier:1}]}]);
            assert.strictEqual(reportProviderUnderTest._argumentValueHandler.containerItemArray.callCount,1);
        });


        it("should call the containerItemArray handler in case that value is not containerItem",function(){
            ReportUtils.isContainerItemsArray.returns(false);
            reportProviderUnderTest._argumentValueHandler.containerItemArray = sinon.stub();
            reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,[{name:'items',value:[{_identifier:0}]}]);
            assert.strictEqual(reportProviderUnderTest._argumentValueHandler.containerItemArray.callCount,0);
        });

        it("should not call the containerItemArray handler in case that value is not containerItemArray",function(){
            ReportUtils.isContainerItemsArray.returns(false);
            reportProviderUnderTest._argumentValueHandler.containerItemArray = sinon.stub();
            reportProviderUnderTest.buildArgumentsTable.call(reportProviderUnderTest,[{name:'items',value:[{_identifier:0,_identifier:1}]}]);
            assert.strictEqual(reportProviderUnderTest._argumentValueHandler.containerItemArray.callCount,0);
        });

        afterEach(function () {
            ReportUtils.isContainerItemsArray.restore();
        });
    });



    describe("_reportExpectEvent",function() {

        beforeEach(function () {
            reportProviderUnderTest.buildArgumentsTable = sinon.stub().returns();
            reportProviderUnderTest._addNodeToReportModel = sinon.stub();
        });

        it("should call the buildArgumentsTable method with actual and expected value for Expect",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:false, args:[1,2], shouldThrow:true, func:function(a,b){}});
            assert.deepEqual(reportProviderUnderTest.buildArgumentsTable.firstCall.args[0], [ { "name": "expected","value": {"expectArg": 1}}, { "name": "actual", "value": { "error": undefined, "expectArg": 2}}  ]);
        });

        it("should call the buildArgumentsTable method with actual and expected value with error",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:false, args:[1,2], shouldThrow:false, error:new Error(), func:function(a,b){}});
            assert.deepEqual(reportProviderUnderTest.buildArgumentsTable.firstCall.args[0], [ { "name": "expected","value": {"expectArg": 1}}, { "name": "actual", "value": { "error": new Error(), "expectArg": 2}}  ]);
        });

        it("should call the buildArgumentsTable method with condition value with error",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:false, args:[1], shouldThrow:false, func:function(a){}});
            assert.deepEqual(reportProviderUnderTest.buildArgumentsTable.firstCall.args[0], [ { "name": "condition","value": {"expectArg": 1, "error": undefined}}]);
        });

        it("should call the buildArgumentsTable method with condition value",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:false, args:[1], shouldThrow:false, error:new Error(), func:function(a){}});
            assert.deepEqual(reportProviderUnderTest.buildArgumentsTable.firstCall.args[0], [ { "name": "condition","value": {"expectArg": 1, "error": new Error()}}]);
        });

        it("should call the _addNodeToReportModel method with failed verify value",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:false, args:[1], shouldThrow:false, error:new Error(), func:function(a){}});
            var value = reportProviderUnderTest._addNodeToReportModel.firstCall.args[0];
            assert.deepEqual(value._status, "Failed");
            assert.deepEqual(value._nodeType, "Verify");
            assert.deepEqual(value._name, "verify.check");
        });

        it("should call the _addNodeToReportModel method with expect value",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:false, args:[1], shouldThrow:true, error:new Error(), func:function(a){}});
            var value = reportProviderUnderTest._addNodeToReportModel.firstCall.args[0];
            assert.deepEqual(value._status, "Failed");
            assert.deepEqual(value._nodeType, "Expect");
            assert.deepEqual(value._name, "expect.check");
        });

        it("should call the _addNodeToReportModel method with failed verify value and not true",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:true, args:[1], shouldThrow:false, error:new Error(), func:function(a){}});
            var value = reportProviderUnderTest._addNodeToReportModel.firstCall.args[0];
            assert.deepEqual(value._status, "Failed");
            assert.deepEqual(value._nodeType, "Verify");
            assert.deepEqual(value._name, "verify.not.check");
        });

        it("should call the _addNodeToReportModel method with expect value and not true",function(){
            reportProviderUnderTest._reportExpectEvent({name:"check", isNot:true, args:[1], shouldThrow:true, error:new Error(), func:function(a){}});
            var value = reportProviderUnderTest._addNodeToReportModel.firstCall.args[0];
            assert.deepEqual(value._status, "Failed");
            assert.deepEqual(value._nodeType, "Expect");
            assert.deepEqual(value._name, "expect.not.check");
        });

        afterEach(function () {
            delete reportProviderUnderTest.buildArgumentsTable;
            delete reportProviderUnderTest._addNodeToReportModel;
        });

    });

    describe("_getDisplayName",function() {
        beforeEach(function () {
            reportProviderUnderTest._getLeanFtTypeFromTestObject = sinon.stub();
        });

        it("should return uftDisplayName if display name is null",function(){
            var calculatedDisplayName = reportProviderUnderTest._getDisplayName({displayName:null},"uftName");
            sinon.assert.notCalled(reportProviderUnderTest._getLeanFtTypeFromTestObject);
            assert.deepEqual(calculatedDisplayName, "uftName");
        });

        it("should return object type if display name is null and UFT name is empty",function(){
            reportProviderUnderTest._getLeanFtTypeFromTestObject.returns('Browser')
            var TO = {displayName:null};
            var calculatedDisplayName = reportProviderUnderTest._getDisplayName(TO);
            sinon.assert.calledOnce(reportProviderUnderTest._getLeanFtTypeFromTestObject);
            sinon.assert.calledWith(reportProviderUnderTest._getLeanFtTypeFromTestObject, sinon.match(TO))
            assert.deepEqual(calculatedDisplayName, "[Browser]");
        });

        it("should return display name if exists on test object",function(){
            var TO = {displayName:'myName'};
            var calculatedDisplayName = reportProviderUnderTest._getDisplayName(TO);
            sinon.assert.notCalled(reportProviderUnderTest._getLeanFtTypeFromTestObject);
            assert.deepEqual(calculatedDisplayName, "myName");

            TO.displayName = "myName2";
            calculatedDisplayName = reportProviderUnderTest._getDisplayName(TO);
            assert.deepEqual(calculatedDisplayName, "myName2");
        });

        afterEach(function () {
            delete reportProviderUnderTest._getLeanFtTypeFromTestObject;
        });

    });

    describe("_updateHierarchyNames",function() {
        beforeEach(function () {
            reportProviderUnderTest._getDisplayName = sinon.stub();
        });

        it("should not change the hierarchy names if test object is null",function(){
            var hierarchy = {Name:"name", Type:"type"};
            reportProviderUnderTest._updateHierarchyNames(null, null, hierarchy);
            sinon.assert.notCalled(reportProviderUnderTest._getDisplayName);
            assert.deepEqual(hierarchy, {Name:"name", Type:"type"});
        });

        it("should not change the hierarchy names if test object is null",function(){
            var hierarchy = {Name:"name", Type:"type"};
            reportProviderUnderTest._updateHierarchyNames({}, null, null);
            sinon.assert.notCalled(reportProviderUnderTest._getDisplayName);
        });

        it("should replace the names of test object hierarchy",function(){
            var hierarchy = [{Name:"name1", Type:"type1"},{Name:"name2", Type:"type2"}];
            var parent = {_parent:{}};
            reportProviderUnderTest._getDisplayName.returns("newName");
            reportProviderUnderTest._updateHierarchyNames({_parent:parent}, ["1","2"], hierarchy);
            sinon.assert.callCount( reportProviderUnderTest._getDisplayName, 2);
            assert.deepEqual(hierarchy, [{Name:"newName", Type:"type1"},{Name:"newName", Type:"type2"}]);
        });

        it("should call to getDisplayName with correct testObject objects",function(){
            var hierarchy = [{Name:"name1", Type:"type1"},{Name:"name2", Type:"type2"}];
            var parent = {_parent:{}, name:"2"};
            reportProviderUnderTest._getDisplayName.returns("newName");
            reportProviderUnderTest._updateHierarchyNames({_parent:parent, name:"1"}, ["1","2"], hierarchy);
            assert.deepEqual(reportProviderUnderTest._getDisplayName.args[0][0].name,"1");
            assert.deepEqual(reportProviderUnderTest._getDisplayName.args[1][0].name,"2");
        });

        it("should add displyType if displayType i set",function(){
            var hierarchy = [{Name:"name1", Type:"type1"},{Name:"name2", Type:"type2"}];
            var parent = {_parent:{}, displayType: "a type"};
            reportProviderUnderTest._getDisplayName.returns("newName");
            reportProviderUnderTest._updateHierarchyNames({_parent:parent}, ["1","2"], hierarchy);
            assert.deepEqual(hierarchy, [{Name:"newName", Type:"type1", displayType: "a type"},{Name:"newName", Type:"type2"}]);
        });

        afterEach(function () {
            delete reportProviderUnderTest._getDisplayName;
        });

    });
});

describe("Report Behaviors tests", function () {
    it("should maintain 'interface' equality between DefaultReporterBehavior and EmptyReporterBehavior", function () {
        Object.keys(EmptyReporterBehavior).forEach(function (key) {
           assert(key in DefaultReporterBehavior, "Key: " + key + " is not in DefaultReporterBehavior");
        });

        Object.keys(DefaultReporterBehavior).filter(function (key) {
           return key[0] !== '_';
        }).forEach(function (key) {
            assert(key in EmptyReporterBehavior, "Key: " + key + " is not in EmptyReporterBehavior");
        });
    });
});