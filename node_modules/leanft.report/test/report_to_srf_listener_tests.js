// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

var assert = require("assert");
var sinon = require("sinon");
var ReportToSrfListener = require("../lib/report_to_srf_listener").ReportToSrfListener;
var LftPromiseManager = require("../../leanft.sdk.core/lib/promise_wrapper.js").LftPromiseManager;
var PromiseWrapper = require("../../leanft.sdk.core/lib/promise_wrapper.js").PromiseWrapper;
var Q = require("q");

function fastForward(clock, interval, times) {
    var deferred = Q.defer();
    var tickCalls = 0;
    var tick = function () {
        clock.tick(interval);
        if (++tickCalls < times)
            process.nextTick(tick);
        else
            process.nextTick(function () {
                deferred.resolve();
            });
    };
    process.nextTick(tick);

    return deferred.promise;
}

describe("ReportToSrfListener tests", function () {
    var reportListenerUnderTest;
    var reportSenderMock;
    var sessionMock;

    beforeEach(function () {
        this.clock = sinon.useFakeTimers();
        sessionMock = {
            _promiseManager: {
                syncedBranchThen: sinon.stub().returns(new PromiseWrapper(new LftPromiseManager(), Q.resolve(null)))
            },
            _config: {

            }
        };
        reportListenerUnderTest = new ReportToSrfListener(sessionMock);
        reportSenderMock = {
            sendCloseReportEvent: sinon.stub(),
            sendReportEvent: sinon.stub(),
            createReportContextForId: sinon.stub()
        };

        reportListenerUnderTest._reportSender = reportSenderMock;
    });

    afterEach(function () {
        this.clock.restore();
    });

    describe("onStructureClosedEvent", function () {
        beforeEach(function () {
            sinon.stub(reportListenerUnderTest, "_nodeToJson").returns("MyNode");
        });

        it("should not call sendCloseReportEvent if node is null", function () {
            reportListenerUnderTest.onStructureClosedEvent(null);

            sinon.assert.notCalled(reportSenderMock.sendCloseReportEvent);
        });

        it("should not call sendCloseReportEvent if the known report contexts has not send the node._id before", function () {
            reportListenerUnderTest._knownReportContexts = ["reportContextA", "reportContextB"];
            reportListenerUnderTest._sentEventsPerContext = {
                reportContextA: ["idA", "idB"],
                reportContextB: ["idA", "idC"]
            };

            reportListenerUnderTest.onStructureClosedEvent({_id: "MyId"});

            sinon.assert.notCalled(reportSenderMock.sendCloseReportEvent);
        });

        it("should call sendCloseReportEvent only to report contexts which the node._id was sent to", function () {
            reportListenerUnderTest._knownReportContexts = ["reportContextA", "reportContextB", "reportContextC"];
            reportListenerUnderTest._sentEventsPerContext = {
                reportContextA: ["idA", "idB"],
                reportContextB: ["idA", "MyId"],
                reportContextC: ["idC", "MyId"]
            };

            reportListenerUnderTest.onStructureClosedEvent({_id: "MyId"});

            return fastForward(this.clock, 1, 1).then(function () {
                sinon.assert.calledTwice(reportSenderMock.sendCloseReportEvent);
                sinon.assert.calledWith(reportSenderMock.sendCloseReportEvent, "reportContextB", "MyNode");
                sinon.assert.calledWith(reportSenderMock.sendCloseReportEvent, "reportContextC", "MyNode");
            });
        });
    });

    describe("onSdkOperation", function () {
        beforeEach(function () {
            sinon.stub(reportListenerUnderTest, "_getReportContextForTestObject");
            sinon.stub(reportListenerUnderTest, "_nodeToJson").returns("MyNode");
            sinon.stub(reportListenerUnderTest, "_reportAllParentStructureNodes");
        });

        it("should not call sendReportEvent if testObject is null and result is not application context", function () {
            var node = {
                _testObject: null,
                _result: null
            };

            reportListenerUnderTest.onSdkOperation(node);

            sinon.assert.notCalled(reportSenderMock.sendReportEvent);
        });
        
        it("should request to create report context for top parent of test object if test object != null", function () {
            var topParent = {a:"aa", _getApplicationInfo: sinon.stub()};
            var node = {
                _testObject: {_parent: topParent},
                _result: null
            };

            reportListenerUnderTest.onSdkOperation(node);

            return fastForward(this.clock, 1, 1).then(function () {
                sinon.assert.calledOnce(reportListenerUnderTest._getReportContextForTestObject);
                sinon.assert.calledWith(reportListenerUnderTest._getReportContextForTestObject, topParent);
            });
        });

        it("should request to create report context for result if test object is null and result is applicationContext", function () {
            var result = {_getApplicationInfo: sinon.stub()};
            var node = {
                _testObject: null,
                _result: result
            };

            reportListenerUnderTest.onSdkOperation(node);

            return fastForward(this.clock, 1, 1).then(function () {
                sinon.assert.calledOnce(reportListenerUnderTest._getReportContextForTestObject);
                sinon.assert.calledWith(reportListenerUnderTest._getReportContextForTestObject, result);
            });
        });

        it("should not send anything if _getReportContextForTestObject returns null", function () {
            var topParent = {a:"aa", _getApplicationInfo: sinon.stub()};
            var node = {
                _testObject: {_parent: topParent},
                _result: null
            };

            reportListenerUnderTest._getReportContextForTestObject.returns(null);

            reportListenerUnderTest.onSdkOperation(node);

            return fastForward(this.clock, 1, 1).then(function () {
                sinon.assert.notCalled(reportListenerUnderTest._reportAllParentStructureNodes);
                sinon.assert.notCalled(reportSenderMock.sendReportEvent);
            });
        });

        it("should call _reportAllParentStructureNodes with report context returned from _getReportContextForTestObject", function () {
            var topParent = {a:"aa", _getApplicationInfo: sinon.stub()};
            var node = {
                _testObject: {_parent: topParent},
                _result: null
            };

            reportListenerUnderTest._getReportContextForTestObject.returns("myReportContext");

            reportListenerUnderTest.onSdkOperation(node);

            return fastForward(this.clock, 1, 1).then(function () {
                sinon.assert.calledOnce(reportListenerUnderTest._reportAllParentStructureNodes);
                sinon.assert.calledWith(reportListenerUnderTest._reportAllParentStructureNodes, "myReportContext", node);
            });
        });

        it("should send the node with correct report context", function () {
            var topParent = {a:"aa", _getApplicationInfo: sinon.stub()};
            var node = {
                _testObject: {_parent: topParent},
                _result: null
            };

            reportListenerUnderTest._getReportContextForTestObject.returns("myReportContext");

            reportListenerUnderTest.onSdkOperation(node);

            return fastForward(this.clock, 1, 1).then(function () {
                sinon.assert.calledOnce(reportSenderMock.sendReportEvent);
                sinon.assert.calledWith(reportSenderMock.sendReportEvent, "myReportContext", "MyNode");
            });
        });
    });

    describe("_sendEventWithParentsToAllKnownContexts", function () {
        beforeEach(function () {
            sinon.stub(reportListenerUnderTest, "_nodeToJson").returns("MyNode");
            sinon.stub(reportListenerUnderTest, "_reportAllParentStructureNodes");
        });

        it("should send event and all parents to all known contexts", function () {
            reportListenerUnderTest._knownReportContexts = ["reportContextA", "reportContextB"];
            var node = {a:"aa"};

            reportListenerUnderTest._sendEventWithParentsToAllKnownContexts(node);

            return fastForward(this.clock, 1, 1).then(function () {
                sinon.assert.callOrder(reportListenerUnderTest._reportAllParentStructureNodes,
                    reportSenderMock.sendReportEvent,
                    reportListenerUnderTest._reportAllParentStructureNodes,
                    reportSenderMock.sendReportEvent);
                sinon.assert.calledWith(reportListenerUnderTest._reportAllParentStructureNodes, "reportContextA", node);
                sinon.assert.calledWith(reportListenerUnderTest._reportAllParentStructureNodes, "reportContextB", node);
                sinon.assert.calledWith(reportSenderMock.sendReportEvent, "reportContextA", "MyNode");
                sinon.assert.calledWith(reportSenderMock.sendReportEvent, "reportContextB", "MyNode");
            });
        });
    });
    
    describe("_mergeLogicalNamesToTestObjectJson", function () {
        it("should merge parent names to testObjectMap", function () {
            var node = {
                _objectPath: [{Name: "topParent"}, {Name: "anotherParent"}, {Name: "child"}]
            };

            var testObjectMap = {
                Parent: {
                    Parent: {}
                }
            };

            reportListenerUnderTest._mergeLogicalNamesToTestObjectJson(node, testObjectMap);

            assert.deepEqual(testObjectMap, {
                Name: "child",
                Parent: {
                    Name: "anotherParent",
                    Parent: {
                        Name: "topParent"
                    }
                }
            });
        });
    });
    
    describe("_reportAllParentStructureNodes", function () {
        var node = {
            _id: "aa",
            _parent: {
                _id: "zz",
                _parent: {
                    _id: "ww"
                }
            }
        };

        beforeEach(function () {
            sinon.stub(reportListenerUnderTest, "_nodeToJson");
            reportListenerUnderTest._nodeToJson.withArgs(sinon.match({_id: "zz"})).returns("parentNode1");
            reportListenerUnderTest._nodeToJson.withArgs(sinon.match({_id: "ww"})).returns("parentNode2");
        });

        it("should send all parent nodes if they were not sent before", function () {
            reportListenerUnderTest._reportAllParentStructureNodes("newContext", node);

            sinon.assert.calledTwice(reportSenderMock.sendReportEvent);
            sinon.assert.calledWith(reportSenderMock.sendReportEvent, "newContext", "parentNode1");
            sinon.assert.calledWith(reportSenderMock.sendReportEvent, "newContext", "parentNode2");
        });

        it("should send only parent nodes that were not sent before", function () {
            reportListenerUnderTest._sentEventsPerContext["contextA"] = ["zz", "anotherId"];

            reportListenerUnderTest._reportAllParentStructureNodes("contextA", node);

            sinon.assert.calledOnce(reportSenderMock.sendReportEvent);
            sinon.assert.calledWith(reportSenderMock.sendReportEvent, "contextA", "parentNode2");
        });

        it("should update inner structures so that parent nodes will not be sent twice", function () {
            reportListenerUnderTest._reportAllParentStructureNodes("newContext", node);
            reportListenerUnderTest._reportAllParentStructureNodes("newContext", node);

            sinon.assert.calledTwice(reportSenderMock.sendReportEvent);
            sinon.assert.calledWith(reportSenderMock.sendReportEvent, "newContext", "parentNode1");
            sinon.assert.calledWith(reportSenderMock.sendReportEvent, "newContext", "parentNode2");
        });
    });
    
    describe("_getReportContextForTestObject", function () {
        it("should return null if no cookie in topParent", function () {
            var topParent = {};
            var reportContext = reportListenerUnderTest._getReportContextForTestObject(topParent);
            assert.strictEqual(reportContext, null);
        });
        
        it("should call _reportSender.createReportContextForId with topParent cookie", function () {
            var topParent = {_cookie: "aaa"};
            reportSenderMock.createReportContextForId.returns(Q.resolve(null));

            reportListenerUnderTest._getReportContextForTestObject(topParent);

            sinon.assert.calledOnce(reportSenderMock.createReportContextForId);
            sinon.assert.calledWith(reportSenderMock.createReportContextForId, "aaa");
        });

        it("should return result of _reportSender.createReportContextForId", function () {
            var topParent = {_cookie: "aaa"};
            reportSenderMock.createReportContextForId.returns(Q.resolve("reportContextA"));

            return reportListenerUnderTest._getReportContextForTestObject(topParent).then(function (result) {
                assert.strictEqual(result, "reportContextA");
            });
        });

        it("should return undefined if _reportSender.createReportContextForId rejects", function () {
            var topParent = {_cookie: "aaa"};
            reportSenderMock.createReportContextForId.returns(Q.reject(null));

            return reportListenerUnderTest._getReportContextForTestObject(topParent).then(function (result) {
                assert.strictEqual(result, undefined);
            });
        });
    });
});