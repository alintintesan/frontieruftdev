// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
var processSpawn = require('child_process').spawn;
var process = require("process");
var fs = require('fs');
var RunUnitNode = require("./run_unit_node.js").RunUnitNode;
var RunUnitNodeBase = require("./run_unit_node_base.js").RunUnitNodeBase;
var RunUnitOperationNode = require("./run_unit_operation_node.js").RunUnitOperationNode;
var RunUnitVerificationNode = require("./run_unit_verification_node.js").RunUnitVerificationNode;
var ReportUtils = require("./report_utils.js").ReportUtils;
var Enums = require("./enums.js");
var Status = Enums.Status;
var CaptureLevel = Enums.CaptureLevel;
var ReportLevel = Enums.ReportLevel;
var RunUnitNodeType = Enums.RunUnitNodeType;
var ReportContextMode = Enums.ReportContextMode;
var LFTCore = require("leanft.sdk.core");
var StringUtils = LFTCore.StringUtils;
var ObjectUtils = LFTCore.ObjectUtils;
var Logger = LFTCore.Logger;
var TypeRegistry = LFTCore.TypeRegistry;
var Const = require("./const.js").Const;
var ReportModel = require("./report_model.js").ReportModel;
var Path = require("path");
var JsonReport = require("./json_report.js").JsonReport;
var AdmZip = require('adm-zip');
var DefaultReporterBehavior = require('./default_reporter_behavior.js');
var EmptyReporterBehavior = require('./empty_reporter_behavior.js');
var ConfigurationBuilder = LFTCore.ConfigurationBuilder;
var OS_Helper = require("./os_helper");
var Q = require("q");

/**
 * Reporter class
 * Provides the means to report custom events, additional data, and configuration for the report.
 * @namespace Reporter
 */

var DefaultConfig = {
    enabled: true,
    reportFolder: "RunResults",
    title: "Run Results",
    description: "",
    targetDirectory: ".",
    overrideExisting: true,
    reportLevel: ReportLevel.All,
    snapshotsLevel: CaptureLevel.Off,
};

var EmptyConfig = {
    enable: null,
    reportFolder: null,
    title: null,
    description: null,
    targetDirectory: null,
    overrideExisting: null,
    reportLevel: null,
    snapshotsLevel: null
};

/**
 * @memberof Reporter
 * @mixes Reporter.DefaultReporterBehavior
 * @private
 */
function ReporterProvider() {
    this._shouldGenerateReport = false;
    this._logger = new Logger("ReporterProvider");
    this._reportListeners = [];
    this._initReportModel();
    if (!global.__LFT_REPORTER__) {
        global.__LFT_REPORTER__ = this;
    }

    ObjectUtils.extend(this, EmptyReporterBehavior);
}

ReporterProvider.prototype = {
    _runtimeSettings: null,
    _reportModel: null,
    _logger: null,
    _reportGeneratedPath: null,
    _snapshotFolder: null,
    _reportNodesMap: [],
    _nativeObjectsMap: [],
    _session: null,
    _registered: false,
    _reportListeners: null,

    FilterLevelAsString: {
        "Off": 1000,
        "Error": 2000,
        "Warning": 3000,
        "All": 4000
    },

    NodeLevelAsString: {
        "Failed": 2000,
        "Warning": 3000,
        "Passed": 4000
    },

    ReadOnlyConfigProperties: ["reportFolder", "targetDirectory", "overrideExisting"],

    onStart: function () {
        this._registered = true;
    },

    onSuiteStart: function (data) {
        this._openReportLevel(
            {
                name: data.name,
                nodeType: RunUnitNodeType.Suite,
            });
    },

    onSpecStart: function (data) {
        this._openReportLevel(
            {
                name: data.name,
                description: "",
                nodeType: RunUnitNodeType.Spec
            }
        );
    },

    onSuiteDone: function (data) {
        if(!this._shouldGenerateReport) {
            return;
        }
        this._closeCurrentReportLevel(RunUnitNodeType.Suite, Status.Passed);
    },

    onSpecDone: function (data) {
        if(!this._shouldGenerateReport) {
            return;
        }

        if (data.status === "disabled" || data.status === "pending") {
            this._disableCurrentReportLevel(RunUnitNodeType.Spec);
        }
        if (data.status === "failed") {
            var error = data.error;

            if(error && error !== this._reportModel._latestError) {
                var runtimeError = new RunUnitNodeBase(
                    {
                        name: error.message,
                        status: Status.Failed,
                        exception: error,
                        nodeType: RunUnitNodeType.RunTimeError
                    });

                this._addNodeToReportModel(runtimeError);
            }

            this._closeCurrentReportLevel(RunUnitNodeType.Spec, Status.Failed);
            return;
        }
        this._closeCurrentReportLevel(RunUnitNodeType.Spec, Status.Passed);
    },

    onDone: function () {
        if(!this._shouldGenerateReport) {
            return;
        }
        this.generateReport();
    },

    /**
     * Initializes the specified report configuration.
     * @param {Object} [session] Initializes a reporter using the supplied session.
     * @param {Object} [inCodeConfiguration] The configuration given in code by the user
     * @memberof Reporter#
     * @private
     */
    init: function (session, inCodeConfiguration) {
        if (inCodeConfiguration && !inCodeConfiguration.report) {
            inCodeConfiguration = { report: inCodeConfiguration };
        }
        var processedConfig = new ConfigurationBuilder().build(inCodeConfiguration);
        return this._init(session, processedConfig.report);
    },

    /**
     * Initializes the specified report configuration.
     * @param {Object} [session] Initializes a reporter using the supplied session.
     * @param {Object} [processedReportConfig] The report part of configuration prepared by ConfigurationBuilder
     * @memberof Reporter#
     * @private
     */
    _init: function (session, processedReportConfig) {
        ReporterProvider.prototype._runtimeSettings = EmptyConfig;

        if (processedReportConfig.enabled) {
            ObjectUtils.extend(this, DefaultReporterBehavior);

            this._session = session;
            this._session.onBeforeCommand = this._onBeforeOperation.bind(this);
            this._session.onAfterCommand = this._onAfterOperation.bind(this);
            this._session.onAdditionalDataReceivedCommand = this._onAdditionalDataReceivedOperation.bind(this);
            this._session.onErrorCommand = this._onHandleErrorOperation.bind(this);

            this._shouldGenerateReport = false;

            ReporterProvider.prototype._runtimeSettings = ReporterProvider.prototype._runtimeSettings || DefaultConfig;
            var targetDirectory = processedReportConfig.targetDirectory;
            var reportFolder = processedReportConfig.reportFolder;

            if ((targetDirectory !== (ReporterProvider.prototype._runtimeSettings.targetDirectory)) ||
                reportFolder !== (ReporterProvider.prototype._runtimeSettings.reportFolder)) {
                ReporterProvider.prototype._runtimeSettings._generatedReportPath = null;
            }

            var currGeneratedReportPath = ReporterProvider.prototype._runtimeSettings._generatedReportPath;
            ReporterProvider.prototype._runtimeSettings = processedReportConfig;
            ReporterProvider.prototype._runtimeSettings._generatedReportPath = currGeneratedReportPath;

            if (!ReporterProvider.prototype._runtimeSettings._generatedReportPath) {
                try {
                    ReporterProvider.prototype._runtimeSettings._generatedReportPath = this._generateReportFolder();
                } catch (err) {
                    this._logger.error("failed to generate report folder: " + err + " stack: " + err.stack);
                    return;
                }
            }

            this._updateSnapshotSettings();
            this._getEnvironmentInfo();
            this._getMobileServerInfo();

            this._shouldGenerateReport = true;
        }
        else {
            ObjectUtils.extend(this, EmptyReporterBehavior);
        }
    },

    /**
     * The report configuration used for generating the report.
     */
    config: function () {
        var config = JSON.parse(JSON.stringify(ReporterProvider.prototype._runtimeSettings));

        Object.keys(ReporterProvider.prototype._runtimeSettings).forEach(function (key) {
            Object.defineProperty(config, key, {
                get: function () {
                    return ReporterProvider.prototype._runtimeSettings[key];
                }.bind(this),
                set: function (newValue) {
                    // check it the key is readOnly
                    var indexOfKey = this.ReadOnlyConfigProperties.indexOf(key);
                    if (indexOfKey !== -1) {
                        throw new Error("the '" + key + "' property is read only property!");
                    }
                    ReporterProvider.prototype._runtimeSettings[key] = newValue;
                    if(key === "snapshotsLevel"){
                        this._updateSnapshotSettings();
                    }
                }.bind(this),
                enumerable: true
            });
        }, this);

        return config;
    },

    /**
     * Returns a promise containing the runtime status of the LeanFT report.
     * @returns Promise containing {Reporter.Status} the runtime status of the LeanFT report.
     * @memberof Reporter#
     */
    getStatus: function () {
        return this._session._promiseManager.syncedBranchThen(function () {
            return ReporterProvider.prototype._reportModel._runtimeStatus;
        }.bind(this));
    },

    _updateSnapshotSettings: function () {
        if (ReporterProvider.prototype._runtimeSettings.snapshotsLevel === undefined || ReporterProvider.prototype._runtimeSettings.snapshotsLevel === null || !this._session)
            return;

        var settingsData = {
            "UpdateReportSessionSettings": {
                "SnapshotData": ReporterProvider.prototype._runtimeSettings.snapshotsLevel
            }
        };

        // update the runtime engine with current report configuration
        this._session._communication.send("UpdateReportSettingsCommand", settingsData).then(function () {
            this._logger.trace("_updateSnapshotSettings: updated engine with report settings");
        }.bind(this),
            this._handleError.bind(this));
    },

    _addEnvironmentInfo: function (info) {
        ReporterProvider.prototype._reportModel.addEnvironmentInfoData(info);
    },

    _getEnvironmentInfo: function () {
        if (!this._session)
            return;

        // update the runtime engine with current report configuration
        this._session._communication.send("GetEnvironmentInfo", null).then(function (info) {
            this._logger.trace("_getEnvironmentInfo: getting environmentInfo from engine");
            this._addEnvironmentInfo(info);
        }.bind(this),
            function (error) {
                this._logger.error("_getEnvironmentInfo: failed to get environment info from engine, error:" + error);
            });
    },

    _getMobileServerInfo: function () {
        if (!this._session)
            return;

        this._session._communication.send("GetMobileCenterConfiguration", null);
        this._session._promiseManager.syncedBranchThen(function (result) {
            var address = result ? result.URI : null;
            if (address) {
                ReporterProvider.prototype._reportModel.addGeneralInfo("MC Server Address", address);
            }
        },
            function (error) {
                this._logger.error("GetMobileCenterConfiguration: failed to get mobile info from engine, error:" + error);
            }.bind(this));
    },

    _handleError: function (error) {
        this._logger.info("setReporter: failed to update engine with report settings ");
        throw error;
    },

    _initReportModel: function () {
        ReporterProvider.prototype._reportModel = new ReportModel();
    },

    _generateReportFolder: function () {
        if (!fs.existsSync(ReporterProvider.prototype._runtimeSettings.targetDirectory)) {
            throw new Error("Target directory does not exist: " + ReporterProvider.prototype._runtimeSettings.targetDirectory);
        }

        var reportFullPath = Path.join(ReporterProvider.prototype._runtimeSettings.targetDirectory, ReporterProvider.prototype._runtimeSettings.reportFolder);

        if (!ReporterProvider.prototype._runtimeSettings.overrideExisting) {
            // generate new folder
            var i = 1;
            var resultFolder = reportFullPath;

            while (fs.existsSync(resultFolder)) {
                resultFolder = reportFullPath + i;
                i++;
            }
            ReporterProvider.prototype._runtimeSettings._generatedReportPath = Path.resolve(resultFolder);
        }
        else {
            if (fs.existsSync(reportFullPath)) {
                try {
                    ReportUtils.deleteFolder(reportFullPath);
                }
                catch (error) {
                    this._logger.warn("_generateReportFolder:: failed to delete report folder - using the existing folder, error = " + error);
                }
            }
            ReporterProvider.prototype._runtimeSettings._generatedReportPath = Path.resolve(reportFullPath);
        }

        if (!fs.existsSync(ReporterProvider.prototype._runtimeSettings._generatedReportPath)) {
            fs.mkdirSync(ReporterProvider.prototype._runtimeSettings._generatedReportPath);
        }
        var resourcesFolder = Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, "Resources");
        // create resources folder
        fs.mkdirSync(resourcesFolder);
        // create snapshot folder
        fs.mkdirSync(Path.join(resourcesFolder, "Snapshots"));
        // create user images folder
        fs.mkdirSync(Path.join(resourcesFolder, "User"));

        return ReporterProvider.prototype._runtimeSettings._generatedReportPath;
    },

    _startScreenRecording: function(useCompression, outputPath) {
        if(this._isRecording) {
            throw new Error("Screen recording is already running, stop it before starting a new one.");
        }

        if (!outputPath.toLowerCase().endsWith(".avi")) {
            throw new Error("Invalid output path, only *.avi files are supported: " + outputPath);
        }
        
        this._isRecording = true;

        var promise = this._session._promiseManager.syncedBranchThen(function () {
            var uftDeveloperHome = OS_Helper.uftDeveloperHomePathProvider[process.platform]();            
            var jvmFolder = Path.join(uftDeveloperHome, "jre", "bin");
            
            if(!fs.existsSync(jvmFolder)){
                jvmFolder =  Path.join(uftDeveloperHome, "Contents", "Home", "bin", "java");
            } 

            if(!fs.existsSync(jvmFolder)){
                jvmFolder = Path.join(process.env.JAVA_HOME, "bin");
            }

            var jvmPath = Path.join(jvmFolder, "java");
            var jarFolder = Path.join(uftDeveloperHome, "Tools", "ScreenRecorder");

            var jvmProcessEnv = process.env;
            delete jvmProcessEnv._JAVA_OPTIONS;
            delete jvmProcessEnv.JAVA_TOOL_OPTIONS;

            var jvmProcess = processSpawn(jvmPath, [
                "-jar",
                "ScreenRecorder.jar",
                "--output",
                outputPath,
                "--source",
                "desktop",
                "--skip-equal-images",
                useCompression
            ], {
                detached: true,
                cwd: jarFolder,
                env: jvmProcessEnv
            });

            var deferred = Q.defer();
            var processStartupComplete = false;
            jvmProcess.stdout.on('data', function (data) {
                if (data && data.indexOf("Screen recorder started.") > -1) {
                    this._screenRecordingProcess = jvmProcess;
                    processStartupComplete = true;
                    deferred.resolve();
                }
            }.bind(this));
            jvmProcess.on('close', function (code) {
                if (code != 0) {
                    this._isRecording = false;
                    deferred.reject(new Error("Screen recording process ended unexpectedly."));
                } 
            }.bind(this));
            setTimeout(function() {
                if (!processStartupComplete) {
                    this._isRecording = false;
                    deferred.reject(new Error("Failed to start the screen recording process."));
                }
            }, 10000);

            return deferred.promise;

        }.bind(this));

        return promise;
    },

    _stopScreenRecording: function () {
        this._isRecording = false;
        return this._session._promiseManager.syncedBranchThen(function () {
            if (this._screenRecordingProcess) {
                this._screenRecordingProcess.stdin.write("\n");
                this._screenRecordingProcess = null;
            }
        }.bind(this));
    }, 

    _reportEvent: function (stepName, description, status, image, error, base64image, additionalData) {
        return this._session._promiseManager.syncedBranchThen(function () {
            var newStep = new RunUnitNodeBase(
                {
                    name: stepName,
                    description: description,
                    htmlDescription: this._getPresentedDescription(description, additionalData),
                    status: status || Status.Passed,
                    exception: error,
                    imageDetails: { path: image, imageType: 'user' },
                    nodeType: RunUnitNodeType.CustomStep,
                    additionalData: additionalData
                });

            var snapshotData;
            if(base64image) {
                snapshotData = {
                    image: base64image,
                    type: 'user'
                };
            }

            this._addNodeToReportModel(newStep, snapshotData);
        }.bind(this));
    },

    _getPresentedDescription: function(description, additionalData){
        if(additionalData == null || additionalData.length == 0){
            return description;
        }

        var dataArr = Object.keys(additionalData).map(function(key){
            return {name: key, value: additionalData[key]};
        });

        return (description ? description + "<br><br>" : "") + "Additional data: <br>" + this.buildArgumentsTable(dataArr);
    },

    /*jshint eqnull:true */
    _reportExpectEvent: function (data) {
        return this._session._promiseManager.syncedBranchThen(function () {
            var notStr = data.isNot ? 'not.' : "";
            var expectArguments = [{name: 'expected', value: {expectArg: data.args[0]}}];

            var argumentNames = ReportUtils.getParamNames(data.func, data.args) || [];

            if (argumentNames.length > 1) {
                expectArguments = expectArguments.concat([{
                    name: 'actual',
                    value: {expectArg: data.args[1], error: data.error}
                }]);
            }
            else {
                expectArguments[0].value.error = data.error;
                expectArguments[0].name = 'condition';
            }
            var validationStep = new RunUnitVerificationNode(
                {
                    status: data.error ? Status.Failed : Status.Passed,
                    exception: data.error,
                    htmlDescription: this.buildArgumentsTable(expectArguments),
                    parameters: expectArguments.map(function (arg) {
                       return {name: arg.name, value: arg.value.expectArg};
                    })
                });

            if(data.error){
                this._reportModel.getCurrentContext()._status = Status.Failed;
            }
            
            if (data.shouldThrow) {
                validationStep._nodeType = RunUnitNodeType.Expect;
                validationStep._name = 'expect.' + notStr + data.name;
            }
            else {
                validationStep._nodeType = RunUnitNodeType.Verify;
                validationStep._name = 'verify.' + notStr + data.name;
            }
            this._addNodeToReportModel(validationStep);
        }.bind(this));
    },

    _reportVerification: function (status, data) {
        return this._session._promiseManager.syncedBranchThen(function () {
            var args = [];

            //Temporary fix for handling Warning status in custom verification.
            if(status === Status.Warning){
                status = Status.Passed;
            }

            if (data._args) {
                data._args.forEach(function (arg, index) {
                    if (arg.hasOwnProperty('value')) {
                        args.push({
                            name: arg.hasOwnProperty('name') ? arg.name : 'arg' + index,
                            value: arg.value
                        });
                    }
                });
            }

            var newStep = new RunUnitVerificationNode(
                {
                    name: data._name,
                    description: data._description,
                    htmlDescription: '<p>' + data._description + '</p><br>' + this.buildArgumentsTable(args),
                    status: status,
                    imageDetails: data._image? { path: data._image, imageType: 'user' }: undefined,
                    parameters: args,
                    verifyDesc: data._description
                });

            if(data._highlightRect) {
                newStep._reportAdditionalData.highlightArea = data._highlightRect;
            }

            this._addNodeToReportModel(newStep);
        }.bind(this));
    },

    _publishEvent: function (event, node, additionalArg) {
        this._reportListeners.forEach(function (reportListener) {
            try {
                reportListener[event](node, additionalArg);
            } catch(err) {
                this._logger.warn("reportListener" + "." + event +" failure: " + err + " stack: " + err.stack);
            }
        }, this);
    },

    _sendNonStructureEventToExternalListeners: function (node, snapshotData) {
        if(node._nodeType ===  Enums.RunUnitNodeType.Step) {
            this._publishEvent("onSdkOperation", node, snapshotData);
        } else if(node._nodeType === Enums.RunUnitNodeType.Verify || node._nodeType === Enums.RunUnitNodeType.Expect) {
            this._publishEvent("onVerification", node, snapshotData);
        } else if(node._nodeType === Enums.RunUnitNodeType.CustomStep) {
            this._publishEvent("onReportCustomEvent", node, snapshotData);
        } else if(node._nodeType === Enums.RunUnitNodeType.RunTimeError) {
            this._publishEvent("onRuntimeErrorEvent", node, snapshotData);
        } else {
            this._logger.error("_sendNonStructureEventToExternalListeners: unsupported event: " + node._nodeType);
        }
    },

    _addNodeToReportModel: function (node, snapshotData) {
        var isStructureNode = ReportUtils.isStructureNode(node);
        if (node === null || (!this._shouldGenerateReport && !isStructureNode))
            return;

        if (isStructureNode) {
            ReporterProvider.prototype._reportModel.addRunUnitNode(node);
            this._publishEvent("onStructureOpenedEvent", node);
            return;
        }

        var reportLevel = ReporterProvider.prototype._runtimeSettings.reportLevel;
        if (this.NodeLevelAsString[node._status] <= this.FilterLevelAsString[reportLevel]) {
            ReporterProvider.prototype._reportModel.addRunUnitNode(node);
        } else {
            node._id = ReporterProvider.prototype._reportModel._generateId(node);
            node._parent = ReporterProvider.prototype._reportModel._findParentToInsert(node);
        }

	    this._sendNonStructureEventToExternalListeners(node, snapshotData);
    },

    _startCdlsStep: function (stepData) {
        this._currentCdlsStepData = stepData;
    },

    _endCdlsStep: function () {
        this._currentCdlsStepData = null;
    },

    _openReportLevel: function (node) {
        var runUnitNode = new RunUnitNode(node);
        this._addNodeToReportModel(runUnitNode);
    },

    _closeAllReportLevels: function () {
        if (!this._shouldGenerateReport)
            return;
        var closedNode = ReporterProvider.prototype._reportModel.closeRootRunUnitNode();
        this._publishEvent("onStructureClosedEvent", closedNode);
    },

    _closeCurrentReportLevel: function (type, status) {
        if (!this._shouldGenerateReport)
            return;
        var closedNode = ReporterProvider.prototype._reportModel.closeCurrentRunUnitNode(type, status);
        this._publishEvent("onStructureClosedEvent", closedNode);
    },

    _disableCurrentReportLevel: function (type) {
        ReporterProvider.prototype._reportModel.removeCurrentRunUnitNode(type);
    },

    _getLeanFtTypeFromTestObject: function (testObject) {
       return ReportUtils.getLeanFtTypeFromTestObject(testObject);
    },

    _getTechnologyFromTestObject: function (testObject) {
        return ReportUtils.getTechnologyFromTestObject(testObject);
    },

    _getWiredNameOrDefault: function (leanFtType, methodName) {
        return TypeRegistry.getSdkToWiredMethodTranslation(leanFtType, methodName)[0] || methodName;
    },

    _onBeforeOperation: function (data) {
        try {
            var senderType = data.type;
            var handler = this._specialValueHandler[senderType];

            if (!handler)
                return;

            // Special scenario for UIAPro.
            // Skip invoking the pattern.methodFromUFTOne operation since
            // the information of this operation will be incomplete
            // and can't be reported properly and the first operation
            // of testObject.method will show on the report anyway.
            if (
                senderType === "NativeObject" && 
                this._reportNodesMap[data.commandId - 1] &&
                this._reportNodesMap[data.commandId - 1]._technology === "UIAPro" &&
                this._reportNodesMap[data.commandId - 1]._testObject.constructor.name === "UiObjectTO"
            ) {
                return;
            }

            var node = handler.call(this, data);
            this._reportNodesMap[data.commandId] = node;
        }
        catch (error) {
            this._logger.error("onBeforeOperation - failed. error:" + error + " stack: " + error.stack);
        }
    },

    _calculateDuration: function (node) {
        return ReportUtils.getCurrentDateTime().getTime() - node._time.getTime();
    },

    _onAfterOperation: function (data) {
        try {
            var result = data.result;
            var senderType = data.testObject.type || data.type;
            var node = this._reportNodesMap[data.commandId];

            // Special scenario for UIAPro.
            // Skip reporting the pattern.method operation and instead report
            // only the first corresponding operation, which is testObject.methodFromUFTdPattern
            // and pass the result from pattern.methodFromUFTOne to this report.
            if (senderType === "NativeObject" && this._reportNodesMap[data.commandId - 1]) {
                senderType = "TestObject";
                node = this._reportNodesMap[data.commandId - 1];
                node._result = result;
            } 

            if (!node)
                return;

            var captureLevel = ReporterProvider.prototype._runtimeSettings.snapshotsLevel;
            //Add snapshot to report only if snapshot capture level is All (if its onError or Off don't add).
            this._handleSnapshotDataHelper(node, captureLevel === CaptureLevel.All);

            // nativeObject scenario
            if (result && result._proxyId) {
                this._nativeObjectsMap[data.result._proxyId] = node.cloneNode();
                return;
            }

            var resultHandler = this._specialValueResultHandler[senderType];
            if (resultHandler)
                resultHandler.call(this, node, result, data);

            node._duration = this._calculateDuration(node);
            var snapshotData = this._createSnapshotDataFroSdkOperation(node);
            this._addNodeToReportModel(node, snapshotData);
        }
        catch (error) {
            this._logger.error("onAfterOperation - failed. error:" + error);
        }
    },

    _createSnapshotDataFroSdkOperation: function (node) {
        var snapshotData = {
            snapshotId: node._snapshotId,
            image: node._snapshotBitmapRef,
            type: 'Snapshots'
        };

        //release base64 string from memory
        delete node._snapshotBitmapRef;

        if (node._reportAdditionalData && node._reportAdditionalData.highlightArea) {
            snapshotData.highlightRect = node._reportAdditionalData.highlightArea;
        }

        return snapshotData;
    },

    /*jshint eqnull:true */
    _getDisplayName: function (testObject, uftDisplayName) {
        if (testObject.displayName != null && !StringUtils.isNullOrWhiteSpace(testObject.displayName)) {
            return testObject.displayName;
        }

        if (!uftDisplayName) {
            return '[' + this._getLeanFtTypeFromTestObject(testObject) + "]";
        }

        return uftDisplayName;
    },

    _getTestObjectHierarchy: function (testObject) {
        if (!testObject)
            return [];

        var type = this._getTechnologyFromTestObject(testObject) + "." + this._getLeanFtTypeFromTestObject(testObject);
        var parsedDisplayName = this._getDisplayName(testObject);
        return this._getTestObjectHierarchy(testObject._parent).concat([{ Type: type, Name: parsedDisplayName }]);
    },

    _handleSnapshotDataHelper: function (node, addSnaphotToReport) {
        if (addSnaphotToReport) {
            this._addSnapshotForOperation(node, node._snapshotBitmapRef);
        }
    },

    _addSnapshotForOperation: function (node, base64Image, cb) {
        try {
            var self = this;
            var imageRelativePath = Path.join(Const.SnapshotsFolder, ReportUtils.generateUUID() + ".png");
            var imageFullPath = Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, imageRelativePath);

            ReportUtils.base64_decode(base64Image, imageFullPath, function (error) {
                if (!error) {
                    if (!cb) {
                        node.imageDetails = { path: imageRelativePath, imageType: 'Snapshots' };
                        return;
                    }
                    cb({ path: imageFullPath, imageType: 'Snapshots' });
                }
                else {
                    self._logger.error("saving snapshot failed, error = " + error);
                }
            });
        }
        catch (error) {
            this._logger.error("addSnapshotForOperation failed, error = " + error);
        }
    },

    _getSnapshotHighlightArea: function (snapshotData) {
        if ((snapshotData.rectX === null) || (snapshotData.rectY === null) || (snapshotData.topRectX === null) || (snapshotData.topRectY === null))
            return null;

        var offsetX = snapshotData.rectX - snapshotData.topRectX;
        var offsetY = snapshotData.rectY - snapshotData.topRectY;
        var drawWidth = snapshotData.rectWidth;
        var drawHeight = snapshotData.rectHeight;


        return { x: offsetX, y: offsetY, height: drawHeight, width: drawWidth };
    },

    _onAdditionalDataReceivedOperation: function (data) {
        try {
            var node = this._reportNodesMap[data.commandId];
            var testObject = data.sender;
            var additionalInfo = data.additionalData;

            if(additionalInfo && additionalInfo.externalReportLink) {
                node._externalReportLink = additionalInfo.externalReportLink;
            }

            if (!testObject || !node)
                return;

            var operationAdditionalInfo = additionalInfo ? additionalInfo.AdditionalInfo || additionalInfo : null;
            var eventData = operationAdditionalInfo ? operationAdditionalInfo.ReportEventData : null;

            if (!eventData || !additionalInfo) {
                return;
            }

            var displayNameHierarchy = eventData.DispTestObjectPath;

            if (!Array.isArray(displayNameHierarchy)) {
                var nodeName = eventData.nodeName;
                this._updateHierarchyNames(testObject, [nodeName], node._objectPath);
            }
            else {
                var uftObjectNames = displayNameHierarchy.map(function (objectName) {
                    if (objectName.startsWith('[') && objectName.endsWith(']')) {
                        return objectName.substring(2, objectName.length - 2);
                    }
                    return objectName;
                });

                node._nativeType = eventData.Type || node._nativeType;
                this._updateHierarchyNames(testObject, uftObjectNames, node._objectPath);
            }

            if (node._reportAdditionalData.textRepresentation) {
                node._name = node._objectPath[node._objectPath.length - 1].Name + ".Item[\"" + node._reportAdditionalData.textRepresentation + "\"]." + node._operation;
                node._objectPath[node._objectPath.length - 1].Name = node._objectPath[node._objectPath.length - 1].Name + ".Item[\"" + node._reportAdditionalData.textRepresentation + "\"]";
            }
            else {
                node._name = node._objectPath[node._objectPath.length - 1].Name + "." + node._operation;
            }

            if (eventData.SnapshotBitmapRef || eventData.SnapshotFileName) {
                if (node._status)
                    node._snapshotBitmapRef = eventData.SnapshotBitmapRef;//store snapshot bitmap on the node, to be handled once the operation is completed.
                var snapshotData = {
                    rectX: eventData.SnapshotHighlightRectX,
                    rectY: eventData.SnapshotHighlightRectY,
                    topRectX: eventData.abs_x,
                    topRectY: eventData.abs_y,
                    rectWidth: eventData.SnapshotHighlightRectWidth,
                    rectHeight: eventData.SnapshotHighlightRectHeight
                };
                node._reportAdditionalData.highlightArea = this._getSnapshotHighlightArea(snapshotData);
                node._snapshotId = eventData.SnapshotFileName;
            }

        }
        catch (error) {
            this._logger.error("onAfterOperation - failed. error:" + error);
        }
    },

    _onHandleErrorOperation: function (data) {
        var node = this._reportNodesMap[data.commandId];

        if (!node)
            return;

        var captureLevel = ReporterProvider.prototype._runtimeSettings.snapshotsLevel;
        //Add snapshot to report only if snapshot capture level is OnError or lower (All) (if its Off don't add).
        this._handleSnapshotDataHelper(node, captureLevel <= CaptureLevel.OnError);

        node._status = Status.Failed;
        node._exception = data.error;
        node._duration = this._calculateDuration(node);
        var testObjectList = node._objectPath;


        if (testObjectList && testObjectList.length > 0 && node._nativeType) {
            var lastTestObjectInPath = testObjectList[testObjectList.length - 1];
            var objectName = lastTestObjectInPath.Name;

            // if the name that was returned by UFT equals its nativeclass - then put LeanFT type instead.
            // for example [WinButton] => Button
            if (node._nativeType === objectName) {
                lastTestObjectInPath.Name = "[" + this._getLeanFtTypeFromTestObject(data.testObject) + "]";
                node._name = lastTestObjectInPath.Type + "." + node._operation;
            }
        }

        var snapshotData = this._createSnapshotDataFroSdkOperation(node);
        this._addNodeToReportModel(node, snapshotData);
    },

    _updateHierarchyNames: function (testObject, names, hierarchy) {
        if (!testObject || !hierarchy)
            return;

        names = names.reverse();
        var TO = testObject;

        for (var i = names.length - 1; i >= 0; i--) {
            if (hierarchy[i]) {
                hierarchy[i].Name = this._getDisplayName(TO, names[i]);
                if (TO.displayType !== undefined) {
                    hierarchy[i].displayType = TO.displayType;
                }
                TO = TO._parent;
            }
        }
    },

    _buildParametersWithNames: function (data) {
        if (data.methodArguments.length === 0)
            return null;

        var argumentNames = ReportUtils.getParamNames(data.method, data.methodArguments) || [];

        if (argumentNames.length >= data.methodArguments.length) {
            // fill the argument names in the node description
            argumentNames = argumentNames.map(function (name, i) {
                return { name: name, value: data.methodArguments[i] };
            });
        }
        else {
            argumentNames = [{ name: argumentNames[0], value: data.methodArguments }];
        }

        return argumentNames;
    },

    _getTOProperties: function (testObject) {
        return ReportUtils.getTOProperties(testObject);
    },

    _getDescriptionTable: function (testObject) {
        var properties = this._getTOProperties(testObject);
        var sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";

        properties.forEach(function (property) {
            sb += "<tr><td class='ex-name'>" + property.name + "</td><td class='ex-value'>" + property.value + "</td></tr>";
        });
        sb += "</table>";
        return sb;
    },

    buildArgumentsTable: function (data, cb) {
        if (!Array.isArray(data) || data.length === 0)
            return "";

        var sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";
        for (var i = 0; i < data.length; i++) {
            if (data[i].value === undefined)
                continue;

            var containerItemsArray = [].concat(data[i].value);

            // check if data contains container items
            if (ReportUtils.isContainerItemsArray(containerItemsArray)) {
                return sb + this._argumentValueHandler.containerItemArray.call(this, { name: data[i].name, value: containerItemsArray });
            }

            sb += "<tr><td class='ex-name'>" + data[i].name + "</td><td class='ex-value'>" + this._argumentValueHandler[typeof (data[i].value)].call(this, data[i].value, cb) + "</td></tr>";
        }
        sb += ("</table>");
        return sb;
    },

    _specialValueHandler: {
        TestObject: function (data, cb) {
            var testObject = data.sender;
            var properties = this._getTOProperties(testObject);

            var objectHierarchy = this._getTestObjectHierarchy(testObject);
            var leanFtType = this._getLeanFtTypeFromTestObject(testObject);
            var technology = this._getTechnologyFromTestObject(testObject);
            var wiredName = this._getWiredNameOrDefault({
                technology: technology,
                leanftType: leanFtType
            }, data.methodName);

            var node = new RunUnitOperationNode(
                {
                    objectType: leanFtType,
                    technology: technology,
                    operation: data.methodName,
                    properties: properties,
                    objectPath: objectHierarchy,
                    name: objectHierarchy[objectHierarchy.length - 1].Name + "." + data.methodName,
                    testObject: testObject,
                    wiredName: wiredName
                });

            node._parameters = this._buildParametersWithNames(data);
            node._htmlDescription = this.buildArgumentsTable(node._parameters, cb) || "";

            if (data.caller && data.caller._getTextRepresentation) {
                node._reportAdditionalData.textRepresentation = data.caller._getTextRepresentation();
            }
            
            if (this._currentCdlsStepData) {
                node.cdlsStepData = this._currentCdlsStepData;
            }
    
            return node;
        },

        /*jshint eqnull:true */
        BrowserFactory: function (data) {
            var browserType = "";

            function methodNameForReport(methodName) {
                if (methodName.match(/launchonsrf/i)) {
                    return "launch";
                }

                return methodName;
            }

            var methodName = methodNameForReport(data.methodName);
            var browserNode = new RunUnitOperationNode(
                {
                    name: "Browser." + methodName,
                    objectType: "Browser",
                    technology: "Web",
                    operation: methodName
                });

            var overrideEvnInfo = this._getOverriddenEnvInfo("web");

            if(overrideEvnInfo != null) {
                //SRF cloud execution, get browser type and override args with info provided in the env var.
                var browserTypeKeyName = ObjectUtils.findKeyNameIgnoreCase(overrideEvnInfo, "browserType");
                browserType = browserTypeKeyName != null ? overrideEvnInfo[browserTypeKeyName] : "";
                browserNode._parameters = [{name: "browserEnvInfo", value: overrideEvnInfo}];
            } else {
                var methodArgument = data.methodArguments[0];
                if (typeof methodArgument === "string") {
                    //  for example "Chrome"
                    browserType = methodArgument;
                }
                else { //type is either BrowserFilter (for attach) or BrowserCapabilities for launchOnSrf
                    if (methodArgument) {
                        var browserTypeKey = ObjectUtils.findKeyNameIgnoreCase(methodArgument, "type");
                        if (browserTypeKey) {
                            browserType = methodArgument[browserTypeKey];
                        }
                    }
                }

                browserNode._parameters = this._buildParametersWithNames(data);
            }

            browserNode._htmlDescription = this.buildArgumentsTable(browserNode._parameters) || "";

            // hints to XmlReport that need to replace title with new title
            var browserTypeStr = browserType !== "" ? "(\"" + browserType + "\")" : "()";
            var titleToPresent = "Browser.<span class='emphasis'>" + methodName + browserTypeStr+"</span>";
            var titleToolTip = browserNode._name + browserTypeStr;

            browserNode._reportAdditionalData[Const.Title] = titleToPresent;
            browserNode._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            return browserNode;
        },

        /*jshint eqnull:true */
        MobileLab: function (data) {
            var operationTitle = data.methodArguments[0].name && typeof data.methodArguments[0].name === 'string' ? "Device.Lock(\"" + data.methodArguments[0].name + "\")" : "Device.Lock";


            var mobileNode = new RunUnitOperationNode(
                {
                    name: operationTitle,
                    objectType: "Device",
                    technology: "Mobile",
                    operation: data.methodName
                });

            var overrideEvnInfo = this._getOverriddenEnvInfo("mobile");
            if(overrideEvnInfo != null) {
                //SRF Cloud execution - override args with info provided in the env var.
                operationTitle = "Device.Lock";
                mobileNode._name = operationTitle;
                mobileNode._parameters = [{name: "deviceEnvInfo", value: overrideEvnInfo}];
            } else {
                mobileNode._parameters = this._buildParametersWithNames(data);
            }

            mobileNode._htmlDescription = this.buildArgumentsTable(mobileNode._parameters) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(operationTitle);
            var titleToolTip = operationTitle;

            mobileNode._reportAdditionalData[Const.Title] = titleToPresent;
            mobileNode._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            return mobileNode;
        },

        GuiSessionFactory: function (data) {
            var operationTitle = data.methodName;

            var mobileNode = new RunUnitOperationNode(
                {
                    name: "Session." + data.methodName,
                    objectType: "GuiSession",
                    technology: "SAPGUI",
                    operation: data.methodName,
                });

            mobileNode._parameters = this._buildParametersWithNames(data);
            mobileNode._htmlDescription = this.buildArgumentsTable(node._parameters) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(mobileNode._name);
            var titleToolTip = operationTitle;

            mobileNode._reportAdditionalData[Const.Title] = titleToPresent;
            mobileNode._reportAdditionalData[Const.TitleToolTip] = mobileNode._name;

            return mobileNode;
        },


        APITestRunner: function (data) {
            var apiNode = new RunUnitOperationNode(
                {
                    name: "UFTAPITestRunner.Run",
                    objectType: "UFTAPITestRun"
                });

            apiNode._parameters = this._buildParametersWithNames(data);
            apiNode._htmlDescription = this.buildArgumentsTable(apiNode._parameters) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(apiNode._name);


            apiNode._reportAdditionalData[Const.Title] = titleToPresent;
            apiNode._reportAdditionalData[Const.TitleToolTip] = apiNode._name;

            return apiNode;
        },

        NativeObject: function (data) {
            var node = this._nativeObjectsMap[data.sender._proxyId].cloneNode();
            node._operation = "NativeObject" + '.' + data.methodName;
            node._name = node._name.substring(0, node._name.indexOf('.')) + '.' + node._operation;
            node._htmlDescription = "";
            node._time = ReportUtils.getCurrentDateTime();

            return node;
        },

        Keyboard: function (data) {
            return this._specialValueHandler.getUtilityNode.call(this, 'Keyboard', data);
        },

        Mouse: function (data) {
            return this._specialValueHandler.getUtilityNode.call(this, 'Mouse', data);
        },

        Desktop: function (data) {
            return this._specialValueHandler.getUtilityNode.call(this, 'Desktop', data);
        },

        Aut: function (data) {
            return this._specialValueHandler.getUtilityNode.call(this, 'Aut', data);
        },

        BitmapCheckpoint: function (data) {
            var testObject = data.sender;
            var node = this._specialValueHandler.TestObject.call(this, data);
            var operationTitle = node._objectPath[node._objectPath.length - 1].Name + "." + data.methodName;
            node._nodeType = RunUnitNodeType.Mix;

            // save first argument to file
            this._addSnapshotForOperation(node, data.methodArguments[0], function (result) {
                node._reportAdditionalData.firstImage = result.path;
            });

            // save test object snapshot to file
            testObject.snapshot().then(function (base64Img) {
                this._addSnapshotForOperation(node, base64Img,
                    function (result) {
                        node._reportAdditionalData.secondImage = result.path;
                    });
            }.bind(this));

            testObject._session._promiseManager.syncedBranchThen(function () { testObject.exists(); });

            node._parameters = this._buildParametersWithNames(data);

            //eliminate argument if value is null or string empty.
            node._parameters.forEach(function(param, idx){
                if(param.value === null || param.value === ""){
                    node._parameters.splice(idx, 1);
                }
            });

            node._htmlDescription = this.buildArgumentsTable(node._parameters, function () { return true; }) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(operationTitle);
            var titleToolTip = operationTitle;

            node._reportAdditionalData[Const.Title] = titleToPresent;
            node._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            var argumentNames = ReportUtils.getParamNames(data.method, data.methodArguments) || [];

            // fill the argument names in the node additional data
            argumentNames.map(function (name, i) {
                node._reportAdditionalData[name] = data.methodArguments[i];
            });

            return node;
        },

        getBoldOperationTitle: function (operationTitle) {
            var firstIndexOfChar = operationTitle.indexOf('.');
            if (firstIndexOfChar > -1) {
                return [operationTitle.slice(0, firstIndexOfChar + 1), "<span class='emphasis'>", operationTitle.slice(firstIndexOfChar + 1)].join('') + "</span>";
            }

            return "<span class='emphasis'>" + operationTitle + "</span>";
        },

        getUtilityNode: function (utilityName, data) {
            var node = new RunUnitOperationNode(
                {
                    operation: data.methodName,
                    name: utilityName + '.' + data.methodName,
                    objectType: utilityName,
                    time: ReportUtils.getCurrentDateTime()
                });

            node._parameters = this._buildParametersWithNames(data);
            node._htmlDescription = this.buildArgumentsTable(node._parameters) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(node._name);
            var titleToolTip = node._name;

            node._reportAdditionalData[Const.Title] = titleToPresent;
            node._reportAdditionalData[Const.TitleToolTip] = titleToolTip;
            return node;
        }


    },

    _buildExternalReportLinkHTML: function (externalReportLink) {
        return StringUtils.isNullOrEmpty(externalReportLink) ? ""
            : "(<a href=\"" + externalReportLink + "\">Show results</a>)";
    },

    _specialValueResultHandler: {
        BitmapCheckpoint: function (node, result) {
            var operationTitle = node._objectPath[node._objectPath.length - 1].Name + "." + node._operation;

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(operationTitle);
            var titleToolTip = operationTitle;

            node._reportAdditionalData[Const.Title] = titleToPresent;
            node._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            if (!result)
                return;

            // verifyImageMatch
            function removeCaptureData(node) {
                function removeKey(data, key) {
                    if (data[key]) {
                        delete data[key];
                    }
                }

                removeKey(node._reportAdditionalData, "firstImage");
                removeKey(node._reportAdditionalData, "secondImage");
                removeKey(node._reportAdditionalData, "deltaImage");
            }

            if (result.imagesMatch !== undefined) {
                node._reportAdditionalData.ImageBitmapCheckPointResult = true;

                this._addSnapshotForOperation(node, result.base64EncodedDiffImage, function (result) {
                    node._reportAdditionalData.deltaImage = result.path;
                });

                node._status = result.imagesMatch ? Status.Passed : Status.Failed;

                if (node._status === Status.Passed) {
                    node._htmlDescription = this._getNodeDescriptionPrefix(node) + Const.HtmlTableCssStyle +
                        "<p><div class=data-label>Result</div>The test object matches the image</p>";

                    if ((node._reportAdditionalData.pixelTolerance === 0 && node._reportAdditionalData.rgbTolerance === 0)) {
                        removeCaptureData(node);
                    }
                }
                else {
                    node._htmlDescription = this._getNodeDescriptionPrefix(node) + Const.HtmlTableCssStyle +
                        "<p><div class=data-label>Result</div><font color='red'>The test object does not match the image</font></p>";
                }
            }
            else {
                node._reportAdditionalData.ImageBitmapCheckPointResult = true;

                var value = this._argumentValueHandler[typeof (result.point)].call(this, result.point);
                var similarity = node._reportAdditionalData.similarity || 100;
                if (result && result.actualSimilarity >= similarity) {
                    node._status = Status.Passed;

                    node._htmlDescription = this._getNodeDescriptionPrefix(node) + Const.HtmlTableCssStyle +
                        "<p><div class=data-label>Result</div> Image was located successfully" + value + "</p>";

                    // remove the additional data if similarity equals 100
                    if (node._reportAdditionalData.actualSimilarity === 100) {
                        removeCaptureData(node);
                    }
                    return;
                }

                node._status = Status.Failed;
                node._htmlDescription = this._getNodeDescriptionPrefix(node) + Const.HtmlTableCssStyle + "<p><div class=data-label>Result</div><font color='red'>Could not locate image</font></p>";

                removeCaptureData(node);
            }
        },
        APITestRunner: function (node, result) {
            var generatedPath = ReporterProvider.prototype._runtimeSettings._generatedReportPath;
            var testReportZipPath = Path.join(generatedPath, ReportUtils.generateUUID() + ".zip");
            var resourcesDirectory = Path.join(generatedPath, "Resources");
            var apiReportDirectoryName = "ApiTestReport";
            var additionalData = {};

            var buff = new Buffer(result.report);
            fs.writeFileSync(testReportZipPath, buff);

            var zip = new AdmZip(testReportZipPath);
            var index = 0;
            while (fs.existsSync(Path.join(resourcesDirectory, apiReportDirectoryName + index)))
                index++;

            var apiReportUniqueDirectory = apiReportDirectoryName + index;
            zip.extractAllTo(Path.join(resourcesDirectory, apiReportUniqueDirectory), true);


            if (result != null) {
                if (result.outParams != null && Object.keys(result.outParams).length > 0) {
                    var outputTable = null;
                    var orgStringHandler = this._argumentValueHandler.string;
                    try {
                        this._argumentValueHandler.string = function (value) {
                            return value;
                        };
                        outputTable = Const.HtmlTableCssStyle + this._argumentValueHandler.object.call(this, result.outParams);
                    }
                    finally {
                        this._argumentValueHandler.string = orgStringHandler;
                    }
                    additionalData.outputParameters = outputTable;
                }

                if (!result.status) {
                    additionalData.APIUFTReportStatus = "The API test includes one or more failed steps or checkpoints";
                }
            }

            node._status = result.status === true ? Status.Passed : Status.Failed;
            additionalData.APIUFTReportlink = Path.join("Resources", apiReportUniqueDirectory, "Report", "run_results.html");
            node._reportAdditionalData.API = additionalData;
            fs.unlinkSync(testReportZipPath);
        },
        /*jshint eqnull:true */
        BrowserFactory: function (node, result, fullData) {
            //only handle Browser returned
            if (!result || result._nativeClass !== "Browser") {
                return;
            }

            function getLabNameFromMethodName(methodName) {
                if (methodName.match(/launchonsrf/i)) {
                    return "StormRunner Functional";
                }

                return null;
            }

            var prettyLabName = getLabNameFromMethodName(fullData.methodName);

            var browserTitle = prettyLabName != null ? "Launched on " + prettyLabName : "";

            var resultProps = result._getApplicationInfo();

            var browserPropsStr = "";
            var resultPropsKeys = Object.keys(resultProps);
            if (resultPropsKeys.length > 0) {
                var argsToPresent = resultPropsKeys.map(function (key) {
                    return { name: key, value: resultProps[key] };
                });

                browserPropsStr = this.buildArgumentsTable(argsToPresent);
            }

            node._htmlDescription = this._getNodeDescriptionPrefix(node) + Const.HtmlTableCssStyle +
                "<p><div class=data-label><hr><b>Browser Information</b></div>" + browserTitle +
                " " + this._buildExternalReportLinkHTML(node._externalReportLink) + "</p>" + browserPropsStr;

            node._result = result;
        },

        Aut: function (node, result, fullData) {
            var applicationInfo = fullData.testObject._applicationInfo;

            var autPropsStr = "";
            var propsKeys = Object.keys(applicationInfo);
            if (propsKeys.length > 0) {
                var argsToPresent = propsKeys.map(function (key) {
                    return { name: key, value: applicationInfo[key] };
                });

                autPropsStr = this.buildArgumentsTable(argsToPresent);
            }

            node._htmlDescription = this._getNodeDescriptionPrefix(node) + Const.HtmlTableCssStyle +
                "<p><div class=data-label><hr><b>Application Information</b></div></p>" + autPropsStr;
        },

        MobileLab: function (node, result, fullData) {
            //only handle Device returned
            if (!result || result._nativeClass !== "Device") {
                return;
            }

            function prettifyLabName(labName) {
                if (StringUtils.isNullOrEmpty(labName))
                    return "";

                if (labName.toLowerCase() === "srf") {
                    return "StormRunner Functional";
                }

                return labName;
            }

            var prettyLabName = prettifyLabName(fullData.testObject._lab);

            var deviceTitle = StringUtils.isNullOrEmpty(prettyLabName) || prettyLabName.toLowerCase() === "mobilecenter" ?
                "" : "Locked in " + prettyLabName;

            var resultProps = result._getApplicationInfo();

            var devicePropsStr = "";
            var resultPropsKeys = Object.keys(resultProps);
            if (resultPropsKeys.length > 0) {
                var argsToPresent = resultPropsKeys.map(function (key) {
                    return { name: key, value: resultProps[key] };
                });

                devicePropsStr = this.buildArgumentsTable(argsToPresent);
            }

            node._htmlDescription = this._getNodeDescriptionPrefix(node) + Const.HtmlTableCssStyle +
                "<p><div class=data-label><hr><b>Device Information</b></div>" + deviceTitle +
                " " + this._buildExternalReportLinkHTML(node._externalReportLink) + "</p>" + devicePropsStr;

            node._result = result;
        },
        TestObject: function (node, result, fullData) {
            var testObject = fullData.testObject;

            if(testObject._nativeClass !== "Device") {
                return;
            }

            if(node._operation === "getLogs") {
                this._handleResultOfMobileOperation(node, result, "Device Logs", "Logs", "logs", "Logs");
            }

            if(node._operation === "getVitals") {
                this._handleResultOfMobileOperation(node, result, "Device Vitals", "Vitals", "vitals", "Vitals");
            }
        }
    },



    _argumentValueHandler: {
        /*jshint eqnull:true */
        object: function (value) {
            if (value === null) {
                return 'null';
            }

            // test object case
            if (value._description) {
                return this._argumentValueHandler.testObject.call(this, value);
            }

            // description case
            if (value._properties) {
                return this._getDescriptionTable({ _description: value });
            }

            // date case
            if (Object.prototype.toString.call(value) === "[object Date]") {
                return value.toLocaleString();
            }

            // array case
            if (Array.isArray(value)) {
                return "[ " + value.map(function (value) {
                    return this._argumentValueHandler[typeof (value)].call(this, value);
                }, this).join(", ") + " ]";
            }

            // containerItem case
            if (value._identifier != null) {
                return "<td class='ex-value'>" + value._identifier + "</td>";
            }

            // expected\actual arg
            if (value.hasOwnProperty('expectArg')) {
                var argumentPresentation = this._argumentValueHandler[typeof (value.expectArg)].call(this, value.expectArg);
                if (!value.error)
                    return "<p>" + argumentPresentation + "</p>";

                return "<p style='color:red;'>" + argumentPresentation + "</p>";

            }

            // regex case
            if (value instanceof RegExp){
                return value;
            }

            var sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";
            Object.keys(value).forEach(function (item) {
                sb += "<tr><td class='ex-name'>" + item + "</td><td class='ex-value'>" + this._argumentValueHandler[typeof (value[item])].call(this, value[item]) + "</td></tr>";
            }, this);
            sb += "</table>";
            return sb;
        },

        testObject: function (value) {
            var testObject = value;
            var sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";

            // display name will be presented only if exist
            if (testObject.displayName) {
                sb += "<tr><td class='ex-name'>DisplayName</td><td class='ex-value'>testObject.displayName</td></tr>";
            }

            sb += "<tr><td class='ex-name'>Description</td><td class='ex-value'>" + this._getDescriptionTable(testObject) + "</td></tr></table>";
            return sb;
        },

        string: function (value, cb) {
            var regex = new RegExp('(?:^(?:[A-Za-z0-9+\/]{4}\\n?)*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)$)');

            // check if string is base64 image string
            var match = value.match(regex);
            var method = cb || ObjectUtils.identity;

            if (match || method(value) === true) {
                return this._argumentValueHandler.image.call(this, value);
            }

            return ReportUtils.encodeHtmlEntities(value);
        },

        image: function (value) {
            var imageRelativePath = Path.join(Const.SnapshotsFolder, ReportUtils.generateUUID() + ".png");
            var imageFullPath = Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, imageRelativePath);
            ReportUtils.base64_decode(value, imageFullPath);
            return "<img src='" + imageRelativePath + "\' height='40' width='40' style = \'cursor: pointer;\' onclick=\'__uiElements.show_image_viewer_in_float_pane_by_imgelement(this) \'>";
        },

        number: function (value) {
            return value;
        },

        boolean: function (value) {
            return value;
        },

        containerItemArray: function (value) {
            var containerValues = "";
            value.value.forEach(function (containerItem) {
                containerValues += this._argumentValueHandler[typeof (containerItem)].call(this, containerItem);
            }, this);

            return "<tr><td class='ex-name'>" + value.name + "</td><td class='ex-value'>" + Const.HtmlTableCssStyle +
                "<table class='ex-table'><tr><td class='ex-name'>Identifier</td>" + containerValues + "</tr></table></td></tr></table>";
        },

        function: function (value) {
            return "";
        },

        undefined: function () {
            return "undefined";
        }
    },

    _addReportListener: function (reportListener) {
        this._reportListeners.push(reportListener);
    },

    _removeReportListener: function (reportListener) {
        var index = this._reportListeners.indexOf(reportListener);
        if(index > -1) {
            this._reportListeners.splice(index,1);
        }
    },

    _getSnapshotImagePath: function(image){
        var snapshotDir = Path.join(this._runtimeSettings._generatedReportPath, "Snapshots");
        ReportUtils.createDirectory(snapshotDir);
        var filePath = Path.join(snapshotDir, ReportUtils.generateUUID() + ".png");
        ReportUtils.base64_decode(image, filePath);

        return filePath;
    },

    _getDeviceNameFromNode: function (node) {
        if(!node._properties) {
            return null;
        }

        var namePropsFound = node._properties.filter(function (prop) {
            return prop.name === 'name';
        });

        if(namePropsFound.length === 0) {
            this._logger.warn("_getDeviceNameFromNode: name property not found");
            return null;
        }

        if(namePropsFound.length > 1) {
            this._logger.warn("number of name properties found is: " + namePropsFound.length);
        }

        return namePropsFound[0].value;
    },

    _handleResultOfMobileOperation: function (node, result, operationTitle, resourceFolder, fileConstPart, linkName) {
        var deviceName = this._getDeviceNameFromNode(node) || "device";
        StringUtils.trim(deviceName,' ');
        deviceName = deviceName.replace(' ', '_');
        deviceName = deviceName.replace(/\W/g, '');

        node._reportAdditionalData.OperationDataTitle = operationTitle;

        var currentDate = ReportUtils.getCurrentDateTimeInStringFormat();

        var relativePath = Path.join("Resources", resourceFolder);
        var dirName = Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, relativePath);
        var fileName = deviceName + "_" + fileConstPart + "_" + currentDate;
        var filePath = Path.join(dirName, fileName);

        try {
            ReportUtils.createDirectory(dirName);

            fs.writeFileSync(filePath, result);
        } catch(err) {
            this._logger.error("failed to write resource file", err);
        }
        node._htmlDescription = "<a href=\"" + Path.join(relativePath, fileName)  + "\" target=\"_blank\">" + linkName + "</a>";
    },

    _getOverriddenEnvInfo: function (envType) {
        var overrideEnvInfoStr = this._session._config.REPORT_OVERRIDE_ENVINFO;

        try {
            if (overrideEnvInfoStr != null) {
                var temp = JSON.parse(overrideEnvInfoStr);
                return temp.type === envType ? temp.data : null;
            }
        } catch(e) {
            this._logger.error("failed to parse LFTSDK_REPORT_OVERRIDE_ENVINFO value: " + e);
        }

        return null;
    },

    _contextModeToNodeType: function (contextMode) {
        switch(contextMode){
            case ReportContextMode.Verification: 
                return RunUnitNodeType.VerificationRegion;
            default:
                return RunUnitNodeType.Region;
        }
    },

    _getNodeDescriptionPrefix: function(node) {
        var descriptionPrefix = "";
        if(node._description) {
            descriptionPrefix += node._description;
        }

        if(node._htmlDescription) {
            descriptionPrefix += node._htmlDescription;
        }

        return descriptionPrefix;
    }
};

module.exports.ReporterProvider = ReporterProvider;
