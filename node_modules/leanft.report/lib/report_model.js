// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

var RunUnitNode = require("./run_unit_node.js").RunUnitNode;
var ReportUtils = require("./report_utils.js").ReportUtils;
var Const = require("./const.js");
var Enums = require("./enums.js");
var Status = Enums.Status;
var RunUnitNodeType = Enums.RunUnitNodeType;
var RunUnitNodeState = Enums.RunUnitNodeState;
var LFTCore = require("leanft.sdk.core");
var Logger = LFTCore.Logger;


function ReportModel(){
    ReportModel.prototype._environmentInfo = {};
    ReportModel.prototype._generalInfo = {};
    ReportModel.prototype._testedApplication = {};
    ReportModel.prototype._rootNode = new RunUnitNode({nodeType:RunUnitNodeType.Run});
    ReportModel.prototype._rootNode._id =  this._generateId(this._rootNode);
    ReportModel.prototype._currentNode = this._rootNode;
    ReportModel.prototype._runtimeStatus = Status.Passed;
    this._logger = new Logger("ReportModel");
}

ReportModel.prototype = {
    _rootNode:null,
    _currentNode:null,
    _environmentInfo:null,
    _generalInfo:null,
    _testedApplication:null,
    _currentTestFailed:null,
    _currentTest:null,
    _latestError:null,
    _nextId:0,
    _logger:null,
    _runtimeStatus:null,
    _currentScreenrecording:null,

    _getNextId: function () {
        return this._nextId++;
    },

    _generateId: function (/*runUnitNode*/) {
        return this._getNextId();
    },

    _getNodePath: function (currentReportNode) {
        var currentInprogressPath = [];

        while (currentReportNode !== null) {
            currentInprogressPath.push(currentReportNode);
            currentReportNode = currentReportNode._parent;
        }
        return currentInprogressPath;
    },

    _findParentToInsert: function (runUnitNode) {
        var currentInProgressPath = this._getNodePath(this._currentNode);

        var filteredArray = currentInProgressPath.filter(function (node) {
            // the node already exists and should be updated
            if (node._id === runUnitNode._id) {
                return true;
            }

            // if the same node type is added (only nodes having NestingAllowed = false)
            // then close current node and add another child of the same type to the parent node
            if (node._nodeType === runUnitNode._nodeType && !runUnitNode._isNestingAllowed) {
                return true;
            }

            if (node._state === RunUnitNodeState.InProgress || node._childRunUnits.length === 0) {
                return true;
            }

            return false;
        });

        var parent = filteredArray[0];
        return parent;
    },

    _addNodeToModel: function (runUnitNode) {
// handle multiple assemblies situation - where the run node status was already calculated
        this._rootNode._state = RunUnitNodeState.InProgress;

        runUnitNode._id = this._generateId(runUnitNode);

        var parent = this._findParentToInsert(runUnitNode);

        // case we don't need to add any new node - but just update existing one
        if (parent._id === runUnitNode._id) {
            parent.updateExistingNode(runUnitNode);
            this._currentTest = parent;
        }
        else {
            this._addNode(parent, runUnitNode);
        }

        if (runUnitNode._status === Status.Failed) {
            this._runtimeStatus = Status.Failed;
            if(runUnitNode._exception) {
                this._latestError = runUnitNode._exception;
            }
        } else if (runUnitNode._status === Status.Warning && this._runtimeStatus === Status.Passed) {
            this._runtimeStatus = Status.Warning;
        }
    },

    addRunUnitNode : function(runUnitNode) {
        if (runUnitNode._nodeType !== RunUnitNodeType.Step && runUnitNode._nodeType !== RunUnitNodeType.Mix){
            this._addNodeToModel(runUnitNode);
            return;
        }

        this._addNodeToModel(runUnitNode);
    },

    _addNode : function (parentNode, runUnitNode){
        this._currentNode = parentNode.addNodeToList(runUnitNode);

        switch(runUnitNode._nodeType){
            case RunUnitNodeType.Step :
            case RunUnitNodeType.CustomStep:
            case RunUnitNodeType.Mix:
            case RunUnitNodeType.Verify:
            case RunUnitNodeType.Expect:
                this.closeCurrentRunUnitNode(runUnitNode._nodeType,runUnitNode._status);
                break;
            case RunUnitNodeType.Test:
                this._currentTestFailed = false;
                this._currentTest = runUnitNode;
                break;
        }
    },


    closeCurrentRunUnitNode : function(type, status) {
        try {
            var node = type ? this._findNodeByType(type) : this._currentNode;
            if (!node)
                return;

            status = status || "Passed";
            node._status = status;
            this._currentNode = node;
            node.closeLevel();

            if (this._currentNode !== null && this._currentNode._parent !== null) {
                this._currentNode = this._currentNode._parent;
            }

            return node;
        }
        catch(error){
            this._logger.error("closeCurrentRunUnitNode:: failed, error = " + error);
        }
    },

    removeCurrentRunUnitNode : function(type) {
        try {
            var node = type ? this._findNodeByType(type) : this._currentNode;
            if (!node)
                return false;

            var index = node._parent._childRunUnits.indexOf(node);

            if (index > -1) {
                node._parent._childRunUnits.splice(index, 1);

                if (node._parent._childRunUnits.length === 0){
                    this._currentNode = node._parent;
                }
                return true;
            }
        }
        catch(error){
            this._logger.error("removeCurrentRunUnitNode:: failed, error = " + error);
        }
        return false;
    },

    _findNodeByType : function(type) {
        var tempCurrentNode = this._currentNode;
        while (tempCurrentNode !== null && tempCurrentNode._nodeType !== type) {
            tempCurrentNode = tempCurrentNode._parent;
        }
        return tempCurrentNode;
    },

    closeRootRunUnitNode : function() {
        var closedNode = this._rootNode._state !== RunUnitNodeState.Done ? this._rootNode : null;
        this._rootNode.closeLevel();
        return closedNode;
    },

    addGeneralInfo : function(title, description) {
        this._generalInfo["user_" + title] = description;
    },

    addEnvironmentInfo : function(title, description) {
        this._environmentInfo[title] = description;
    },

    addEnvironmentInfoData : function(data) {
        for(var member in data){
            if (!member || !data[member]){
                continue;
            }
            this.addEnvironmentInfo(member, data[member]);
        }
    },

    addTestedApplicationInfoData : function(data) {
        for(var member in data){
            if (!member.title || !member.description){
                continue;
            }
            this.addTestedApplicationInfo(member.title, member.description);
        }
    },

    addTestedApplicationInfo : function(title, description) {
        this._testedApplication.items.push(title, description);
    },

    getRuntimeStatus : function() {
        return this._runtimeStatus;
    },

    getCurrentContext: function(){
        if(ReportUtils.isStructureNode(this._currentNode)){
            return this._currentNode;
        }
        else{
            return this._currentNode._parent;
        }
    }

};

module.exports.ReportModel = ReportModel;