// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
var ReporterProvider = require("./report_provider.js");
var fs = require('fs');
var RunUnitNode = require("./run_unit_node.js").RunUnitNode;
var RunUnitNodeBase = require("./run_unit_node_base.js").RunUnitNodeBase;
var RunUnitOperationNode = require("./run_unit_operation_node.js").RunUnitOperationNode;
var ReportUtils = require("./report_utils.js").ReportUtils;
var Enums = require("./enums.js");
var Status = Enums.Status;
var CaptureLevel = Enums.CaptureLevel;
var ReportLevel = Enums.ReportLevel;
var RunUnitNodeType = Enums.RunUnitNodeType;
var LFTCore = require("leanft.sdk.core");
var StringUtils = LFTCore.StringUtils;
var ObjectUtils = LFTCore.ObjectUtils;
var Logger = LFTCore.Logger;
var Const = require("./const.js").Const;
var ReportModel = require("./report_model.js").ReportModel;
var Path = require("path");
var JsonReport = require("./json_report.js").JsonReport;
var ReportUtils = require("./report_utils.js").ReportUtils;

DefaultReporterBehavior = {
    cleanup: function () {
        // check if any testing framework (jasmine\mocha) was registered
        if (!this._registered) {
            this.generateReport();
        }
        this._session = null;
        this._reportListeners = [];
    },

    /**
     * Generates the LeanFT report.
     * @returns {null|string} the path to the LeanFT report.
     * @memberof Reporter#
     */
    generateReport: function () {
        if (!this._shouldGenerateReport) {
            return null;
        }

        try {
            this._closeAllReportLevels();


            var jsonReport = new JsonReport();
            var reportResult = jsonReport.generate(ReportModel.prototype, ReporterProvider.ReporterProvider.prototype._runtimeSettings);

            var generatedPath = ReporterProvider.ReporterProvider.prototype._runtimeSettings._generatedReportPath;

            if (!fs.existsSync(generatedPath)) {
                fs.mkdirSync(generatedPath);
            }

            var jsonPath = Path.join(generatedPath, "runresults.json");
            var cssPath = Path.join(generatedPath, "runresults.css");
            var htmlPath = Path.join(generatedPath, "runresults.html");
            var vitalsPath = Path.join(generatedPath, "Resources", "Vitals");

            var buildReport = require("leanft.report.builder");
            buildReport({ jsonPath: jsonPath, cssPath: cssPath, htmlPath: htmlPath, vitalsPath: vitalsPath }, reportResult);
            return htmlPath;
        } catch (error) {
            this._logger.error("generateReport() failed, error =" + error);
            return null;
        }
    },

    /**
     * Starts screen recording. A test cannot start multiple screen recordings in parallel. The recording file format is ".avi".
     * @param {boolean} [useCompression] if true (default) the recorded video represents a time lapse of the recorded scene, otherwise the full scene gets recorded
     * @param {string} [outputPath] target location for the recorded video, in case of a relative path, the output can be found in the report folder, if you don't specify a folder, the recording is saved in the report folder
     * @returns {Promise<void>}
     * @memberof Reporter#
     */
    startScreenRecording: function(useCompression, outputPath) { 
        if (!useCompression) {
            if (typeof useCompression !== "boolean") {
                useCompression = true;
            }
        }
        if (typeof useCompression === "string" && !outputPath) {
            outputPath = useCompression;
            useCompression = true;
        }
        
        var outputPathAbs;
        if (!outputPath) {
            var context = this._reportModel.getCurrentContext();
            if (!context || !context._name) {
                outputPath = "screenrecording.avi";
            }
            else {
                if (!context._parent || !context._parent._name) {
                    outputPath = context._name + ".avi";
                }
                else {
                    outputPath = context._parent._name + "." + context._name + ".avi";
                }
                outputPath = ReportUtils.trimHtmlTags(outputPath);
            }
            outputPathAbs = Path.join(ReporterProvider.ReporterProvider.prototype._runtimeSettings._generatedReportPath, outputPath);
        } else if (!Path.isAbsolute(outputPath)) { 
            outputPathAbs = Path.join(ReporterProvider.ReporterProvider.prototype._runtimeSettings._generatedReportPath, outputPath);
        }

        var link = "<A href=\"" + outputPath + "\">" + outputPath + "</A>";
        this._reportModel.currentScreenrecording = link;
        this.reportEvent("Screenrecording.start", link);

        return this._startScreenRecording(useCompression, outputPathAbs);
    },

    /**
     * Stops screen recording.
     * @returns {Promise<void>}
     * @memberof Reporter#
     */
    stopScreenRecording: function() {
        this.reportEvent("Screenrecording.stop", this._reportModel.currentScreenrecording);
        return this._stopScreenRecording();
    },

    /**
     * Adds a custom step to the LeanFT report with default status "Passed".
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {string} description The description of the reported step. The description is displayed in the Details pane of the report.
     * @param {Reporter.Status} [status] The status for the step.
     * @returns {void}
     * @memberof Reporter#
     */
    reportEvent: function (stepName, description, status) {
        if (!this._shouldGenerateReport)
            return;

        return this._reportEvent(stepName, description, status);
    },

    /**
     * Adds a custom step to the LeanFT report with default status "Passed" and an image.
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {string} description The description of the reported step. The description is displayed in the Details pane of the report.
     * @param {Reporter.Status} [status] The status for the step.
     * @param {string} image The Base64 image to use for the step.
     * @returns {void}
     * @memberof Reporter#
     */
    reportEventWithImage: function (stepName, description, status, image){
        if(arguments.length < 4){
             throw new Error("One or more arguments are missing.");
        }
        if (!this._shouldGenerateReport)
            return;

        if (!image) {
            return this._reportEvent(stepName, description, status);
        }
        var filePath = this._getSnapshotImagePath(image);
        return this._reportEvent(stepName, description, status, filePath, null, image);
    },

    /**
     * Adds a custom step to the LeanFT report including exception details.
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {string} description The description of the reported step. The description is displayed in the Details pane of the report.
     * @param {Error} exception The exception that occurred.
     * @returns {void}
     * @memberof Reporter#
     */
    reportErrorEvent: function (stepName, description, exception) {
        if (!this._shouldGenerateReport)
            return;

        return this._reportEvent(stepName, description, Status.Failed, null, exception);
    },

    /**
     * Adds a custom step to the LeanFT report including exception details and the Base64 image.
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {string} description The description of the reported step. The description is displayed in the Details pane of the report.
     * @param {Error} exception The exception that occurred.
     * @param {string} image The Base64 image to use for the step.
     * @returns {void}
     * @memberof Reporter#
     */
    reportErrorEventWithImage: function (stepName, description, error, image) {
        if(arguments.length < 4){
             throw new Error("One or more arguments are missing.");
        }
        if (!this._shouldGenerateReport)
            return;

        if (!image) {
            return this._reportEvent(stepName, description, Status.Failed, null, error);
        }
        var filePath = this._getSnapshotImagePath(image);
        return this._reportEvent(stepName, description, Status.Failed, filePath, error, image);
    },

    /**
     * Adds a custom step to the LeanFT report including information contained in the additionalInfo parameter
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {object} additionalInfo  A property bag containing information about the step.
     * @param {string} [additionalInfo.description] The verification description presented in the report file.
     * @param {Reporter.Status} [additionalInfo.status] The status of the step as a property of LFT.Reporter.Status
     * @param {string} [additionalInfo.imagePath] The path of the image file
     * @param {string} [additionalInfo.error] An error message
     * @param {string} [additionalInfo.image] An image as base64 string
     * @param {object} [additionalInfo.data] Additional custom data about the step as a JavaScript object
     * @returns {void}
     * @memberof Reporter#
     */
    reportEventWithAdditionalInfo: function(stepName, additionalInfo) {
        var info = additionalInfo || {};
        if(info.image && info.imagePath){
            throw new Error("additionalInfo.image is mutually exclusive with additionalInfo.imagePath. You must set only one of them.");
        }
        if(info.image){
            info.imagePath = this._getSnapshotImagePath(info.image);
        }
        return this._reportEvent(stepName, info.description, info.status, info.imagePath, info.error, info.image, info.data);
    },

    /**
     * Adds a custom verification step to the LeanFT report.
     * @param {string} status The verification result status.
     * @param {Reporter.VerificationData} verificationData The report verification data.
     * @returns {void}
     * @memberof Reporter#
     */
    reportVerification: function (status, verificationData) {
        if (!this._shouldGenerateReport)
            return;

        if (!verificationData._image) {
            return this._reportVerification(status, verificationData);
        }
        else{
            var filePath = Path.join(Const.SnapshotsFolder, ReportUtils.generateUUID() + ".png");
            ReportUtils.base64_decode(verificationData._image, Path.join(ReporterProvider.ReporterProvider.prototype._runtimeSettings._generatedReportPath, filePath));
            verificationData._image = filePath;
            return this._reportVerification(status, verificationData);
        }
    },
    /**
     * Adds a custom entry to the top section of the LeanFT report.
     * @param {string} fieldName The name of the entry.
     * @param {string} fieldValue The entry value.
     * @returns {void}
     * @memberof Reporter#
     */
    addRunInformation: function (fieldName, fieldValue) {
        if (!this._shouldGenerateReport || !fieldName || !fieldValue)
            return;

        ReporterProvider.ReporterProvider.prototype._reportModel.addGeneralInfo(fieldName, fieldValue);
    },

    /**
     * Starts a named section in the LeanFT report.
     * @param {string} contextName The section name.
     * @param {string} [contextDescription] The section description. Default=blank.
     * @param {object} additionalData The key/value object containing additional custom information.
     * @returns {Promise<void>}
     * @memberof Reporter#
     */
    startReportingContext: function (contextName, contextDescription, additionalData) {
        return this._session._promiseManager.syncedBranchThen(function () {
            this._openReportLevel(
                {
                    name: contextName,
                    description: contextDescription,
                    htmlDescription: this._getPresentedDescription(contextDescription, additionalData),
                    nodeType: RunUnitNodeType.Region,
                    additionalData: additionalData
                });
        }.bind(this));
    },

    /**
     * Starts a named section in the LeanFT report.
     * @param {string} contextName The section name.
     * @param {object} reportContextInfo  A property bag containing information about the reporting context.
     * @param {string} [reportContextInfo.description] The section description. Default=blank.
     * @param {string} [reportContextInfo.contextMode] The mode of the reporting context as an LFT.Reporter.ReportContextMode enum value: Normal or Verification. Default value = Normal.
     * @param {object} [reportContextInfo.data] Additional custom data about the reporting context as a JavaScript object.
     * @returns {void}
     * @memberof Reporter#
     */
    startReportingContextWithInfo: function (contextName, reportContextInfo) {
        var info = reportContextInfo || {};
        return this._session._promiseManager.syncedBranchThen(function () {
            this._openReportLevel(
                {
                    name: contextName,
                    description: info.description,
                    htmlDescription: this._getPresentedDescription(info.description, info.data),
                    nodeType: this._contextModeToNodeType(info.contextMode),
                    additionalData: info.data
                });
        }.bind(this));
    },

    /**
     * Ends the section in the LeanFT report.
     * @returns {Promise<void>}
     * @memberof Reporter#
     */
    endReportingContext: function () {
        return this._session._promiseManager.syncedBranchThen(function () {
            var nodeType; 
            if(this._reportModel._currentNode._nodeType == RunUnitNodeType.VerificationRegion){
                nodeType = RunUnitNodeType.VerificationRegion;
            }else{
                nodeType = RunUnitNodeType.Region;
            }
            return this._closeCurrentReportLevel(nodeType, Status.Passed);
        }.bind(this));
    },

    /**
     * Sets the snapshot capture level used to generate the LeanFT report.
     * @param {number} snapshotCaptureLevel The CaptureLevel to use.
     * @returns {void}
     * @memberof Reporter#
     */
    setSnapshotCaptureLevel: function (snapshotCaptureLevel) {
        if (snapshotCaptureLevel === undefined || snapshotCaptureLevel === null || !Number.isInteger(snapshotCaptureLevel))
            return;

        ReporterProvider.ReporterProvider.prototype._runtimeSettings.snapshotsLevel = snapshotCaptureLevel;

        this._updateSnapshotSettings();
    },
    /**
     * Starts a new spec level for the LeanFT report.
     * @param {string} specName The name of the spec, that is, the label of the spec node in the report.
     * @param {string} specDescription The spec description.
     * @returns {void}
     * @memberof Reporter#
     */
    startSpec: function (specName, specDescription) {
        return this._session._promiseManager.syncedBranchThen(function () {
            this._openReportLevel(
                {
                    name: specName,
                    description: specDescription,
                    nodeType: RunUnitNodeType.Spec,
                }
            );
        }.bind(this));
    },

    /**
     * Ends the current spec level and optionally sets the status for the spec.
     * @param {Reporter.Status} [specDescription] The status for the current spec. Default = Passed.
     * @returns {void}
     * @memberof Reporter#
     */
    endSpec: function (status) {
        return this._session._promiseManager.syncedBranchThen(function () {
            if (!this._shouldGenerateReport)
                return;

            var closedNode;
            if (status) {
                closedNode = ReporterProvider.ReporterProvider.prototype._reportModel.closeCurrentRunUnitNode(RunUnitNodeType.Spec, status);
            } else {
                closedNode = ReporterProvider.ReporterProvider.prototype._reportModel.closeCurrentRunUnitNode(RunUnitNodeType.Spec);
            }

            this._publishEvent("onStructureClosedEvent", closedNode);
        }.bind(this));
    },

    reportExpectEvent: function(data) {
        this._reportExpectEvent(data);
    },

    /**
     * Returns the status of the current execution context. The execution context is equivalent to any superior structure that contains operations (e.g.: test method, reporting context, etc.).
     * @returns {Promise}
     * @memberof Reporter#
     */
    getCurrentExecutionContextStatus: function(){
        return this._session._promiseManager.syncedBranchThen(function () {
            return ReporterProvider.ReporterProvider.prototype._reportModel.getCurrentContext()._status;
        }.bind(this));
    }
};



module.exports = DefaultReporterBehavior;
