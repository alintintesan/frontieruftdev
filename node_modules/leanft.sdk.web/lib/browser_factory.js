// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 12/10/2015.
 * This file contains the definition of the BrowserFactory that will be used to launch or attach to a browser instance.
 * @ignore
 */

var Convert = require("leanft.sdk.core").Convert;
var Core = require("leanft.sdk.core");
var Logger = Core.Logger;
var ObjectUtils = Core.ObjectUtils;
var EmulatedDevice =require("./emulated_device.js").EmulatedDevice;
var EmulatedDeviceConverter =require("./emulated_device.js").EmulatedDeviceConverter;

var Browser = require("./browser.js").Browser;
var BrowserFilter = require("./browser.js").BrowserFilter;
var ReplayErrorsBehavior = Core.ReplayErrorsBehavior;
var NotifyEventsBehavior = Core.NotifyEventsBehavior;
var RuntimeAccessMode = Core.RuntimeAccessMode;


/**
 * @typedef {Object} BrowserType - Supported browser types.
 * @property {string} Chrome  Google Chrome
 * @property {string} IE  Microsoft Internet Explorer
 * @property {string} Firefox  Mozilla Firefox
 * @property {string} Edge  Microsoft Edge
 * @property {string} Safari  Safari browser
 * @property {string} PhantomJS  The PhantomJS headless browser.<br/>
 * Note: to use PhantomJS you must install it in a specific location.<br/>
 * For details, see <a href="https://admhelp.microfocus.com/uftdev/en/latest/HelpCenter/Content/HowTo/WebApps.htm#setupPhantomJS">https://admhelp.microfocus.com/uftdev/en/latest/HelpCenter/Content/HowTo/WebApps.htm#setupPhantomJS</a>
 * @property {string} MobileCenterBrowser  The UFT Mobile web browser
 * @property {string} HeadlessChrome  Headless Chrome
 * @property {string} EdgeChromium Edge Chromium 
 * @memberof Web
 */
var BrowserType = {
    Chrome: "Chrome",
    IE: "Internet Explorer",
    Firefox: "Firefox",
    Edge: "Edge",
    Safari: "Safari",
    PhantomJS: "PhantomJS",
    MobileCenterBrowser: "MobileCenterBrowser",
    HeadlessChrome: "Chrome Headless",
    EdgeChromium: "Chromium Edge",

    _convertToRealMap : {
        chrome: "Chrome",
        ie: "Internet Explorer",
        "internet explorer": "Internet Explorer",
        firefox: "Firefox",
        edge: "Edge",
        safari: "Safari",
        phantomjs: "PhantomJS",
        mobilecenterbrowser: "MobileCenterBrowser",
        headlesschrome: "Chrome Headless",
        "chrome headless": "Chrome Headless",
        "chromium edge": "Chromium Edge"
    },

    _convertToRealValue: function (type) {
        /*jshint eqnull:true */
        if (type == null) {
            throw new Error("Browser type is undefined, null or does not exist");
        }

        var realValue = BrowserType._convertToRealMap[type.toLowerCase()];
        if (realValue == null) {
            throw new Error("Browser type is not supported: " + type);
        }

        return realValue;
    },

    _tryConvertToRealValue: function (type) {
        /*jshint eqnull:true */
        var convertedValue = BrowserType._convertToRealMap[type.toLowerCase()];

        return convertedValue != null ? convertedValue : type;
    }
};

/**
 * @class Browser
 * @memberof Web
 */
function BrowserFactory(session, mobileLab){
    this._logger = new Logger("BrowserFactory");
    if(session === null){
        throw  new Error("The communication channel is mandatory for creating BrowserFactory");
    }

    this._session = session;
    this._mobileLab = mobileLab;

    //extends other behaviors
    Core.ObjectUtils.extend(this,ReplayErrorsBehavior);
    Core.ObjectUtils.extend(this,NotifyEventsBehavior);
}
/**
 * @ignore
 */
BrowserFactory.prototype = {

    _logger: null,
    _session: null,
    _mobileLab: null,
    _internalLaunchHelper: function (browserType, browserVersion, environment, notifyAdditionalDataCallback) {
        var launchData = {
            "type": "Browser",
            "launch info": {
                "type": browserType,
                "version": browserVersion,
                "environment": environment
            }
        };

        return this._session._communication.send("LaunchApplication", launchData).then(function (launchResult) {
                this._logger.trace("launch: The result of the launch is \n" + JSON.stringify(launchResult));
                if (launchResult === null) {
                    throw new Error("launch result cannot be null");
                }
                var browser = new Browser(this._session, null, launchResult["AUT cookie"]);
                browser._useCachedProperties(launchResult.Properties, RuntimeAccessMode.accessOnUnknownOperationOrProperty);
                browser._applicationInfo = launchResult.Properties;
                if (launchResult.envInfo) {
                    browser._envInfo = launchResult.envInfo;
                }

                if(notifyAdditionalDataCallback && launchResult.AdditionalInfo) {
                    notifyAdditionalDataCallback(launchResult.AdditionalInfo);
                }

                return browser;
            }.bind(this),
            this._handleError.bind(this, browserType));
    }, /**
     * Launches a new browser tab returning an instance of {@link Web.Browser} for the launched browser.
     * The returned browser instance is valid until the tab is closed.
     * @param {string} browserType The type of browser to launch: Possible values: {@link Web.BrowserType}
     * @param {string} [browserVersion] The version of the requested version, in case it is not supplied any version will be selected.
     * @param {object} environment The environment of browser to launch.
     * @returns {Promise<Web.BrowserTO>} a promise that is fulfilled with the browser instance.
     * @memberof Web.Browser#
     * @private
     */
    _internalLaunch: function(browserType, browserVersion , environment, notifyAdditionalDataCallback) {
        this._logger.trace("launch: Called for browser type: " + browserType);

        var deviceBrowserType = this._session._config.ENVIRONMENT_DEVICE_BROWSER_TYPE;
        if(deviceBrowserType) {
            return this._mobileLab.lockDeviceById("")//empty id since it will be overridden by environment id
                .then(function (device) {
                    deviceBrowserType = BrowserType._tryConvertToRealValue(deviceBrowserType);

                    return this._internalLaunchHelper(deviceBrowserType, null, this._generateEnvironmentInfo("Device", device), notifyAdditionalDataCallback);
                }.bind(this));

        }

        return this._internalLaunchHelper(browserType, browserVersion, environment, notifyAdditionalDataCallback);
    },
    /**
     * Launches a new browser tab returning an instance of {@link Web.Browser} for the launched browser.
     * The returned browser instance is valid until the tab is closed.
     * @param {string} browserType The type of browser to launch: Possible values: {@link Web.BrowserType}
     * @returns {Promise<Web.BrowserTO>} a promise that is fulfilled with the browser instance.
     * @memberof Web.Browser#
     */
    launch: function(browserType){
        var browserTypeRealValue = BrowserType._convertToRealValue(browserType);
        if (browserTypeRealValue === BrowserType.MobileCenterBrowser) {
            throw new Error("Mobile browsers can't be launched without specifying the device to use; please use the launchDevice(BrowserType, IEnvironment)");
        }

        var func = function(id) {
            return this._internalLaunch(browserTypeRealValue, undefined, this._generateEnvironmentInfo(), this._notifyAdditionalData.bind(this, id));
        };
        var options = { sender: this, onError:false, calleeArguments: arguments, type: "BrowserFactory"};
        return this.notifyWithEvents(func, arguments, options);
    },

    /*jshint eqnull:true */
    /**
     * Launches a new browser tab in SRF, returning an instance of {@link Web.Browser} for the launched browser.
     * The returned browser instance is valid until the tab is closed.
     * @param {Object} browserCapabilities The capabilities of browser to launch.
     * @returns {Promise<Web.BrowserTO>} a promise that is fulfilled with the browser instance.
     * @memberof Web.Browser#
     * @ignore
     * @private
     */
    _launchOnSrf: function (browserCapabilities) {
        if(browserCapabilities == null) {
            throw new Error("you must provide the browser type or the browser environment settings");
        }

        var capabilities = typeof browserCapabilities === 'string' ?
            {type: browserCapabilities} :
            ObjectUtils.clone(browserCapabilities);

        var browserTypeKey = ObjectUtils.findKeyNameIgnoreCase(capabilities, "type");
        if(!browserTypeKey){
            throw new Error("Browser type must be supplied in the Browser environment settings");
        }

        capabilities.lab = "srf";

        //handle browser type
        var browserTypeRealValue = capabilities[browserTypeKey];
        //unsupported browsers should be passed as is, in case a new browser is supported by SRF and SDK is not updated
        browserTypeRealValue = BrowserType._tryConvertToRealValue(browserTypeRealValue);
        delete capabilities[browserTypeKey];


        //handle browser version
        var browserVersionKey = ObjectUtils.findKeyNameIgnoreCase(capabilities, "version");
        var browserVersion;
        if(browserVersionKey) {
            browserVersion = capabilities[browserVersionKey];
            delete capabilities[browserVersionKey];
        }

        this._convertCapabilitiesToWireFormat(capabilities);

        var func = function(id) {
            return this._internalLaunch(browserTypeRealValue,browserVersion, this._generateEnvironmentInfo("RemoteEnvironment",capabilities), this._notifyAdditionalData.bind(this, id));
        };
        var options = { sender: this, onError:false, calleeArguments: arguments, type: "BrowserFactory"};
        return this.notifyWithEvents(func, arguments, options);
    },

    _convertCapabilitiesToWireFormat: function (capabilities) {
        var osTypeKey = ObjectUtils.findKeyNameIgnoreCase(capabilities, "osType");
        var osVersionKey = ObjectUtils.findKeyNameIgnoreCase(capabilities, "osVersion");

        if(osTypeKey) {
            var platformValue = capabilities[osTypeKey];

            if(osVersionKey) {
                platformValue += " " + capabilities[osVersionKey];
                delete capabilities[osVersionKey];
            }

            capabilities.platform = platformValue;
            delete capabilities[osTypeKey];
        }

        var resolutionKey = ObjectUtils.findKeyNameIgnoreCase(capabilities, "resolution");

        if(resolutionKey) {
            var resolutionValue = capabilities[resolutionKey];
            capabilities.screenResolution = resolutionValue.toLowerCase();
            delete capabilities[resolutionKey];
        }
    },

    /**
     * Launches a new browser on emulated device returning an instance of {@link Web.BrowserTO} for the launched browser.
     * The returned browser instance is valid until the tab is closed.
     * @param {string} browserType The type of browser to launch: Possible values: {@link Web.BrowserType}
     * @param {Object | string} [emulatedDevice] The emulated device object (see members below) or the name of predefined emulated device as it appears in Chrome e.g. "iPhone 6" or "Nexus 6P"<br/>
     * Note: the predefined devices are "Galaxy S5","Nexus 5X","Nexus 6P","iPhone 5","iPhone 6","iPhone 6 Plus","iPad".
     * @param {string} [emulatedDevice.name] The name of the emulated device.
     * @param {number} [emulatedDevice.height] The height of the emulated device screen.
     * @param {number} [emulatedDevice.width] The width of the emulated device screen.
     * @param {boolean} [emulatedDevice.isTouchable = true] The touchable capability of the emulated device screen.
     * @param {number} [emulatedDevice.scaleFactor] The scale factor of the emulated device screen.
     * @param {string} [emulatedDevice.userAgent] The UserAgent property of the emulated device.
     * @param {boolean} [emulatedDevice.isMobile = true] The mobile property of the emulated device.
     * @returns {Promise<Web.BrowserTO>} a promise that is fulfilled with the browser instance.
     * @memberof Web.Browser#
     */
    launchEmulated: function(browserType, emulatedDevice){
        var browserTypeRealValue = BrowserType._convertToRealValue(browserType);
        if (typeof emulatedDevice === 'string') {
            var emulatedDeviceName = emulatedDevice;
            emulatedDevice = EmulatedDeviceConverter.convert(emulatedDeviceName);
        }

        var func = function(id) {
            return this._internalLaunch(browserTypeRealValue,undefined, this._generateEnvironmentInfo("EmulatedDevice", emulatedDevice), this._notifyAdditionalData.bind(this, id));
        };
        var options = { sender: this, onError:false, calleeArguments: arguments, type: "BrowserFactory"};
        return this.notifyWithEvents(func, arguments, options);
    },


    /**
     * Launched a new browser on the passed device returning an instance of {@link Web.BrowserTO} for the launched browser.
     * @param {string} browserType The type of browser to launch: Possible values: {@link Web.BrowserType}.
     * Note: not all devices support all browser types.
     * @param {DeviceTO} device the device to launch the browser on.
     * @returns {Promise<Web.BrowserTO>} a promise that is fulfilled with the browser instance.
     * @memberof Web.Browser#
     */
    launchDevice: function (browserType, device) {
        /*jshint eqnull:true */
        var browserTypeRealValue = browserType && browserType === 'environment-browser' ? //for SRF record, launchDevice is recorded with 'environment-browser' as the type
            browserType
            :BrowserType._convertToRealValue(browserType);

        if (device == null) {
            throw new Error("device parameter can't be null and must be a valid Mobile device test object");
        }

        var func = function(id) {
            return this._internalLaunch(browserTypeRealValue, undefined, this._generateEnvironmentInfo("Device", device), this._notifyAdditionalData.bind(this, id));
        };
        var options = { sender: this, onError:false, calleeArguments: arguments, type: "BrowserFactory"};
        return this.notifyWithEvents(func, arguments, options);
    },


    /**
     * Returns a new browser instance that is attached to a browser tab that was not opened by LeanFT (for example, a browser tab that was opened manually or by the AUT). <br/>
     * {@link Web.BrowserFilter} is used only when attaching to the browser so transient properties like {@link Web.BrowserFilter#url|Web.BrowserFilter.url}
     * and {@link Web.BrowserFilter#title|Web.BrowserFilter.title} can be used. <br/>
     * LeanFT recognizes browser windows and tabs that it opens (for example, via {@link Web.Browser#launch|Web.Browser.launch}).
     * If a browser is opened outside of the LeanFT context, you need to use the {@link Web.Browser#attach|Web.Browser.attach} method to acquire the browser tab or window.
     * For example: <br/>
     * - A browser tab was opened manually while setting up a scenario prior to running a LeanFT test.<br/>
     * - A test step clicks a link in the AUT that opens a new or replacement browser tab or window.<br/>
     * @param {Web.BrowserFilter} filter The browser filter object, or property bag which contains the browser filter properties. <br/>
     * Example: Web.Browser.attach({type: "Chrome"}).then(function (b) { browser = b; ... });
     * @returns {Promise<Web.BrowserTO>} a promise that is fulfilled with the requested browser or rejected with the relevant error.
     * @memberof Web.Browser#
     */
    attach: function(filter){
        var func = function() {
            this._logger.trace("attach: called with the following filter:" + JSON.stringify(filter));
            filter = filter || new BrowserFilter();
            var browserFilter = filter instanceof BrowserFilter ? filter : new BrowserFilter(filter);

            var attachMessage = {
                "type": "Browser",
                "launch info": {
                    Object: {
                        Class: "Browser",
                        Description: browserFilter._toJSON(),
                        Parent: null
                    }
                }
            };

            return this._session._communication.send("AttachApplication", attachMessage).then(function (attachResult) {
                    this._logger.trace("attach: The result of the launch is \n" + JSON.stringify(attachResult));
                    if (attachResult === null) {
                        throw new Error("attach result cannot be null");
                    }
                    var browser = new Browser(this._session, null, attachResult["AUT cookie"]);
                    browser._useCachedProperties(attachResult.Properties, RuntimeAccessMode.accessOnUnknownOperationOrProperty);
                    browser._applicationInfo = attachResult.Properties;
                    return browser;
                }.bind(this),
                this._handleError.bind(this, null));
        };
        var options = { sender: this, onError: false, calleeArguments: arguments, type: "BrowserFactory"};
        return this.notifyWithEvents(func, arguments, options);
    },
    /**
     * Returns a collection of all open {@link Web.Browser} instances that match the {@link Web.BrowserFilter}. <br/>
     * {@link Web.BrowserFilter} is used only when attaching to the browser so transient properties like {@link Web.BrowserFilter#url|Web.BrowserFilter.url}
     * and {@link Web.BrowserFilter#title|Web.BrowserFilter.title} can be used. <br/>
     * LeanFT recognizes browser windows and tabs that it opens (for example, via {@link Web.Browser#launch|Web.Browser.launch}).
     * If a browser is opened outside of the LeanFT context, you need to use the {@link Web.Browser#attach|Web.Browser.attach} method to acquire the browser tab or window. <br/>
     * For example:<br/>
     * - A browser tab was opened manually while setting up a scenario prior to running a LeanFT test.<br/>
     * - A test step clicks a link in the AUT that opens a new or replacement browser tab or window.<br/>
     * @param {Web.BrowserFilter} filter The browser filter object, or property bag which contains the browser filter properties. <br/>
     * Example: Web.Browser.openedBrowsers({type: "Chrome"}).then(function (blist) { list = blist; ... });
     * @returns {Promise<Web.BrowserTO[]>} a promise that is fulfilled with an array of all the requested browsers.
     * @memberof Web.Browser#
     */
    openedBrowsers: function(filter){
        var func = function() {
            this._logger.trace("openedBrowsers: called with the following filter:" + JSON.stringify(filter));
            filter = filter || new BrowserFilter();
            var browserFilter = filter instanceof BrowserFilter ? filter : new BrowserFilter(filter);

            var filterKnownBrowsersMsg = {
                "type": "Browser",
                "launch info": {
                    Object: {
                        Class: "Browser",
                        Description: browserFilter._toJSON(),
                        Parent: null
                    }
                }
            };

            return this._session._communication.send("GetAllOpenApplication",filterKnownBrowsersMsg).then(function(filteredBrowsersRes){
                    this._logger.trace("attach: The result of the launch is \n" + JSON.stringify(filteredBrowsersRes));
                    if(filteredBrowsersRes === null){
                        throw new Error("filter known browsers result cannot be null");
                    }

                    if(filteredBrowsersRes.Result === undefined){
                        throw new Error("filter known browsers result cannot be null");
                    }

                    if(filteredBrowsersRes.Result === null)
                        return [];

                    return filteredBrowsersRes.Result.map(function(browserInfo){
                        var browser = new Browser(this._session, null, browserInfo.ServerCookie);
                        browser._applicationInfo = browserInfo.Properties;
                        return browser;
                    },this);
                }.bind(this),
                this._handleError.bind(this,null));
        };
        var options = { sender: this, onError: true, calleeArguments: arguments, type: "BrowserFactory"};
        return this.notifyWithEvents(func, arguments, options);
    },
    /**
     * Handles the errors that are returned from the runtime engine. The method should be used in the rejected of the promise.
     * @param error The exception object. If the error is returned from the runtime, a field of statusCode should be included.
     * @param browserType The type of browser whose operation caused the error. Usually this parameter is binded. If null is provided, it is ignored.
     * @private
     */
    _handleError: function(browserType,error){
        //is it our error?
        if(error.statusCode !== -119){
            return this.handleReplayError(error);
        }

        this._logger.info("launch: The error is related to browser installation ");
        if(Core.StringUtils.isNullOrWhiteSpace(error.message))
            throw new Error("The specified browser " + browserType + " is not installed on the target machine.");

        throw error;
    },

    _notifyAdditionalData: function(id, additionalData) {
        this._session.fireEvent("onAdditionalDataReceivedCommand", {
            commandId: id,
            sender: this,
            additionalData: additionalData
        });
    },

    _generateEnvironmentInfo: function (type, device) {
        var env_id = this._session._config.ENVIRONMENT_ID;
        // in case we have environment id we need to override the context of the environment, execpt
        // if the type of the environment is device since  the browser is treated as application and not a context that needs to be overriden.
        if (env_id && type !== "Device") {
            this._logger.info("_generateEnvironmentInfo: overriding the given environment with environment id",env_id);
            return {
                type: "RemoteEnvironment",
                environment_id: env_id,
                environment_address: this._session._config.ENVIRONMENT_ADDRESS,
                lab : "srf"
            };
        }

        if (!type)
            return undefined;

        if (!(type in this._envGenerators))
        throw new Error("Unknown environment type " + type);

        return this._envGenerators[type].call(this, device);
    },

    _envGenerators: {
        "EmulatedDevice" : function(device){
            /*jshint eqnull:true */
            return {
                "type": "EmulatedDevice",
                "name": device.name,
                "height": device.height == null? 0 : Convert.toNumber(device.height),
                "width": device.width == null? 0 : Convert.toNumber(device.width),
                "touchable": device.isTouchable == null ? true : device.isTouchable,
                "scaleFactor": device.scaleFactor == null? 1 : Convert.toNumber(device.scaleFactor),
                "userAgent": device.userAgent,
                "mobile": device.isMobile == null ? true : device.isMobile,
                "fit": false
            };
        },

        "Device": function(device){
            var environment = device._toJSON();
            environment.type = "Device";
            return environment;
        },

        "RemoteEnvironment": function(capabilities){
            var envInfo = {type: "RemoteEnvironment"};
            envInfo = Core.ObjectUtils.extend(envInfo,capabilities);

            return envInfo;
        }
    }
};

module.exports.BrowserFactory = BrowserFactory;
module.exports.BrowserType = BrowserType;
