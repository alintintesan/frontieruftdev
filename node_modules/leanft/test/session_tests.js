require('expectations');
var Session = require("../lib/session.js").Session;
var sinon = require("sinon");
var assert = require("assert");
var Core = require("leanft.sdk.core");
var ConfigurationBuilder = Core.ConfigurationBuilder;
var nconf = require('nconf');
var RunTimeAccessMode = Core.RuntimeAccessMode;
var TestObjectParser = Core.TestObjectParser;

describe("session unit tests", function() {
    var session;
    var configurationBuilder;
    var promiseManagerMock;

    beforeEach(function () {
        promiseManagerMock = {
          config: sinon.stub(),
          init: sinon.stub()
        };
        session = new Session(promiseManagerMock);
	    configurationBuilder = new ConfigurationBuilder();
    });
    describe("_buildConfig", function () {
        describe("nconf tests", function () {
            var envStore = {};
            var argvStore = {};
            var fileStore = {};
            var sandbox;
            beforeEach(function () {
                sandbox = sinon.sandbox.create();
                sandbox.stub(Session.prototype, "_createCommunicationClient").returns({connect: sinon.stub()});
                sandbox.stub(configurationBuilder, "_handleEnvPrefix");
                ConfigurationBuilder.prototype._config = undefined;
                sandbox.stub(nconf,"env", function () {
                    return nconf.add("env", { type: 'literal', store: envStore});
                });
                sandbox.stub(nconf,"file", function (name) {
                    return nconf.add(name, { type: 'literal', store: fileStore});
                });

                sandbox.stub(nconf,"argv", function () {
                    return nconf.add("argv", { type: 'literal', store: argvStore});
                });
            });

            afterEach(function () {
                sandbox.restore();

                //clear all loaded stores
                Object.keys(nconf.stores).forEach(function(store) {
                    nconf.remove(store);
                });
            });

            it("should return default settings if none are given", function () {
                session.init({});
                assert.deepStrictEqual(session._config, {
                    address: "ws://localhost:5095",
                    autoLaunch: true,
                    mode: "replay",
                    executionSynchronization : undefined,
                    ENVIRONMENT_ID: undefined,
                    ENVIRONMENT_ADDRESS: undefined,
                    ENVIRONMENT_DEVICE_BROWSER_TYPE: undefined,
                    ENVIRONMENT_REPORT_CONTEXT: undefined,
                    lwePath: undefined,
                    report: {
                        enabled: true,
                        reportFolder: "RunResults",
                        title: "Run Results",
                        description: "",
                        targetDirectory: ".",
                        overrideExisting: true,
                        reportLevel: "All",
                        snapshotsLevel: 2 //off
                    }
                });
            });

            it("should use the lft_address from json object", function () {
                envStore.address = "aaa";
                argvStore.address = "ccc";
                fileStore.address = "zzz";
                session.init({"address": "ws://1.0.0.0.1:5095"});
                assert.strictEqual(session._config.address, "ws://1.0.0.0.1:5095");
            });

            describe("nconf calling order", function () {
                beforeEach(function () {
                    process.env.LFT_TEST_CONFIG = "myConfigFile.json";
                });

                afterEach(function () {
                    process.env.LFT_TEST_CONFIG = "";
                });

                it("should load config in the following order: env, file, argv if file environment variable exist", function () {
                    session.init();
                    sinon.assert.callOrder(nconf.argv, nconf.file, nconf.env);
                });

                it("should load config in the following order: env, argv if file environment variable doesn't exist", function () {
                    process.env.LEANFT_CONFIG = "";
                    session.init();
                    sinon.assert.callOrder(nconf.argv, nconf.env);
                });
            })
        });
    });

    describe("init", function () {
        var envStore = {};
        var argvStore = {};
        var fileStore = {};
        var sandbox;
        beforeEach(function () {
            sandbox = sinon.sandbox.create();
            sandbox.stub(Session.prototype, "_createCommunicationClient").returns({connect: sinon.stub()});
            sandbox.stub(configurationBuilder, "_handleEnvPrefix");
            ConfigurationBuilder.prototype._config = undefined;
            sandbox.stub(nconf,"env", function () {
                return nconf.add("env", { type: 'literal', store: envStore});
            });
            sandbox.stub(nconf,"file", function (name) {
                return nconf.add(name, { type: 'literal', store: fileStore});
            });

            sandbox.stub(nconf,"argv", function () {
                return nconf.add("argv", { type: 'literal', store: argvStore});
            });
            session._communication = {connect: sinon.stub()};
            session._promiseManager = {config: sinon.stub(), init: sinon.stub()};
        });

        afterEach(function () {
            sandbox.restore();

            //clear all loaded stores
            Object.keys(nconf.stores).forEach(function(store) {
                nconf.remove(store);
            });
        });

        it("should initialize config with correct configuration", function(){
                session.init({"address": "ws://1.0.0.0.1:5095"});
                sinon.assert.match(session._config.address, "ws://1.0.0.0.1:5095");
            }
        );

        it("should initialize promise manager with executionSynchronization and default address", function(){
                session.init({executionSynchronization: true});
                sinon.assert.match(session._config.address, "ws://localhost:5095");
                sinon.assert.calledOnce(session._promiseManager.config);
                sinon.assert.calledWith(session._promiseManager.config, sinon.match(true))
            }
        )
    });

    describe("getTestObjectFromJSON",function() {
        var sessionMock = null;
        beforeEach(function() {
            sinon.stub(TestObjectParser,"createTestObjectFromJson");
        });

        afterEach(function() {
            TestObjectParser.createTestObjectFromJson.restore();
        });

        it("should return testObject with correct hierarchy", function() {
            var obj = {
                Name: 'Pressme!',
                Class: 'WebElement',
                ServerCookie: 1,
                Properties: {
                },
                Parent: {
                    Name: 'UIControlStore',
                    Class: 'Page',
                    Properties: null,
                    ServerCookie: 2,
                    Parent: {
                        Name: 'UIControlStore',
                        Class: 'Browser',
                        Properties: null,
                        Parent: null,
                        ServerCookie: 3
                    }
                }
            };
            var session = new Session();
            var testObject = session.getTestObjectFromJSON(obj, RunTimeAccessMode.accessOnUnknownOperationOrProperty);
            sinon.assert.calledOnce(TestObjectParser.createTestObjectFromJson);
            sinon.assert.calledWith(TestObjectParser.createTestObjectFromJson,sinon.match(session), sinon.match(obj), RunTimeAccessMode.accessOnUnknownOperationOrProperty);
        });
    });

    describe("_handleEnvPrefix", function () {
        var nconfStoresBackup;
        var envStore;
        beforeEach(function () {
            nconfStoresBackup = nconf.stores;
            envStore = {};
            nconf.env(); //to create the store
            nconf.stores.env.store = envStore;
        });

        afterEach(function () {
            nconf.stores = nconfStoresBackup;
        });

        it("should set the readonly property of nconf.stores.env to false", function () {
            configurationBuilder._handleEnvPrefix();
            assert.strictEqual(nconf.stores.env.readOnly, false);
        });

        it("should remove env var if it does not start with prefix", function () {
            envStore.var1 = "value1";
            configurationBuilder._handleEnvPrefix();
            assert.deepStrictEqual(envStore, {});
        });

        it("should remove prefix from env var with prefix", function () {
            envStore.LFTSDK_var1 = "value1";
            configurationBuilder._handleEnvPrefix();
            assert.deepStrictEqual(envStore, {var1: "value1"});
        });

        it("should remove all env vars without prefix and remove prefix from those who start with prefix", function () {
            envStore.var1 = "value1";
            envStore.var3 = "value3";
            envStore.LFTSDK_var1 = "valueA";
            envStore.LFTSDK_var2 = "valueB";
            configurationBuilder._handleEnvPrefix();
            assert.deepStrictEqual(envStore, {
                var1: "valueA",
                var2: "valueB"
            });
        });
    });
});
