// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates.

var child_process = require('child_process');
var path = require("path");
var fs = require("fs");
var url = require("url");
var os = require('os');
var process = require("process");
var Q = require("q");
var Core = require("leanft.sdk.core");
var Logger = Core.Logger;
var log = new Logger("ServerLauncher");

var LeanFtLauncher;
try {
    LeanFtLauncher = require("leanft-launcher").LeanFtLauncher;
} catch(e) {
    log.debug("Failed to load leanft-launcher, fallback to script.");
}

var lwePathProvider = {
    "win32": function() {
        var progFiles = (process.arch === "x64") ? process.env['PROGRAMFILES(X86)'] : process.env.PROGRAMFILES;
        var UFTDeveloperHomeBin = path.join(progFiles, "Micro Focus", "UFT Developer", "lwe", "lightweight-engine");
        var leanFtHomeBin = path.join(progFiles, "Micro Focus", "LeanFT", "lwe", "lightweight-engine");
        var uftHomeBin = path.join(progFiles, "Micro Focus", "Unified Functional Testing", "lwe", "lightweight-engine");

        return Q.nfcall(fs.access, UFTDeveloperHomeBin).then(function() {
            return UFTDeveloperHomeBin;
        }).catch(function() {
            return Q.nfcall(fs.access, leanFtHomeBin).then(function() { return leanFtHomeBin; });
        }).catch(function() {
            return uftHomeBin;
        });
    },
    "linux": function() {
        var UFTDeveloperHome = "/opt/uftdeveloper/lwe/lightweight-engine";
        return Q.nfcall(fs.access, UFTDeveloperHome).then(function() {
            return UFTDeveloperHome;
        }).catch(function() {
            return "/opt/leanft/lwe/lightweight-engine/";
        });
    },
    "darwin": function() {
        var userUFTDeveloperHome = path.join(process.env.HOME, "Applications", "UFTDeveloper", "lwe", "lightweight-engine");
        var userLeanFtHome = path.join(process.env.HOME, "Applications", "LeanFT", "lwe", "lightweight-engine");
        var applicationsUFTDeveloperHome = path.join("/", "Applications", "UFTDeveloper", "lwe", "lightweight-engine");
        var applicationsLeanFtHome = path.join("/", "Applications", "LeanFT", "lwe", "lightweight-engine");

        return Q.nfcall(fs.access, userUFTDeveloperHome).then(function() {
            return userUFTDeveloperHome;
        }).catch(function() {
            return Q.nfcall(fs.access, userLeanFtHome).then(function() { return userLeanFtHome; });
        }).catch(function() {
            return Q.nfcall(fs.access, applicationsUFTDeveloperHome).then(function() { return applicationsUFTDeveloperHome; });
        }).catch(function() {
            return applicationsLeanFtHome;
        });
        
    }
};

// part of the path to launch leanft script relative to leanft home dir
var leanftScriptPath = {
    "win32": path.join("bin", "leanft.bat"),
    "linux": path.join("bin", "leanft"),
    "darwin": path.join("leanft")
};

/**
 * Server Launcher - performs launch/stop of LeanFT engine
 *
 * @class
 * @ignore
*/
function ServerLauncher(config, promiseManager) {
    this._config = config;
    this._promiseManager = promiseManager;
}

ServerLauncher.prototype = {
    _config: undefined,
    _localAddressesList: undefined,
    _wasStartedByMe: false,
    _promiseManager: null,

   /**
    * launches LeanFT engine if config.autoLaunch=true and config.address has local address
    * @returns Promise which is resolved:
    *               - if should be launched when engine is up.
    *               - if should NOT be launched, resolved at once.
    * @ignore
    */
    launchIfNeeded: function() {
        log.trace("launchIfNeeded(), config.autoLaunch=" + this._config.autoLaunch);
        return this._config.autoLaunch && this._isLocalAddress() ? this._start() : this._promiseManager.syncedBranchThen(function(){return Q.when();});
    },

     /**
      * stops LeanFT engine if was started by this ServerLauncher
      * @returns Promise which is resolved:
      *               - if started by this code, when engine is down
      *               - if NOT started by this code, resolved at once.
      * @ignore
      */
    stopIfNeeded: function() {
        log.trace("stopIfNeeded(), _wasStartedByMe=" + this._wasStartedByMe);
        return this._wasStartedByMe ? this._stop() : this._promiseManager.syncedBranchThen(function(){return Q.when();});
    },

    _start: function() {
        return this._getLwePath().then(function(lwePath) {
            return this._runLeanFtLauncher("start", lwePath);
        }.bind(this))
        .then(function(exitCode) {
            log.trace("_start(), exitCode=" + exitCode);
            if (exitCode === 0) {
                this._wasStartedByMe = true;
                log.debug("LeanFT runtime engine started successfully");
            }
        }.bind(this));
    },

    _stop: function() {
        return this._getLwePath().then(function(lwePath) {
            return this._runLeanFtLauncher("stop", lwePath).then(function(exitCode) {
                log.trace("_stop(), exitCode=" + exitCode);
                if (exitCode === 0) {
                    log.debug("LeanFT runtime engine has stopped successfully");
                }
            });
        }.bind(this));
    },

    // resolves promise with path to lwe, either specified by parameters or in the default paths
    _getLwePath: function() {
        if (this._config.lwePath) {
            log.trace("_getLwePath(), using config.lwePath lwePath=" + this._config.lwePath);
            return this._promiseManager.syncedBranchThen(function(){ return this._config.lwePath;}.bind(this));
        }

        if (process.env.LEANFT_HOME) {
            var lwePath = path.join(process.env.LEANFT_HOME, "lwe", "lightweight-engine");
            log.trace("_getLwePath(), using LEANFT_HOME, lwePath=" + lwePath);
            return this._promiseManager.syncedBranchThen(function(){ return lwePath;});
        }

        return this._promiseManager.syncedBranchThen(function() { return lwePathProvider[process.platform]();});
    },

    _runLeanFtLauncher: function(command, lwePath) {
        return LeanFtLauncher ? this._runLauncherLibrary(command, lwePath) : this._runLauncherScript(command, lwePath);
    },

    _runLauncherScript: function(command, lwePath) {
        return this._promiseManager.syncedBranchThen(function() {
            var launcherPath = path.join(lwePath, "..", "..", leanftScriptPath[process.platform]);

            return Q.nfcall(fs.access, launcherPath).catch(function (err) {
                return Q.reject(new Error("unable to find LeanFT Runtime engine at the default location, " +
                    "please specify env. variable LEANFT_HOME or settings parameter lwePath."));
            }).then(function () {
                var deferred = Q.defer();
                var args = [command, "--silentLauncher", "--lwePort", this._getLwePort()];
                log.debug("executing leanft-launcher at " + launcherPath + ", args=" + args);
                var child = child_process.execFile(launcherPath, args, { cwd: lwePath });

                child.on("exit", function (exitCode) {
                    deferred.resolve(exitCode);
                });

                child.on("error", function (err) {
                    deferred.reject(err);
                });

                return deferred.promise;
            }.bind(this));
        }.bind(this));
    },

    _runLauncherLibrary: function(command, lwePath) {
        var options = {
            printInfoOnLaunch: false,
            lwePath: lwePath,
            lwePort: this._getLwePort(),
            logger: new Logger("LeanFtLauncher")
        };

        log.debug("LeanFtLauncher options: lwePath=" + options.lwePath + ", lwePort=" + options.lwePort);

        var launcher = new LeanFtLauncher(options);

        return this._promiseManager.syncedBranchThen(function() { return launcher.handleCommand(command, []);});
    },

    _isLocalAddress: function() {
        if (!this._config.address) {
            log.debug("given config.address is empty");
            return false;
        }

        if (!this._localAddressesList) {
            var ifaces = os.networkInterfaces();
            var ifacesInfo = [];
            Object.keys(ifaces).forEach(function(ifaceName){
                var addressesInfo = ifaces[ifaceName];
                ifacesInfo = ifacesInfo.concat(addressesInfo.filter(function(interfaceInfo){
                    return "IPv4" === interfaceInfo.family;
                }));
            });

            this._localAddressesList = [{address: "localhost"}].concat(ifacesInfo);
        }

        log.trace("_isLocalAddress(), config.address=" + this._config.address);
        var hostname = url.parse(this._config.address).hostname;

        var isLocal = this._localAddressesList.filter(function(iface) {
            return hostname === iface.address;
        }).length !== 0;

        if (!isLocal) {
            log.debug("given address is not local, config.address=" + this._config.address);
        }

        return isLocal;
    },

    _getLwePort: function() {
        return url.parse(this._config.address).port;
    }
};

module.exports.ServerLauncher = ServerLauncher;
