// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

var Core = require("leanft.sdk.core");
var Logger = Core.Logger;
var CommunicationClient  = Core.CommunicationClient;
var TestObjectFactory = Core.TestObjectFactory;
var delay = Core.delay;
var waitUntil = Core.waitUntil;
var ArrayUtils = Core.ArrayUtils;
var TestObjectParser = Core.TestObjectParser;
var ConfigurationBuilder = Core.ConfigurationBuilder;


/**
 * SDK namespace - The LeanFT SDK base class.
 * @namespace SDK
 */

function Session(promiseManager){
    this._logger = new Logger("Session");
    this.factory = new TestObjectFactory(this);
    this._promiseManager = promiseManager;
}

Session.prototype = {
    _logger: null,
    _communication: null,
    factory:  null,
    _promiseManager: null,
    onBeforeCommand: null,
    onAfterCommand: null,
    onAdditionalDataReceivedCommand: null,
    onErrorCommand: null,
    _config: null,

    /*jshint unused:true, eqnull:true */
    init: function (config, libraryMode) {
        this._initWithoutConnect(config, libraryMode);
        return this._connect();
    },

    buildConfig: function(config, libraryMode) {
        return new ConfigurationBuilder().build(config, libraryMode);
    },

    /**
     * Builds configuration from passed config, configures PromiseManager and CommunicationClient
     * @param config the configuration as passed by user
     * @return the processed configuration.
     * @private
     */
    _initWithoutConnect: function (config, libraryMode) {
        var processedConfig = this.buildConfig(config, libraryMode);

        this._promiseManager.config(processedConfig.executionSynchronization);
        this._promiseManager.init();
        this._config = processedConfig;
        this._logger.info("init: going to use the following configuration:\n" + JSON.stringify(this._config));

        this._communication = this._createCommunicationClient(this._config);
        return this._config;
    },

    _connect: function () {
        return this._communication.connect();
    },

    getTestObjectFromJSON: function(jsonInfo, runTimeAccessMode){
        return TestObjectParser.createTestObjectFromJson(this, jsonInfo, runTimeAccessMode);
    },

    /*jshint eqnull:true */
    _getLeanFtTypeFromNativeType: function (micclass) {
      var testObject = this.factory.createByNativeClass(micclass);
      if(testObject == null) {
          return null;
      }

      return testObject._description.leanFTType;
    },

    /*jshint eqnull:true */
    _getNativeTypeFromLeanFtType: function (leanFtType) {
      var testObject = this.factory.create(leanFtType);

      if(testObject == null) {
          return null;
      }

      return testObject._nativeClass;
    },

    _createCommunicationClient: function (config, options) {
        return new CommunicationClient(config, this._promiseManager, options);
    },

    cleanup: function() {
        this._logger.info("cleanup: Called");
        var disconnectDefer = this._communication.disconnect();
        this._address = null;
        return disconnectDefer;
    },

    fireEvent: function(eventName){
        if(!this[eventName]){
            return;
        }

        var args = ArrayUtils.toArray(arguments);
        args.splice(0,1);

        return this[eventName].apply(undefined,args);
    },

    /**
     * Delays the execution of the next LeanFT command by the specified length of time (in milliseconds).
     * @param {number} milliseconds The length of time (in milliseconds) to delay the execution of the next LeanFT command.
     * @returns {Promise<void>} a promise fulfilled when the length of time (in milliseconds) since the previous LeanFT command has passed.
     * @memberof SDK#
     */
    delay: function (milliseconds) {
        return delay(this._promiseManager, milliseconds);
    },

    /**
     * A function representing a condition to check in the waitUntil function.
     * @callback Condition
     * @returns {boolean | Promise<boolean>} a boolean value or a promise fulfilled with a boolean value indicating whether the condition is met.
     * @memberof SDK#
     */

    /**
     * Waits until a certain condition is met (that is, waits until the specified checkFunc function is resolved to true), or the timeout elapses.
     * This method is useful for synchronizing your test with your application.
     * @param {SDK.Condition} checkFunc The condition that must be met.
     * @param {number} [timeout] The length of time to wait (in milliseconds) to meet the condition.
     * @returns {Promise<boolean>} a promise fulfilled with true if checkFunc is resolved to true before the timeout is reached; otherwise, false.
     * @memberof SDK#
     */
    waitUntil: function(checkFunc, timeout) {
        return waitUntil(this._promiseManager, checkFunc, timeout);
    }
};

module.exports.Session = Session;
