// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 06/03/2016.
 */

var assert = require("assert");
var sinon = require("sinon");
var Core = require("leanft.sdk.core");

describe("TabStrip Description", function () {

    var TabStrip = require("../lib/tab_strip.js").TabStrip;    
    var tabStripDescriptionUnderTest;
    
    beforeEach(function () {
        comboBoxDescriptionUnderTest = new TabStrip({});
    });

    describe("Constructor", function () {
        it("should assign 'WPF' and 'TabStrip' LeanFT type", function () {
            tabStripDescriptionUnderTest = new TabStrip();
            assert.deepEqual(tabStripDescriptionUnderTest.leanFTType, {
                technology: "WPF",
                leanftType: "TabStrip"
            });
        });
    });

    describe("name method", function () {
        it("should add 'name' to _properties when value is given", function () {
            tabStripDescriptionUnderTest.name("name");
            assert.strictEqual(tabStripDescriptionUnderTest._properties["name"], "name");
        });

        it("should return this - builder pattern when value is given", function () {
            var result = tabStripDescriptionUnderTest.name("name");
            assert.strictEqual(result, tabStripDescriptionUnderTest);
        });

        it("should remove 'name' from _properties when value is null", function () {
            tabStripDescriptionUnderTest._properties["name"] = "name";
            tabStripDescriptionUnderTest.name(null);
            assert(!("name" in tabStripDescriptionUnderTest._properties));
        });

        it("should return the value of 'name' from _properties when value is not given", function () {
            tabStripDescriptionUnderTest._properties["name"] = "name";
            var name = tabStripDescriptionUnderTest.name();
            assert.equal(name, "name");
        });
    });

    describe("tabs method", function () {
        it("should add 'all items' to _properties when value is given", function () {
            tabStripDescriptionUnderTest.tabs(["item1", "item2"]);
            assert.strictEqual(tabStripDescriptionUnderTest._properties["all items"], "item1\nitem2");
        });

        it("should add 'all items' to _properties when value is given using property bag", function () {
            tabStripDescriptionUnderTest = TabStrip({
                tabs: ["item1", "item2"]
            });
            assert.strictEqual(tabStripDescriptionUnderTest._properties["all items"], "item1\nitem2");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = tabStripDescriptionUnderTest.tabs(["item1", "item2"]);
            assert.strictEqual(result, tabStripDescriptionUnderTest);
        });

        it("should remove 'all items' from _properties when value is null", function () {
            tabStripDescriptionUnderTest._properties["all items"] = "item1\nitem2";
            tabStripDescriptionUnderTest.tabs(null);
            assert(!("all items" in tabStripDescriptionUnderTest._properties));
        });
        it("should return the value of 'all items' from _properties when value is not given", function () {
            tabStripDescriptionUnderTest._properties["all items"] = "item1\nitem2";
            var value = tabStripDescriptionUnderTest.tabs();
            assert.deepEqual(value, ["item1", "item2"]);
        });

        it("should not change value of 'all items' in _properties when get is called", function () {
            tabStripDescriptionUnderTest._properties["all items"] = "item1\nitem2";
            tabStripDescriptionUnderTest.tabs();
            assert.strictEqual(tabStripDescriptionUnderTest._properties["all items"], "item1\nitem2");
        });
    });

    describe("selectedTab method", function () {
        it("should add 'selection' to _properties when value is given", function () {
            tabStripDescriptionUnderTest.selectedTab("selectedTab");
            assert.strictEqual(tabStripDescriptionUnderTest._properties["selection"], "selectedTab");
        });

        it("should return this - builder pattern when value is given", function () {
            var result = tabStripDescriptionUnderTest.selectedTab("selectedTab");
            assert.strictEqual(result, tabStripDescriptionUnderTest);
        });

        it("should remove 'selection' from _properties when value is null", function () {
            tabStripDescriptionUnderTest._properties["selection"] = "selectedTab";
            tabStripDescriptionUnderTest.selectedTab(null);
            assert(!("selection" in tabStripDescriptionUnderTest._properties));
        });

        it("should return the value of 'selection' from _properties when value is not given", function () {
            tabStripDescriptionUnderTest._properties["selection"] = "selectedTab";
            var result = tabStripDescriptionUnderTest.selectedTab();
            assert.equal(result, "selectedTab");
        });
    });

});

describe("TabStrip TO", function () {

    var TabStripTO = require("../lib/tab_strip.js").TabStripTO;
    var tabStripTOUnderTest;

    beforeEach(function () {
        tabStripTOUnderTest = new TabStripTO();
        sinon.stub(tabStripTOUnderTest, "_getROProperty");
        sinon.stub(tabStripTOUnderTest, "_executeWithEvents");
    });

    afterEach(function () {
        tabStripTOUnderTest._getROProperty.restore();
        tabStripTOUnderTest._executeWithEvents.restore();
    });

    describe("name method", function () {
        it("should execute _getROProperty 'name'", function () {
            tabStripTOUnderTest.name();
            sinon.assert.calledOnce(tabStripTOUnderTest._getROProperty);
            sinon.assert.calledWith(tabStripTOUnderTest._getROProperty, "name", sinon.match({}));
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            tabStripTOUnderTest._getROProperty.returns(promiseMock);
            var res = tabStripTOUnderTest.name();
            assert.strictEqual(res, promiseMock);
        });
    });

    describe("selectedTab method", function () {
        it("should execute _getROProperty 'selection'", function () {
            tabStripTOUnderTest.selectedTab();
            sinon.assert.calledOnce(tabStripTOUnderTest._getROProperty);
            sinon.assert.calledWith(tabStripTOUnderTest._getROProperty, "selection", sinon.match({}));
        });

        it("should return promise as is", function () {
            var promiseMock = {};
            tabStripTOUnderTest._getROProperty.returns(promiseMock);
            var res = tabStripTOUnderTest.selectedTab();
            assert.strictEqual(res, promiseMock);
        });
    });

    
    describe("tabs method", function () {
        it("should query the property 'all items'", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("Item1\nItem2");
                }
            };
            tabStripTOUnderTest._getROProperty.returns(promiseMock);
            tabStripTOUnderTest.tabs();
            sinon.assert.calledOnce(tabStripTOUnderTest._getROProperty);
            sinon.assert.calledWith(tabStripTOUnderTest._getROProperty, "all items");
        });

        it("should return empty list if no item returns from _getROProperty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("");
                }
            };

            tabStripTOUnderTest._getROProperty.returns(promiseMock);
            var res = tabStripTOUnderTest.tabs();
            assert.deepEqual(res, []);
        });

        it("should return a list  with tabs if tabs returns from _getROProperty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("Item1\nItem2");
                }
            };

            tabStripTOUnderTest._getROProperty.returns(promiseMock);
            var res = tabStripTOUnderTest.tabs();
            assert.deepEqual(res, ["Item1", "Item2"]);
        });
    });

    describe("select method", function () {
        it("should throw error if indexOrItem is undefined", function () {
            assert.throws(function () {
                tabStripTOUnderTest.select();
            });
        });

        it("should throw error if indexOrItem is null", function () {
            assert.throws(function () {
                tabStripTOUnderTest.select(null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            tabStripTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = tabStripTOUnderTest.select(10);
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'Select' if indexOrItem is a number", function () {
            tabStripTOUnderTest.select(10);
            sinon.assert.calledOnce(tabStripTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(tabStripTOUnderTest._executeWithEvents, sinon.match({ 0: 10 }), "Select", 10);
        });

        it("should execute _executeWithEvents 'Select' if indexOrItem is a string", function () {
            tabStripTOUnderTest.select("item1");
            sinon.assert.calledOnce(tabStripTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(tabStripTOUnderTest._executeWithEvents, sinon.match({ 0: "item1" }), "Select", "item1");
        });        
    });
});
