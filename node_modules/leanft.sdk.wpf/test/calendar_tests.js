// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 08/18/2016.
 */

var assert = require("assert");
var sinon = require("sinon");
var Core = require("leanft.sdk.core");
var DateFormatType = Core.DateFormatType;
var Q = require("q");

describe("CalendarDescriptionBehavior", function () {

    var Calendar = require("../lib/calendar.js").Calendar;
    var calendarUnderTest;

    beforeEach(function () {
        calendarUnderTest = new Calendar();
    });

    describe("helpText method", function () {
        it("should add 'helptext' to _properties when value is given", function () {
            calendarUnderTest.helpText("SomeHelpText");
            assert.strictEqual(calendarUnderTest._properties["helptext"], "SomeHelpText");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = calendarUnderTest.helpText("SomeHelpText");
            assert.strictEqual(result, calendarUnderTest);
        });

        it("should remove 'helptext' from _properties when value is null", function () {
            calendarUnderTest._properties["helptext"] = "SomeHelpText";
            assert(("helptext" in calendarUnderTest._properties));
            calendarUnderTest.helpText(null);
            assert(!("helptext" in calendarUnderTest._properties));
        });

        it("should return the value of 'SomeHelpText' from _properties when value is not given", function () {
            calendarUnderTest._properties["helptext"] = "SomeHelpText";
            var value = calendarUnderTest.helpText();
            assert.strictEqual(value, "SomeHelpText");
        });
    });

    describe("parentText method", function () {
        it("should add 'parent text' to _properties when value is given", function () {
            calendarUnderTest.parentText("SomeParentText");
            assert.strictEqual(calendarUnderTest._properties["parent text"], "SomeParentText");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = calendarUnderTest.parentText("SomeParentText");
            assert.strictEqual(result, calendarUnderTest);
        });

        it("should remove 'parent text' from _properties when value is null", function () {
            calendarUnderTest._properties["parent text"] = "SomeParentText";
            assert(("parent text" in calendarUnderTest._properties));
            calendarUnderTest.parentText(null);
            assert(!("parent text" in calendarUnderTest._properties));
        });

        it("should return the value of 'SomeParentText' from _properties when value is not given", function () {
            calendarUnderTest._properties["parent text"] = "SomeParentText";
            var value = calendarUnderTest.parentText();
            assert.strictEqual(value, "SomeParentText");
        });
    });
});

describe("CalendarTO Test Object", function () {

    var CalendarTO = require("../lib/calendar.js").CalendarTO;
    var calendarTOUnderTest;

    beforeEach(function () {
        calendarTOUnderTest = new CalendarTO();
        sinon.stub(calendarTOUnderTest, "_executeWithEvents");
        sinon.stub(calendarTOUnderTest, "_getROProperty");
    });

    afterEach(function () {
        calendarTOUnderTest._executeWithEvents.restore();
        calendarTOUnderTest._getROProperty.restore();
    });

    describe("helpText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._getROProperty.returns(executionPromise);
            var res = calendarTOUnderTest.helpText();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'helptext' with correct parameters", function () {
            calendarTOUnderTest.helpText();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "helptext", sinon.match({}));
        });
    });

    describe("parentText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._getROProperty.returns(executionPromise);
            var res = calendarTOUnderTest.parentText();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'parent text' with correct parameters", function () {
            calendarTOUnderTest.parentText();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "parent text", sinon.match({}));
        });
    });

    describe("date method", function () {
        it("should execute _getROProperty 'date' with correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("17-Mar-2016");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            calendarTOUnderTest.date();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "date", sinon.match({}));
        });

        it("should throw error if date is null", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(null);
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOUnderTest.date();
            });
        });

        it("should throw error if date is empty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOUnderTest.date();
            });
        });

        it("should return a date if returned data is valid", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("17-Mar-2016");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.date();
            assert.deepEqual(res, new Date(2016, 2, 17));
        });
    });

    describe("dateRanges method", function () {
        it("should execute _getROProperty 'date' with correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("17-Mar-2016 - 18-May-2016");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            calendarTOUnderTest.dateRanges();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "date", sinon.match({}));
        });

        it("should throw error if date is null", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(null);
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOUnderTest.dateRanges();
            });
        });

        it("should throw error if date is empty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            assert.throws(function () {
                calendarTOUnderTest.dateRanges();
            });
        });

        it("should return a dateRanges if returned data is valid", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("17-Mar-2016 - 18-May-2016; 30-Sep-2015; 18-Apr-2017 - 19-Jun-2017");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.dateRanges();
            assert.deepEqual(res, new Array({startDate: new Date(2016, 2, 17), endDate: new Date(2016, 4, 18)}, {startDate: new Date(2015, 8, 30), endDate: new Date(2015, 8, 30)}, {startDate: new Date(2017, 3, 18), endDate: new Date(2017, 5, 19)}));
        });
    });

    describe("setDate method", function () {
        it("should throw error if date is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDate();
            });
        });

        it("should throw error if date is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDate(null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = calendarTOUnderTest.setDate(new Date(2016, 2, 17));
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetDate' with correct parameter", function () {
            var date = new Date(2016, 2, 17);
            calendarTOUnderTest.setDate(date);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: date }), "SetDate", "17-Mar-2016");
        });
    });

    describe("setDateRange method", function () {
        it("should throw error if dateRangeOrStartDate is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange();
            });
        });

        it("should throw error if dateRangeOrStartDate is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange(null);
            });
        });

        it("should throw error if endDate is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange(new Date(2016, 2, 17));
            });
        });

        it("should throw error if endDate is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange(new Date(2016, 2, 17), null);
            });
        });

        it("should throw error if dateRangeOrStartDate is an object and no have startDate", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange({ endDate: new Date(2016, 2, 17) });
            });
        });

        it("should throw error if dateRangeOrStartDate is an object and no have endDate", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRange({ startDate: new Date(2016, 2, 17) });
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = calendarTOUnderTest.setDateRange(new Date(2016, 2, 17), new Date(2016, 4, 18));
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetDate' with correct parameter if input paramters are 2 dates", function () {
            var date1 = new Date(2016, 2, 17);
            var date2 = new Date(2016, 4, 18);
            calendarTOUnderTest.setDateRange(date1, date2);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: date1, 1: date2 }), "SetDate", "17-Mar-2016 - 18-May-2016");
        });

        it("should execute _executeWithEvents 'SetDate' with correct parameter if input paramater is an object", function () {
            var date1 = new Date(2016, 2, 17);
            var date2 = new Date(2016, 4, 18);
            var range = {startDate: date1, endDate: date2};
            calendarTOUnderTest.setDateRange(range);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: range }), "SetDate", "17-Mar-2016 - 18-May-2016");
        });

        it("should execute _executeWithEvents 'SetDate' with correct parameter if startDate == endDate", function () {
            var date1 = new Date(2016, 2, 17);
            var date2 = new Date(2016, 2, 17);
            var range = {startDate: date1, endDate: date2};
            calendarTOUnderTest.setDateRange(range);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: range }), "SetDate", "17-Mar-2016");
        });
    });

    describe("setDateRanges method", function () {
        beforeEach(function () {
            calendarTOUnderTest._executeWithEvents.returns(Q.resolve());
        });

        it("should throw error if dateRanges is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRanges();
            });
        });

        it("should throw error if dateRanges is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRanges(null);
            });
        });

        it("should throw error if dateRanges is empty", function () {
            assert.throws(function () {
                calendarTOUnderTest.setDateRanges(new Array());
            });
        });

        it("should call setDate for first date range without the true (append) param for a single date range array", function () {
            var range1 = {startDate: new Date(2016, 2, 17), endDate: new Date(2016, 4, 18)};
            return calendarTOUnderTest.setDateRanges([range1]).then(function () {
                sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
                sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents.firstCall, sinon.match({ 0: range1 }), "SetDate", "17-Mar-2016 - 18-May-2016");
            });
        });

        it("should call setDate for each date range, in correct order, for each call after first should add true (append) at the end", function () {
            var range1 = {startDate: new Date(2016, 2, 17), endDate: new Date(2016, 4, 18)};
            var range2 =  {startDate: new Date(2016, 5, 24), endDate: new Date(2016, 5, 24)};
            return calendarTOUnderTest.setDateRanges([range1,range2]).then(function () {
                sinon.assert.calledTwice(calendarTOUnderTest._executeWithEvents);
                sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents.firstCall, sinon.match({ 0: range1 }), "SetDate", "17-Mar-2016 - 18-May-2016");
                sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents.secondCall, sinon.match({ 0: range2 }), "SetDate", "24-Jun-2016", true);
            });
        });

        it("should call setDate for first date range without the true (append) param for a single date range", function () {
            var range1 = {startDate: new Date(2016, 2, 17), endDate: new Date(2016, 4, 18)};
            return calendarTOUnderTest.setDateRanges(range1).then(function () {
                sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
                sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents.firstCall, sinon.match({ 0: range1 }), "SetDate", "17-Mar-2016 - 18-May-2016");
            });
        });

        it("should call setDate for each date range, in correct order, for each call after first should add true (append) at the end, for comma separated date ranges", function () {
            var range1 = {startDate: new Date(2016, 2, 17), endDate: new Date(2016, 4, 18)};
            var range2 =  {startDate: new Date(2016, 5, 24), endDate: new Date(2016, 5, 24)};
            return calendarTOUnderTest.setDateRanges(range1,range2).then(function () {
                sinon.assert.calledTwice(calendarTOUnderTest._executeWithEvents);
                sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents.firstCall, sinon.match({ 0: range1 }), "SetDate", "17-Mar-2016 - 18-May-2016");
                sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents.secondCall, sinon.match({ 0: range2 }), "SetDate", "24-Jun-2016", true);
            });
        });
    });

    describe("setMonth method", function () {
        it("should throw error if month is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setMonth();
            });
        });

        it("should throw error if month is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setMonth(null);
            });
        });

        it("should throw error if month is < 1", function () {
            assert.throws(function () {
                calendarTOUnderTest.setMonth(0);
            });
        });

        it("should throw error if month is > 12", function () {
            assert.throws(function () {
                calendarTOUnderTest.setMonth(13);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = calendarTOUnderTest.setMonth(6);
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetMonth' with correct parameter", function () {
            var month = 7;
            calendarTOUnderTest.setMonth(month);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: month }), "SetMonth", 7);
        });
    });

    describe("setYear method", function () {
        it("should throw error if year is undefined", function () {
            assert.throws(function () {
                calendarTOUnderTest.setYear();
            });
        });

        it("should throw error if year is null", function () {
            assert.throws(function () {
                calendarTOUnderTest.setYear(null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            calendarTOUnderTest._executeWithEvents.returns(executionPromise);
            var res = calendarTOUnderTest.setYear(2009);
            assert.equal(res, executionPromise);
        });

        it("should execute _executeWithEvents 'SetYear' with correct parameter", function () {
            var year = 2010;
            calendarTOUnderTest.setYear(year);
            sinon.assert.calledOnce(calendarTOUnderTest._executeWithEvents);
            sinon.assert.calledWith(calendarTOUnderTest._executeWithEvents, sinon.match({ 0: year }), "SetYear", 2010);
        });
    });

    describe("getDateFormatType method", function () {
        it("should execute _getROProperty 'date' with correct parameters", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("02-Jun-2013");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            calendarTOUnderTest.getDateFormatType();
            sinon.assert.calledOnce(calendarTOUnderTest._getROProperty);
            sinon.assert.calledWith(calendarTOUnderTest._getROProperty, "date", sinon.match({}));
        });

        it("should return DateFormatType.none if date is null", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb(null);
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.getDateFormatType();
            assert.deepEqual(res, DateFormatType.none);
        });

        it("should return DateFormatType.none if date is empty", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.getDateFormatType();
            assert.deepEqual(res, DateFormatType.none);
        });

        it("should return DateFormatType.singleDate if date is a single date", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("02-Jun-2013");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.getDateFormatType();
            assert.deepEqual(res, DateFormatType.singleDate);
        });

        it("should return DateFormatType.singleDateRange if date is a single date range", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("20-Mar-2015 - 22-Aug-2016");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.getDateFormatType();
            assert.deepEqual(res, DateFormatType.singleDateRange);
        });

        it("should return DateFormatType.multipleDateRanges if date is multiple date ranges", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("20-Mar-2015 - 22-Mar-2015; 25-Mar-2015; 28-Mar-2015 - 29-Mar-2015");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.getDateFormatType();
            assert.deepEqual(res, DateFormatType.multipleDateRanges);
        });

        it("should return DateFormatType.none if date is invalid", function () {
            var promiseMock = {
                then: function (cb) {
                    return cb("invalid date");
                }
            };
            calendarTOUnderTest._getROProperty.returns(promiseMock);
            var res = calendarTOUnderTest.getDateFormatType();
            assert.deepEqual(res, DateFormatType.none);
        });
    });
});
