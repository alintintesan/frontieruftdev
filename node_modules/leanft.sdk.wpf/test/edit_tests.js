// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..
/*
 * Created on 09/16/2016.
 */

var assert = require("assert");
var sinon = require("sinon");
var Edit = require("../lib/edit.js").Edit;
var Core = require("leanft.sdk.core");
var Convert = Core.Convert;

describe("Edit Description", function () {

    var editDescriptionUnderTest;

    beforeEach(function () {
        editDescriptionUnderTest = new Edit();
    });

    describe("Constructor", function () {
        it("should assign 'WPF' and 'Edit' LeanFT type", function () {
            editDescriptionUnderTest = new Edit();
            assert.deepEqual(editDescriptionUnderTest.leanFTType, {
                technology: "WPF",
                leanftType: "EditField"
            });
        });
    });

    describe("isReadOnly method",function() {
        it("should add 'isreadonly' to _properties when value is given", function () {
            editDescriptionUnderTest.isReadOnly(true);
            assert.strictEqual(editDescriptionUnderTest._properties["isreadonly"], true);
        });

        it("should add 'isreadonly' to _properties when value is given in string", function () {
            editDescriptionUnderTest.isReadOnly("true");
            assert.strictEqual(editDescriptionUnderTest._properties["isreadonly"], true);
        });

        it("should return this - builder pattern when value is given", function () {
            var result = editDescriptionUnderTest.isReadOnly(true);
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'isreadonly' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["isreadonly"] = true;
            assert(("isreadonly" in editDescriptionUnderTest._properties));
            editDescriptionUnderTest.isReadOnly(null);
            assert(!("isreadonly" in editDescriptionUnderTest._properties));
        });

        it("should return the value of true from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["isreadonly"] = true;
            var result = editDescriptionUnderTest.isReadOnly();
            assert.equal(result, true);
        });
    });

    describe("name method", function () {
        it("should add 'name' to _properties when value is given", function () {
            editDescriptionUnderTest.name("somename");
            assert.strictEqual(editDescriptionUnderTest._properties["name"], "somename");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = editDescriptionUnderTest.name("somename");
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'name' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["name"] = "somename";
            assert(("name" in editDescriptionUnderTest._properties));
            editDescriptionUnderTest.name(null);
            assert(!("name" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'somename' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["name"] = "somename";
            var value = editDescriptionUnderTest.name();
            assert.strictEqual(value, "somename");
        });
    });

    describe("parentText method", function () {
        it("should add 'parent text' to _properties when value is given", function () {
            editDescriptionUnderTest.parentText("SomeParentText");
            assert.strictEqual(editDescriptionUnderTest._properties["parent text"], "SomeParentText");
        });

        it("should return this - builder pattern, when value is given", function () {
            var result = editDescriptionUnderTest.parentText("SomeParentText");
            assert.strictEqual(result, editDescriptionUnderTest);
        });

        it("should remove 'parent text' from _properties when value is null", function () {
            editDescriptionUnderTest._properties["parent text"] = "SomeParentText";
            assert(("parent text" in editDescriptionUnderTest._properties));
            editDescriptionUnderTest.parentText(null);
            assert(!("parent text" in editDescriptionUnderTest._properties));
        });

        it("should return the value of 'SomeParentText' from _properties when value is not given", function () {
            editDescriptionUnderTest._properties["parent text"] = "SomeParentText";
            var value = editDescriptionUnderTest.parentText();
            assert.strictEqual(value, "SomeParentText");
        });
    });
});

describe("Edit Test Object", function () {
    var EditTO = require("../lib/edit.js").EditTO;
    var editTestObjectUnderTest;

    beforeEach(function () {
        editTestObjectUnderTest = new EditTO();
        sinon.stub(editTestObjectUnderTest, "_getROProperty");
        sinon.stub(editTestObjectUnderTest, "_executeWithEvents");
    });

    describe("Constructor", function () {
        it("should assign 'WpfEdit' native class", function () {
            assert.deepEqual(editTestObjectUnderTest._nativeClass, "WpfEdit");
        });
    });

    describe("isReadOnly method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.isReadOnly();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'isreadonly' with correct parameters", function () {
            editTestObjectUnderTest.isReadOnly();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "isreadonly", sinon.match({}));
        });
    });

    describe("name method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.name();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'name' with correct parameters", function () {
            editTestObjectUnderTest.name();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "name", sinon.match({}));
        });
    });

    describe("parentText method", function () {
        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._getROProperty.returns(executionPromise);
            var res = editTestObjectUnderTest.parentText();
            assert.equal(res, executionPromise);
        });

        it("should execute _getROProperty 'parent text' with correct parameters", function () {
            editTestObjectUnderTest.parentText();
            sinon.assert.calledOnce(editTestObjectUnderTest._getROProperty);
            sinon.assert.calledWith(editTestObjectUnderTest._getROProperty, "parent text", sinon.match({}));
        });
    });

    describe("setText method", function () {
        it("should throw error if no arguments passed", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setText();
            });
        });
        it("should throw error if null passed", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setText(null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setText("sometext");
            assert.equal(res, executionPromise);
        });

        it("should call _executeWithEvents and pass it the correct arguments if the input is string", function () {
            editTestObjectUnderTest.setText("sometext");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "sometext" }), "Set", "sometext");
        });
    });

    describe("select method", function () {
        it("should throw error if no arguments passed", function () {
            assert.throws(function () {
                editTestObjectUnderTest.select();
            });
        });

        it("should throw error if fromCharPos is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.select(null);
            });
        });

        it("should throw error if toCharPos is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.select(10, null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.select(10, 20);
            assert.equal(res, executionPromise);
        });

        it("should call _executeWithEvents and pass it the correct arguments", function () {
            editTestObjectUnderTest.select(10, 20);
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: 10, 1: 20 }), "SetSingleLineSelection", 10, 21);
        });
    });

    describe("selectMulti method", function () {
        it("should throw error if no arguments passed", function () {
            assert.throws(function () {
                editTestObjectUnderTest.selectMulti();
            });
        });

        it("should throw error if fromCharPos is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.selectMulti(null);
            });
        });

        it("should throw error if toCharPos is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.selectMulti(10, null);
            });
        });

        it("should throw error if toLine is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.selectMulti(10, 20, null, 30);
            });
        });
        
        it("should throw error if toCharPos is null", function () {
            assert.throws(function () {
                editTestObjectUnderTest.selectMulti(10, 20, 30, null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.selectMulti(10, 20, 30, 40);
            assert.equal(res, executionPromise);
        });

        it("should call _executeWithEvents and pass it the correct arguments", function () {
            editTestObjectUnderTest.selectMulti(10, 20, 30, 40);
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: 10, 1: 20, 2: 30, 3: 40 }), "SetMultiLineSelection", 10, 20, 30, 40);
        });
    });

    describe("setSecure method", function () {
        it("should throw error if no arguments passed", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setSecure();
            });
        });
        it("should throw error if null passed", function () {
            assert.throws(function () {
                editTestObjectUnderTest.setSecure(null);
            });
        });

        it("should return the execution promise", function () {
            var executionPromise = {};
            editTestObjectUnderTest._executeWithEvents.returns(executionPromise);
            var res = editTestObjectUnderTest.setSecure("someencodedtext");
            assert.equal(res, executionPromise);
        });

        it("should call _executeWithEvents and pass it the correct arguments if the input is string", function () {
            editTestObjectUnderTest.setSecure("someencodedtext");
            sinon.assert.calledOnce(editTestObjectUnderTest._executeWithEvents);
            sinon.assert.calledWith(editTestObjectUnderTest._executeWithEvents, sinon.match({ 0: "someencodedtext" }), "SetSecure", "someencodedtext");
        });
    });
});
