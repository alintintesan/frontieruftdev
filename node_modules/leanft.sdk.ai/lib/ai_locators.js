// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/* jshint esversion: 6 */

const LocatorType = {
    Positional: 0,
    Relational: 1
};

const LocatorsMap = {
    fromtop: { caseSensitiveName: "fromTop", type: LocatorType.Positional },
    fromleft: { caseSensitiveName: "fromLeft", type: LocatorType.Positional },
    fromright: { caseSensitiveName: "fromRight", type: LocatorType.Positional },
    frombottom: { caseSensitiveName: "fromBottom", type: LocatorType.Positional },
    withanchorabove: { caseSensitiveName: "withAnchorAbove", type: LocatorType.Relational },
    withanchorbelow: { caseSensitiveName: "withAnchorBelow", type: LocatorType.Relational },
    withanchoronleft: { caseSensitiveName: "withAnchorOnLeft", type: LocatorType.Relational },
    withanchoronright: { caseSensitiveName: "withAnchorOnRight", type: LocatorType.Relational }
};

const AILocators = {

    LeanFtLocator_to_SdkLocator: (locator, locatorData) => {

        // if 'locator' property is not defined then locator is undefined
        if (locator === undefined) {
            return undefined;
        }

        let sdkLocator = AILocators._LeanFtLocator_to_SdkDirectionOrRelation(locator);
        if (sdkLocator.type === LocatorType.Positional) {
            return {
                direction: sdkLocator.value,
                index: AILocators._LeanFtLocatorData_to_SdkIndex(locatorData)
            };
        }
        else if (sdkLocator.type === LocatorType.Relational) {
            return {
                relation: sdkLocator.value,
                anchor: AILocators._LeanFtLocatorData_to_SdkAnchor(locatorData)
            };
        }
    },

    SdkLocator_to_LeanFtLocator: (locator) => {

        return AILocators._SdkPositionalLocator_to_LeanFtLocator(locator) || AILocators._SdkRelationalLocator_to_LeanFtLocator(locator);
    },

    _SdkPositionalLocator_to_LeanFtLocator: (locator) => {

        if (locator.direction == null) {
            return undefined;
        }

        return {
            leanFtLocator: AILocators._SdkLocatorName_to_LeanFtLocator(locator.direction, LocatorType.Positional),
            leanFtLocatorData: AILocators._SdkIndex_to_LeanFtLocatorData(locator.index)
        };
    },

    _SdkRelationalLocator_to_LeanFtLocator: (locator) => {

        if (locator.relation == null) {
            return undefined;
        }

        return {
            leanFtLocator: AILocators._SdkLocatorName_to_LeanFtLocator(locator.relation, LocatorType.Relational),
            leanFtLocatorData: AILocators._SdkAnchor_to_LeanFtLocatorData(locator.anchor)
        };
    },

    _SdkLocatorName_to_LeanFtLocator: (locator, locatorType) => {

        if (typeof(locator) !== "string") {
            throw new Error(`Unexpected type for ${locator} property value`);
        }

        let locatorName = locatorType === LocatorType.Positional ? "direction" : "relation";

        let locatorLowerCase = locator.toLowerCase();
        let entry = LocatorsMap[locatorLowerCase];
        if (entry == null) {
            throw new Error(`Unsupported value for ${locatorName} property`);
        }
        if (entry.type !== locatorType) {
            throw new Error(`Unexpected value for ${locatorName} property`);
        }
        return entry.caseSensitiveName;
    },

    _SdkIndex_to_LeanFtLocatorData: (index) => {
        // 1) LeanFT locator_data property is one-based while the SDK index is zero-based.
        // 2) If SDK index property is not defined we should use default [1]
        return (index || 0) + 1;
    },

    _SdkAnchor_to_LeanFtLocatorData: (anchor) => {

        if (anchor == null) {
            throw new Error("anchor is mandatory when using relational locator");
        }
        if (typeof(anchor) !== 'object' || typeof(anchor._toJSON) !== 'function') {
            throw new Error("Unexpected type for relation anchor value");
        }

        return {
            _flat: () => {
                return {
                    locator_data: Object.assign({Type: "PropTestObject"}, anchor._toJSON())
                };
            },
            _anchor: anchor
        };
    },

    _LeanFtLocator_to_SdkDirectionOrRelation: (locator) => {

        if (typeof(locator) !== "string") {
            throw new Error("Unexpected type for locator property value");
        }

        let locatorLowerCase = locator.toLowerCase();
        if (LocatorsMap[locatorLowerCase] == null) {
            throw new Error("Unexpected value for locator property value");
        }

        return {
            type: LocatorsMap[locatorLowerCase].type,
            value: LocatorsMap[locatorLowerCase].caseSensitiveName
        };
    },

    _LeanFtLocatorData_to_SdkIndex: (locatorData) => {
        // 1) LeanFT locator_data property is one-based while the SDK index is zero-based.
        // 2) If LeanFT locator_data property is not defined  we should use default [0]
        return (locatorData || 1) - 1;
    },

    _LeanFtLocatorData_to_SdkAnchor: (/*locatorData*/) => {
        // Currently we do not use the anchor getter so we do not convert the value.
        // If needed, the anchor SDK Test Object can be found in locatorData._anchor
        return null;
    }
};

module.exports.AILocators = AILocators;