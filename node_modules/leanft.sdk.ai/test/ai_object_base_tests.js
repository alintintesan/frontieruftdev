// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/* jshint esversion: 6 */

const assert = require("assert");
const sinon = require("sinon");

describe("UI Object Base Description", function () {

    let UiObjectBaseDescription = require("../lib/ai_object_base.js").AiObjectBaseDescription;
    let uiObjectBaseDescriptionUnderTest;

    beforeEach(function () {
        uiObjectBaseDescriptionUnderTest = new UiObjectBaseDescription();
    });

    describe("Constructor", function () {
        it("should assign 'AI' and LeanFT type", function () {
            uiObjectBaseDescriptionUnderTest = new UiObjectBaseDescription("UiObject");
            assert.deepEqual(uiObjectBaseDescriptionUnderTest.leanFTType, {
                technology: "AI",
                leanftType: "UiObject"
            });
        });
    });

    describe("text method", function () {
        it("should add 'text' to _properties when value is given", function () {
            uiObjectBaseDescriptionUnderTest.text("some text");
            assert.strictEqual(uiObjectBaseDescriptionUnderTest._properties["text"], "some text");
        });

        it("should return this - builder pattern when value is given", function () {
            let result = uiObjectBaseDescriptionUnderTest.text("some text");
            assert.strictEqual(result, uiObjectBaseDescriptionUnderTest);
        });

        it("should remove 'text' from _properties when value is null", function () {
            uiObjectBaseDescriptionUnderTest._properties["text"] = "some text";
            uiObjectBaseDescriptionUnderTest.text(null);
            assert(!("text" in uiObjectBaseDescriptionUnderTest._properties));
        });

        it("should return the value of 'text' from _properties when value is not given", function () {
            uiObjectBaseDescriptionUnderTest._properties["text"] = "some text";
            let result = uiObjectBaseDescriptionUnderTest.text();
            assert.equal(result, "some text");
        });
    });

    describe("aiClass method", function () {
        it("should add 'aiClass' to _properties when value is given", function () {
            uiObjectBaseDescriptionUnderTest.aiClass("some class");
            assert.strictEqual(uiObjectBaseDescriptionUnderTest._properties["control_class"], "some class");
        });

        it("should return this - builder pattern when value is given", function () {
            let result = uiObjectBaseDescriptionUnderTest.aiClass("some class");
            assert.strictEqual(result, uiObjectBaseDescriptionUnderTest);
        });

        it("should remove 'aiClass' from _properties when value is null", function () {
            uiObjectBaseDescriptionUnderTest._properties["control_class"] = "some class";
            uiObjectBaseDescriptionUnderTest.aiClass(null);
            assert(!("control_class" in uiObjectBaseDescriptionUnderTest._properties));
        });

        it("should return the value of 'aiClass' from _properties when value is not given", function () {
            uiObjectBaseDescriptionUnderTest._properties["control_class"] = "some class";
            let native = uiObjectBaseDescriptionUnderTest.aiClass();
            assert.equal(native, "some class");
        });
    });

    describe("locator method", function () {
        let locator;
        let locatorValue;
        let locatorDataValue;

        beforeEach(function () {
            locator = {
                direction: "fromLeft",
                index: 3
            };
            locatorValue = "fromLeft";
            locatorDataValue = 4;
        });

        it("should add 'locator' and 'locator_data' to _properties when positional value is given.", function () {
            uiObjectBaseDescriptionUnderTest.locator(locator);
            assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator"], locatorValue);
            assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator_data"], locatorDataValue);
        });

        it("should add 'locator' and 'locator_data' to _properties when positional value is given ignore case.", function () {
            locator.direction = "FROMLEft";
            uiObjectBaseDescriptionUnderTest.locator(locator);
            assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator"], locatorValue);
            assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator_data"], locatorDataValue);
        });

        it("should set correct value for 'locator_data' when positional value is given without 'index'.", function () {
            delete locator.index;
            locatorDataValue = 1;
            
            uiObjectBaseDescriptionUnderTest.locator(locator);
            assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator_data"], locatorDataValue);
        });

        it("should return this - builder pattern when positional value is given", function () {
            let result = uiObjectBaseDescriptionUnderTest.locator(locator);
            assert.strictEqual(result, uiObjectBaseDescriptionUnderTest);
        });

        it("should remove 'locator' and 'locator_data' from _properties when value is null", function () {
            uiObjectBaseDescriptionUnderTest._properties["locator"] = locatorValue;
            uiObjectBaseDescriptionUnderTest._properties["locator_data"] = locatorDataValue;
            uiObjectBaseDescriptionUnderTest.locator(null);
            assert(!("locator" in uiObjectBaseDescriptionUnderTest._properties));
            assert(!("locator_data" in uiObjectBaseDescriptionUnderTest._properties));
        });

        it("should return the positional value from 'locator' and 'locator_data' _properties when value is not given", function () {
            uiObjectBaseDescriptionUnderTest._properties["locator"] = locatorValue;
            uiObjectBaseDescriptionUnderTest._properties["locator_data"] = locatorDataValue;
            let native = uiObjectBaseDescriptionUnderTest.locator();
            assert.deepEqual(native, locator);
        });

        it("should return correct positional value of index when value is not given and 'locator_data' is not present in _properties", function () {
            uiObjectBaseDescriptionUnderTest._properties["locator"] = locatorValue;
            delete uiObjectBaseDescriptionUnderTest._properties["locator_data"];
            locator.index = 0;
            
            let native = uiObjectBaseDescriptionUnderTest.locator();
            assert.deepEqual(native, locator);
        });

        it("should return undefined when 'locator' is not present in _properties", function () {
            delete uiObjectBaseDescriptionUnderTest._properties["locator"];
            delete uiObjectBaseDescriptionUnderTest._properties["locator_data"];
            
            let native = uiObjectBaseDescriptionUnderTest.locator();
            assert.deepEqual(native, undefined);
        });

        it("should throw when positional value is given with relational direction name", function () {
            locator.direction = "withAnchorAbove";
            try {
                uiObjectBaseDescriptionUnderTest.locator(locator);
                assert.fail("Not supposed to get here");
            }
            catch(err) {
                assert.equal(err.message, "Unexpected value for direction property");
            }
        });

        it("should throw when positional value is given with unknown direction name", function () {
            locator.direction = "lala";
            try {
                uiObjectBaseDescriptionUnderTest.locator(locator);
                assert.fail("Not supposed to get here");
            }
            catch(err) {
                assert.equal(err.message, "Unsupported value for direction property");
            }
        });

        describe('relational locator', () => {

            let anchor;
            let anchor_json;
            let relationalLocator;
            let relationalLocatorValue;
            let relationalLocatorDataValue;

            beforeEach(function () {

                anchor_json = { value: "anchor test object as JSON"};
                anchor = {
                    _toJSON: () => { return anchor_json; }
                }
                relationalLocator = {
                    relation: "withAnchorAbove",
                    anchor: anchor
                }

                relationalLocatorValue = "withAnchorAbove";
                relationalLocatorDataValue = {
                    locator_data: {
                        Type: "PropTestObject",
                        value: anchor_json.value
                    }
                };
            });

            it("should add 'locator' and 'locator_data' to _properties when relational value is given.", function () {
                uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator"], relationalLocatorValue);
                assert.equal(typeof(uiObjectBaseDescriptionUnderTest._properties["locator_data"]._flat), 'function');
                assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator_data"]._flat(), relationalLocatorDataValue);
            });

            it("should add 'locator' and 'locator_data' to _properties when relational value is given ignore case.", function () {
                relationalLocator.relation = "WITHanchorABOVE";
                uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator"], relationalLocatorValue);
                assert.equal(typeof(uiObjectBaseDescriptionUnderTest._properties["locator_data"]._flat), 'function');
                assert.deepEqual(uiObjectBaseDescriptionUnderTest._properties["locator_data"]._flat(), relationalLocatorDataValue);
            });

            it("should throw when relational value is given without 'anchor'", function () {
                delete relationalLocator.anchor;

                try {
                    uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                    assert.fail("Not supposed to get here");
                }
                catch(err) {
                    assert.equal(err.message, "anchor is mandatory when using relational locator");
                }
            });

            it("should throw when relational value is given with positional relation name", function () {
                relationalLocator.relation = "fromTop";
                try {
                    uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                    assert.fail("Not supposed to get here");
                }
                catch(err) {
                    assert.equal(err.message, "Unexpected value for relation property");
                }
            });

            it("should throw when relational value is given with unknown relation name", function () {
                relationalLocator.relation = "lala";
                try {
                    uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                    assert.fail("Not supposed to get here");
                }
                catch(err) {
                    assert.equal(err.message, "Unsupported value for relation property");
                }
            });

            it("should throw when relational value 'anchor' is not an object", function () {
                relationalLocator.anchor = "anchor";

                try {
                    uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                    assert.fail("Not supposed to get here");
                }
                catch(err) {
                    assert.equal(err.message, "Unexpected type for relation anchor value");
                }
            });

            it("should throw when relational value 'anchor' does not have _toJSON() function", function () {
                relationalLocator.anchor = {};

                try {
                    uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                    assert.fail("Not supposed to get here");
                }
                catch(err) {
                    assert.equal(err.message, "Unexpected type for relation anchor value");
                }
            });

            it("should return this - builder pattern when relational value is given", function () {
                let result = uiObjectBaseDescriptionUnderTest.locator(relationalLocator);
                assert.strictEqual(result, uiObjectBaseDescriptionUnderTest);
            });

            it("should return the relational value from 'locator' and 'locator_data' _properties when value is not given", function () {
                uiObjectBaseDescriptionUnderTest._properties["locator"] = relationalLocatorValue;
                uiObjectBaseDescriptionUnderTest._properties["locator_data"] = relationalLocatorDataValue;
                let native = uiObjectBaseDescriptionUnderTest.locator();

                relationalLocator.anchor = null;
                assert.deepEqual(native, relationalLocator);
            });
        });
    });

});

describe("UI Object Base Test Object", function () {

    let UiObjectBaseTO = require("../lib/ai_object_base.js").AiObjectBaseTO;
    let uiObjectBaseTOUnderTest;

    beforeEach(function () {
        uiObjectBaseTOUnderTest = new UiObjectBaseTO();        
        sinon.stub(uiObjectBaseTOUnderTest, "_getROProperty");
        sinon.stub(uiObjectBaseTOUnderTest, "_executeWithEvents"); 
    });

    afterEach(function () {
        uiObjectBaseTOUnderTest._getROProperty.restore();
        uiObjectBaseTOUnderTest._executeWithEvents.restore();
    });

    describe("aiClass method", function () {
        it("should execute _getROProperty 'aiClass'", function () {
            uiObjectBaseTOUnderTest.aiClass();
            sinon.assert.calledOnce(uiObjectBaseTOUnderTest._getROProperty);
            sinon.assert.calledWith(uiObjectBaseTOUnderTest._getROProperty, "control_class", sinon.match({}));
        });

        it("should return promise as is", function () {
            let promiseMock = {};
            uiObjectBaseTOUnderTest._getROProperty.returns(promiseMock);
            let res = uiObjectBaseTOUnderTest.aiClass();
            assert.strictEqual(res, promiseMock);
        });
    });



    describe("text method", function () {
        it("should execute _getROProperty 'text'", function () {
            uiObjectBaseTOUnderTest.text();
            sinon.assert.calledOnce(uiObjectBaseTOUnderTest._getROProperty);
            sinon.assert.calledWith(uiObjectBaseTOUnderTest._getROProperty, "text", sinon.match({}));
        });

        it("should return promise as is", function () {
            let promiseMock = {};
            uiObjectBaseTOUnderTest._getROProperty.returns(promiseMock);
            let res = uiObjectBaseTOUnderTest.text();
            assert.strictEqual(res, promiseMock);
        });
    });
    
});
