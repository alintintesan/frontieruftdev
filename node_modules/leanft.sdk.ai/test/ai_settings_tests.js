// (c) Copyright 2015 - 2023 Micro Focus or one of its affiliates..

/* jshint esversion: 6 */

const assert = require("assert");
const sinon = require("sinon");
const Q = require("q");

const AIRunSettings = require("../lib/ai_settings.js").AIRunSettings;

describe("AIRunSettings", () => {
    
    let sandbox;
    let aiRunSettingsUnderTest;
    let sessionMock;
    let ocrSettings;
    
    beforeEach(() => {
        sandbox = sinon.sandbox.create();
        
        ocrSettings = { "some key": "some value" };
        
        sessionMock = {
            _communication: {
                send: sandbox.stub().returns(Q.resolve("some value"))
            }
        };
        aiRunSettingsUnderTest = new AIRunSettings(sessionMock);
    });

    describe("OCR", () => {

        describe("set()", () => {
        
            it("should send update message with input settings under 'ocr_options' to the engine", () => {
                
                return aiRunSettingsUnderTest.OCR.set(ocrSettings)
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                ocr_options: ocrSettings 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should send update message with merged settings under 'ocr_options' to the engine even if 'ocr_options' were not empty before the call", () => {
                
                aiRunSettingsUnderTest._sessionSettings = {
                    ocr_options: { "some key": "initial value" , "some other key": "some other value"}
                }
                
                return aiRunSettingsUnderTest.OCR.set(ocrSettings)
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                ocr_options: {
                                    "some key": "some value", 
                                    "some other key": "some other value"
                                } 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should send update message with input settings and other existing settings to the engine", () => {
                
                aiRunSettingsUnderTest._sessionSettings = {
                    "other_options": { "some other key": "some other value" }
                }
                
                return aiRunSettingsUnderTest.OCR.set(ocrSettings)
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                ocr_options: ocrSettings,
                                other_options: { "some other key": "some other value" }
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should return empty result even if the update message returned a value", () => {

                return aiRunSettingsUnderTest.OCR.set(ocrSettings)
                    .then((res) => {
                        assert.strictEqual(res, undefined);
                    });
            });

            it("should fail if the update message failed", () => {

                let error = new Error("some error");
                sessionMock._communication.send.returns(Q.reject(error));
                
                return aiRunSettingsUnderTest.OCR.set(ocrSettings)
                    .then((res) => {
                        assert.fail("should not get here");
                    }, (err) => {
                        assert.strictEqual(err, error);
                    });
            });
        });
    });

    describe("autoscroll", () => {

        describe("enable()", () => {
        
            it("should send update message with enabled:true settings under 'autoscroll_options' to the engine", () => {
                
                return aiRunSettingsUnderTest.autoScroll.enable()
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {"enabled": true} 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should send update message with merged settings under 'autoscroll_options' to the engine even if 'autoscroll_options' were not empty before the call", () => {
                
                aiRunSettingsUnderTest._sessionSettings = {
                    autoscroll_options: { "enabled": false , "some other key": "some other value"}
                }
                
                return aiRunSettingsUnderTest.autoScroll.enable()
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {
                                    "enabled": true, 
                                    "some other key": "some other value"
                                } 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should merge enabled:true with settings and send update message with settings under 'autoscroll_options' to the engine", () => {
                
                return aiRunSettingsUnderTest.autoScroll.enable({"some other key": "some other value"})
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {
                                    "enabled": true,
                                    "some other key": "some other value"
                                } 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should send update message with merged {enabled:true}, settings and settings under 'autoscroll_options' to the engine when 'autoscroll_options' were not empty before the call", () => {
                
                aiRunSettingsUnderTest._sessionSettings = {
                    autoscroll_options: { "enabled": "intial value", "some key": "initial value" , "some other key": "some other value"}
                }
                
                return aiRunSettingsUnderTest.autoScroll.enable({"some key": "some value"})
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {
                                    "enabled": true,
                                    "some key": "some value", 
                                    "some other key": "some other value"
                                } 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should send update message with input settings and other existing settings to the engine", () => {
                
                aiRunSettingsUnderTest._sessionSettings = {
                    "other_options": { "some other key": "some other value" }
                }
                
                return aiRunSettingsUnderTest.autoScroll.enable()
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {enabled:true},
                                other_options: { "some other key": "some other value" }
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should return empty result even if the update message returned a value", () => {

                return aiRunSettingsUnderTest.autoScroll.enable()
                    .then((res) => {
                        assert.strictEqual(res, undefined);
                    });
            });

            it("should fail if the update message failed", () => {

                let error = new Error("some error");
                sessionMock._communication.send.returns(Q.reject(error));
                
                return aiRunSettingsUnderTest.autoScroll.enable()
                    .then((res) => {
                        assert.fail("should not get here");
                    }, (err) => {
                        assert.strictEqual(err, error);
                    });
            });
        });

        describe("disable()", () => {
        
            it("should send update message with enabled:false settings under 'autoscroll_options' to the engine", () => {
                
                return aiRunSettingsUnderTest.autoScroll.disable()
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {"enabled": false} 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should send update message with merged settings under 'autoscroll_options' to the engine even if 'autoscroll_options' were not empty before the call", () => {
                
                aiRunSettingsUnderTest._sessionSettings = {
                    autoscroll_options: { "enabled": true , "some other key": "some other value"}
                }
                
                return aiRunSettingsUnderTest.autoScroll.disable()
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {
                                    "enabled": false, 
                                    "some other key": "some other value"
                                } 
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should send update message with input settings and other existing settings to the engine", () => {
                
                aiRunSettingsUnderTest._sessionSettings = {
                    "other_options": { "some other key": "some other value" }
                }
                
                return aiRunSettingsUnderTest.autoScroll.disable()
                    .then(() => {
                        
                        let expectedMsg = { 
                            AIRunSettings: {
                                autoscroll_options: {enabled:false},
                                other_options: { "some other key": "some other value" }
                            }
                        };
                        
                        sinon.assert.calledOnce(sessionMock._communication.send);
                        sinon.assert.calledWith(sessionMock._communication.send, "UpdateAIRunSettings", expectedMsg);
                    });
            });

            it("should return empty result even if the update message returned a value", () => {

                return aiRunSettingsUnderTest.autoScroll.disable()
                    .then((res) => {
                        assert.strictEqual(res, undefined);
                    });
            });

            it("should fail if the update message failed", () => {

                let error = new Error("some error");
                sessionMock._communication.send.returns(Q.reject(error));
                
                return aiRunSettingsUnderTest.autoScroll.disable()
                    .then((res) => {
                        assert.fail("should not get here");
                    }, (err) => {
                        assert.strictEqual(err, error);
                    });
            });
        });
    });
});